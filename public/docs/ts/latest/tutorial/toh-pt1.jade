include ../_util-fns

:marked
  # 옛날 옛적에

  모든 스토리는 어딘가로부터 시작됩니다. 우리의 이야기는 [퀵스타트](../quickstart.html)가 끝나는 지점에서 시작합니다.

  [파트 1에 대한 라이브 예제를 실행해보세요](/resources/live-examples/toh-1/ts/plnkr.html)

  `angular2-tour-of-heroes`라는 이름의 폴더를 만들고 요구사항, 폴더 구조, 그리고 Tour of Heroes를 위한 주요 파일들을 만들기 위해 
  [퀵스타트](../quickstart.html)의 단계들을 따라 해보세요.

include ../_quickstart_repo
:marked
  다음의 구조를 가지고 있어야 합니다:

.filetree
  .file angular2-tour-of-heroes
  .children
    .file app
    .children
      .file app.component.ts
      .file main.ts
    .file node_modules ...
    .file typings ...      
    .file index.html
    .file package.json
    .file styles.css
    .file systemjs.config.js
    .file tsconfig.json
    .file typings.json
:marked
  ## 앱 트랜스파일링과 실행을 유지하세요
  TypeScript 컴파일러 시작, 변경을 위한 watch, 그리고 서버 시작을 원할 겁니다. 다음 명령어를 통해 이런 것들이 가능합니다.

code-example(format="" language="bash").
  npm start

:marked
  이 명령은 watch 모드의 컴파일러를 실행하고 서버를 시작하며, 브라우저에서 앱을 시작시키며 Tour of Heroes를 빌드하는 내내 앱 실행을 유지시켜 줄 겁니다.

.l-main-section
  :marked
    ## 영웅을 보여주세요
    우리의 앱 내에서 영웅의 데이터를 디스플레이하길 원할겁니다. 

    `AppComponent`에 두 개의 프로퍼티를 추가해보세요. 하나는 `title` 프로퍼티로 애플리케이션 이름을 위한 것이고, 다른 하나는 "Windstorm"이라는 영웅을 위한 `hero` 프로퍼티입니다.

  +makeExample('toh-1/ts-snippets/app.component.snippets.pt1.ts', 'app-component-1', 'app.component.ts (AppComponent class)')(format=".")

  :marked
    이제 `@Component` 데코레이션 내에서 이 새로운 프로퍼티에 대한 데이터 바인딩으로 템플릿을 갱신할 차례입니다.

  +makeExample('toh-1/ts-snippets/app.component.snippets.pt1.ts', 'show-hero')

  :marked
    브라우저가 리프레시되고 제목과 영웅이 디스플레이되어야 합니다.

    이중 중괄호는 우리의 앱에게 컴포넌트로부터 `title`과 `hero` 프로퍼티를 읽고 그들을 렌더링하라고 지시합니다.
    이것이 단방향 데이터 바인딩의 "삽입 어구" 형태입니다.
.l-sub-section
  :marked
    [데이터 디스플레이하기 챕터](../guide/displaying-data.html)에서 삽입 어구에 대해 좀 더 배워보세요.
:marked
  ### 영웅 객체

  지금 현재, 우리의 영웅은 단지 이름으로 존재합니다. 우리의 영웅은 좀 더 많은 프로퍼티를 필요로 합니다.
  `hero`를 리터럴 문자열으로부터 클래스로 바꿔보죠.

  `id`와 `name`이라는 프로퍼티를 가진 `Hero` 클래스를 만듭니다.
  `app.component.ts' 파일 상단 근처 import 구문 바로 아래에 이것을 집어넣습니다.

+makeExample('toh-1/ts/app/app.component.ts', 'hero-class-1', 'app.component.ts (Hero class)')(format=".")

:marked
  이제 `Hero` 클래스를 갖게 되었으니, 컴포넌트의 `hero` 프로퍼티를 `Hero` 타입으로 리팩토링해보죠. 
  그런 뒤에 아이디를 `1`로, 이름을 "Windstorm"으로 초기화해줍니다.

+makeExample('toh-1/ts-snippets/app.component.snippets.pt1.ts', 'hero-property-1', 'app.component.ts (Hero property)')(format=".")

:marked
  영웅을 문자열에서 객체로 변경했기에, 영웅의 `name` 프로퍼티에 대한 템플릿 내 참조 바인딩을 갱신해야 합니다.

+makeExample('toh-1/ts-snippets/app.component.snippets.pt1.ts', 'show-hero-2')
:marked
  브라우저가 리프레시되고 계속해서 영웅의 이름이 디스플레이될 겁니다.

  ### HTML 추가하기
  이름을 디스플레이하는 것은 좋지만, 우리는 영웅의 모든 프로퍼티를 봤으면 합니다.
  영웅의 `id` 프로퍼티와 `name` 프로퍼티를 위한 각각의 `<div>`를 추가할 겁니다.

+makeExample('toh-1/ts-snippets/app.component.snippets.pt1.ts', 'show-hero-properties')
:marked
  어라, 템플릿 문자열이 좀 길어졌네요. 템플릿 내 글자가 늘어나는 부담을 해소하기 위해 좀 더 좋게 만들어보죠.

  ### 멀티라인 템플릿 문자열

  문자열 합치기(concatenation)으로 좀 더 읽기 좋은 템플릿을 만들 수도 있지만
  그건 점점 보기 싫어지고, 읽기 어려우며, 스펠링 오류를 만들기 쉽습니다.
  대신, 제정신을 유지하기 위해 ES2015와 TypeScript의 템플릿 문자열 특성의 장점을 살려보죠.

  템플릿을 감싸고 있는 따옴표를 back-tick으로 변경하고 각자의 라인에 `<h1>`, `<h2>` 그리고 `<div>`을 위치시킵니다.

+makeExample('toh-1/ts-snippets/app.component.snippets.pt1.ts', 'multi-line-strings', 'app.component.ts (AppComponent\'s template)')

  .callout.is-important
    header back-tick은 단일 따옴표가 아닙니다.
    :marked
      **주의하세요!** back-tick (`)은 단일 따옴표 (')처럼 보입니다.
      그들은 실제로 완전히 다른 문자입니다.
      Back-tick은 문자열의 경계를 표시하는 것 이상의 것을 할 수 있습니다.
      이 예제에서 템플릿을 여러 줄로 표현하기 위해 제한된 방법 내에서 back-tick을 사용했습니다.
      템플릿 시작과 끝에서 back-tick 사이의 모든 것은 단일 템플릿 문자열의 일부입니다.

.l-main-section
:marked
  ## 영웅 수정하기

  텍스트 박스 내에서 영웅의 이름을 수정 가능하도록 하고자 합니다.

  아래 보이는 것처럼 영웅 이름인 `<label>`를 `<label>`과 `<input>`으로 리팩토링해보겠습니다:

+makeExample('toh-1/ts-snippets/app.component.snippets.pt1.ts', 'editing-Hero', 'app.component.ts (input element)')
:marked
  영웅의 이름이 `<input>` 텍스트 박스에서 나타나는 것을 브라우저에서 볼 수 있습니다. 
  그러나 무언가 잘못된 느낌입니다.
  우리가 이름을 변경할 때, 그 변경이 `<h2>`에는 반영되지 않기 때문이죠. `<input>`에 단방향 바인딩은 원하는 동작이 아닐 겁니다. 

  ### 양방향 바인딩

  `<input>` 내에서 영웅의 이름을 디스플레이하고 그것을 변경하면 영웅이 이름이 바인딩된 위치라면 어디든지 해당 변경이 반영되기를 원할 겁니다.
  짧게 말해, 양방향 바인딩되기를 바라는 거죠.

  양방향 바인딩을 위해 **`ngModel`** 빌트인 디렉티브를 사용해 템플릿을 바꿔보죠.

.l-sub-section
  :marked
    [Forms](../guide/forms.html#ngModel)과 [템플릿 문법](../guide/template-syntax.html#ngModel) 챕터에서 `ngModel`에 관해 좀 더 배워보세요.
:marked
  다음 HTML로 `<input>'을  대체하세요

code-example(language="html").
  &lt;input [(ngModel)]="hero.name" placeholder="name">

:marked
  브라우저가 리프레시되고 영웅이 다시 한번 보일 겁니다. 영웅의 이름을 변경할 수 있고 `<h2>`에 즉각 반영되는 것을 볼 수 있을 겁니다.

.l-main-section
:marked
  ## 지금까지 알아본 것들
  우리가 빌드해 온 내용들을 점검해보죠.

  * Tour of Heroes는 애플리케이션 제목과 `Hero` 객체의 프로퍼티를 디스플레이하기 위해 
  이중 중괄호 삽입 어구(단방향 데이터 바인딩의 형태)를 사용합니다.
  * 템플릿을 읽기 가능하도록 만들기 위해 ES2015의 템플릿 문자열 사용하여 멀티라인 템플릿을 작성했습니다.
  * 빌트인 `ngModel` 디렉티브를 사용해 `<input>` 요소에 양방향 데이터 바인딩을 한 이후 영웅의 이름의 디스플레이와 변경 모두 가능해졌습니다.
  * 또한 `ngModel` 디렉티브는 `hero.name`이라는 다른 모든 바인딩으로 변경 사항을 전파합니다.

  [파트 1에 대한 라이브 예제를 실행해보세요](/resources/live-examples/toh-1/ts/plnkr.html)

  다음은 `app.component.ts`의 현재 모습입니다:

+makeExample('toh-1/ts/app/app.component.ts', 'pt1', 'app.component.ts')

.l-main-section
:marked
  ## 앞으로 가야할 길
  Tour of Heroes는 현재 한명의 영웅을 디스플레이하는 것만 가능한데 영웅의 목록을 디스플레이하고자 합니다.
  또한, 사용자가 영웅을 선택해서 상세정보를 디스플레이하도록 하고자 합니다.
  [다음 튜토리얼 챕터](./toh-pt2.html)에서는 목록을 가져와 템플릿에 바인딩하고 선택 가능하도록 만드는 방법에 대해 좀 더 배워보고자 합니다. 
