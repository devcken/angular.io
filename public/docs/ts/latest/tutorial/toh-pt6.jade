include ../_util-fns

:marked
  # HTTP로 데이터 가져오기 혹은 저장하기
  
  우리의 이해관계자들은 우리가 진행해온 것들을 고마워하고 있습니다.
  이제 그들은 서버에서 영웅 데이터를 가져오고, 사용자는 영웅들을 추가, 수정, 그리고 삭제하며,
  이런 변경사항들을 다시 서버에 저장하길 원하고 있습니다.
  
  이 챕터에서는 원격 서버의 웹 API에 대한 HTTP 요청을 만들도록 할 것입니다.
:marked
  [라이브 예제를 실행해보세요.](/resources/live-examples/toh-6/ts/plnkr.html).   
  
.l-main-section
:marked
  ## 어디서부터 시작할까요?
  [이전 챕터](toh-pt5.html)에서 우리는 선택된 영웅을 수정하도록 대시보드와 고정된 영웅 목록 사이를 찾아 이동하는 것을 배웠습니다. 
  그것이 바로 이 챕터에서 시작해야 할 부분입니다.

  ### Keep the app transpiling and running
  Open a terminal/console window and enter the following command to
  start the TypeScript compiler, start the server, and watch for changes:

code-example(format="." language="bash").
  npm start

:marked
  The application runs and updates automatically as we continue to build the Tour of Heroes.

.l-main-section  
:marked
 ## Http 준비
  
  `Http`는 Angular의 핵심 모듈이 ***아닙니다***.
  그건 웹 억세스를 위한 부가적인 접근법이며 Angular의 npm 패키지 중 일부 스크립트 파일로 제공되는 `@angular/http`라고 불리는 개별적인 애드온 모듈 내에 존재합니다.
  
  운좋게도 `systemj.config`가 우리가 필요로 할 때 그 라이브러리를 로드할 수 있도록 *SystemJS*를 설정해두었기에 `@angular/http`로부터 임포트할 준비가 되어 있습니다.

:marked
  ### *http* 서비스를 등록(제공)하세요
  우리 앱은 다른 지원 서비스에 의존적인 Angular `http` 서비스에 의존하게 될 것입니다.
  `@angular/http` 라이브러리의 `HTTP_PROVIDERS` 배열은 http 서비스의 전체 집합을 위한 제공자를 가지고 있습니다.
  
  앱의 어느 곳에서든지 이 서비스들에 접근할 수 있어야 합니다.
  그러므로 우리가 애플리케이션과 최상위 컴포넌트인 `AppComponent`를 시작하는 `main.ts`의 `bootstrap` 메서드에 그 서비스들을 등록할 것입니다.
  
+makeExample('toh-6/ts/app/main.ts','v1','app/main.ts (v1)')(format='.')
:marked
  `bootstrap` 메서드에 두번째 파라메터를 배열로 하여 요소에 `HTTP_PROVIDERS`를 제공했다는 것을 알아두시기 바랍니다.
   이것은 `@Component` 메타데이터에서 `providers` 배열과 동일한 효과를 제공합니다.

.l-main-section
:marked
  ## 웹 API 시뮬레이션하기

  일반적으로 최상위 컴포넌트인 `AppComponent`의 *providers*에서 애플리케이션-와이드 서비스를 등록하길 추천합니다.
  여기서 우리는 특별한 이유 때문에 `main`에서 등록하고 있습니다.
  
  우리 애플리케이션은 개발의 초기 스테이지에 있고 아직 완제품이 되려면 멀었습니다. 
  우린 영웅에 대한 요청을 다룰 수 있는 웹 서버조차 가지고 있지 않습니다. 
  그러기 전까지, *웹 서버를 흉내내도록 할 것입니다*.
  
  *인메모리 웹 API*인 데모/개발용 서비스로부터 데이터를 가져오고 저장하도록 HTTP 클라이언트를 *속이려고* 합니다.
  
  애플리케이션 자체는 이에 대해 알 필요도 없고 알아서도 안됩니다.
  그러므로 `AppComponent`의 *상단* 설정 내로 *인메모리 웹 API*를 설정하려고 합니다. 
  
  다음은 이런 트릭을 실행하도록 만든 `main`의 버전입니다
+makeExample('toh-6/ts/app/main.ts', 'final', 'app/main.ts (final)')(format=".")  

:marked
  우리는 다음의 `in-memory-data.services.ts` 파일을 준비한 이후에, 원격 서버와의 통신을 담당하는 서비스인 `XHRBackend`를
  *인메모리 웹 API* 서비스로 대체하는 중입니다:
+makeExample('toh-6/ts/app/in-memory-data.service.ts', null, 'app/in-memory-data.service.ts')(format=".")
:marked
  이 파일로 지워도 안전한 `mock-heroes.ts`를 대체합니다.

.alert.is-helpful
  :marked
    이 챕터는 Angular HTTP  클라이언트를 소개하는 자리입니다.
    여기서의 백엔드 교체에 대한 세부적인 내용 때문에 혼란스러워 하지 마시기 바랍니다. 그냥 예제를 따라하시면 됩니다. 
    
    이후에 [Http 챕터](../guide/server-communication.html#!#in-mem-web-api)에서 *인메모리 웹 API*에 관해 좀 더 알아보시기 바랍니다.
    기억해두세요, *인메모리 웹 API*는 Tour of Heroes처럼 개발 초기 스테이지와 데모의 과정에서만 유용합니다.
    실제 웹 API 서버가 있다면 건너띄시기 바랍니다.

.l-main-section
:marked
  ## 영웅과 Http
  
  현재 `HeroService` 구현은 다음과 같습니다
+makeExample('toh-4/ts/app/hero.service.ts', 'get-heroes', 'app/hero.service.ts (getHeroes - old)')(format=".")
:marked
  가짜 영웅 목록을 가진 promise을 반환했습니다.
  해당 시점에는 그것이 과다한 것 같았지만, HTTP 클라이언트로 영웅 목록을 가져오게 될 순간을 예상하고 있었으며,
  그것이 비동기 동작이 될 것이라는 것을 알고 있기에 그렇게 한 것입니다. 
  
  그러한 날이 왔습니다! `getHeroes()`를 Angular의 `http` 클라이언트를 사용하도록 변경해보죠:
  
+makeExample('toh-6/ts/app/hero.service.ts', 'get-heroes', 'app/hero.service.ts (getHeroes using Http)')(format=".")
  
:marked
  ### Http Promise

  여전히 promise를 반환하고 있지만 다른 방법으로 만들어내고 있습니다.
  
  Angular의 `http.get`은 RxJS의 `Observable`을 반환합니다.
  *Observables*은 비동기 데이터 흐름을 제어하기에 강력한 방법입니다.
  *나중에* `Observables`에 관해 좀 더 알아보겠습니다.
  
  *지금*은 `toPromise` 연산자를 사용하여 즉시 `Observable`을 `Promise`로 변환하여 좀 더 친숙한 것으로 돌아오도록 하겠습니다.
+makeExample('toh-6/ts/app/hero.service.ts', 'to-promise')(format=".")
:marked
  불행히도, Angular `Observable`은 `toPromise` 연산자를 가지고 있지 않습니다 ... 특별히 취급하지 않는거죠. 
  Angular의 `Observable` 구현은 빈약합니다.  
  
  유용한 가용성과 함께 `Observable`을 확장한 `toPromise`와 같은 연산자를 모아놓은 집합이 있습니다.
  그런 가용성을 원한다면 직접 그 연산자들을 추가해야 합니다.
  다음과 같이 RxJS 라이브러리에서 그 연산자들을 추가하면 됩니다:
+makeExample('toh-6/ts/app/hero.service.ts', 'rxjs')(format=".")

:marked
  ### *then* 콜백에서 데이터 추출하기 
  *promise*의 `then` 콜백에서 응답 내의 데이터를 추출해내기 위해 http `Response`의 `json` 메서드를 호출하고 있습니다.
+makeExample('toh-6/ts/app/hero.service.ts', 'to-data')(format=".")
:marked
  `json`에 의해 반환된 그 객체는 단일 `data` 프로퍼티입니다.
  `data` 프로퍼티는 호출자가 실제로 원하는 *heroes* 배열을 가지고 있습니다. 
  그러므로 그 배열을 가져와 그것을 promise의 결과 값으로 반환하고 있습니다.

.alert.is-important
  :marked
    서버에 의해 반환된 데이터의 겉모습을 봐주시기 바랍니다.
    이 특유의 *인메모리 웹 API* 예제는 `data` 프로퍼티를 지닌 객체를 반환하도록 되어 있습니다.
    당신의 API는 어쩌면 다른 것들을 반환할지도 모릅니다.
    
    *당신의 웹 API*에 맞춰 코드를 조정하시기 바랍니다.
:marked
  호출자는 이런 술책을 알지 못합니다. 전에 했던 것처럼 *heroes*를 지닌 promise를 수신하게 되죠.
  서버로부터 영웅 목록을 가져오는지 아닌지에 대한 것도 모릅니다. 
  HTTP 응답을 영웅 목록을 바꾸기 위해 필요로 하는 것을 조작하고 바꾸는 것에 대해서 전혀 모릅니다.
  이런 것이 아름다운 것이고 `HeroService`와 같은 서비스가 데이터 접근을 대리하는 목적입니다.
:marked
  ### 오류 다루기
  `getHeroes`의 끝에서 서버 오류를 `catch`했고 그것을 오류 핸들러로 전달했습니다:
+makeExample('toh-6/ts/app/hero.service.ts', 'catch')(format=".")
:marked
  이것은 중대한 단계입니다!
  우리의 제어를 벗어나는 이유들로 인해 반복적으로 일어날 수 있는 HTTP 오류들을 예상해야 합니다.

+makeExample('toh-6/ts/app/hero.service.ts', 'error-handler', 'app/hero.service.ts (Error handler)')(format=".")
:marked
  이 데모 서비스에서 오류를 콘솔에 기록하고 있습니다; 실제로는 좀 더 나은 방법으로 처리해야 합니다.

  우리는 호출자에게 거절된 promise 내로 오류에 대한 사용자 친화적인 형식을 반환하기로 결정했기에 호출자는 사용자가 오류메시지를 적당한 방법으로 디스플레이스할 수 있습니다.
  
  ### Promise는 Promise입니다
  `getHeroes()`에 중대한 *내부* 변경을 가했더라도, public 시그니처는 변경되지 않았습니다. 
  여전히 promise를 반환하고 있죠. `getHeroes()` 호출하는 어떤 컴포넌트도 변경할 필요가 없습니다.

.l-main-section   
:marked
  ## 추가, 수정, 삭제
  
  우리의 이해관계자들은 API 통합에서 오는 추가적인 유연성으로 점점 더 만족해하고 있습니다. 그러나 거기서 멈추지 않습니다.
  이제 영웅들을 추가하고 수정하거나 삭제하는 능력을 얻길 바라고 있습니다.   
  
  `post`, `put` 그리고 `delete` HTTP 호출을 만들어 새로운 요구사항을 만족시키도록 `HeroService`를 마무리할 것입니다.

:marked
  ### Post
  
  새로운 영웅을 추가하려고 `post`를 사용합니다. Post 요청은 Get 요청에 비해 약간 더 많은 준비과정을 필요로 합니다:
  
+makeExample('toh-6/ts/app/hero.service.ts', 'post-hero', 'app/hero.service.ts (post hero)')(format=".")

:marked
  헤더를 만들고 컨텐츠 타입으로 `application/json`을 설정합니다.
  post하기 전에 영웅 객체를 문자열로 변환하기 위해 `JSON.stringify`를 호출할 것입니다.  
  
  ### Put
  `put`은 특정 영웅을 수정하기 위해 사용되지만 그 구조는 `post` 요청과 매우 흡사합니다.
  유일한 차이점이라면 우리가 수정하고자 하는 영웅의 아이디를 덧붙여서 URL이 약간 변경된다는 것입니다.

+makeExample('toh-6/ts/app/hero.service.ts', 'put-hero', 'app/hero.service.ts (put hero)')(format=".")

:marked
  ### Delete
  `delete`는 영웅들을 지우기 위해 사용되며 함수 이름을 제외하고는 `put`과 동일합니다.

+makeExample('toh-6/ts/app/hero.service.ts', 'delete-hero', 'app/hero.service.ts (delete hero)')(format=".")

:marked
  이 세 가지 경우에 대한 오류 핸들링을 위해 `catch`를 추가합니다.
  
:marked
  ### 저장
  
  `post` 그리고 `put` 메서드 호출을 단일의 `save` 메서드로 합쳐보도록 하겠습니다.
  이것은 public API를 단순화하고 `HeroDetailComponent`와 통합을 더욱 쉽게 만들어줍니다.
  `HeroService`는 `hero` 객체의 상태에 따라 호출해야 하는 메서드가 어떤 것인지 결정하도록 합니다.
  영웅이 이미 아이디를 가지고 있다면 그것이 수정되어야 한다는 것을 우리는 알고 있을 겁니다.
  그렇지 않다면 새로이 추가되어야 한다는 것을 알고 있겠죠.

+makeExample('toh-6/ts/app/hero.service.ts', 'save', 'app/hero.service.ts (save hero)')(format=".")
    
:marked
  위와 같은 변경 이후, `HeroService`는 다음과 같을 겁니다:

+makeExample('toh-6/ts/app/hero.service.ts', null, 'app/hero.service.ts')(format=".")

.l-main-section
:marked
  ## 컴포넌트 갱신하기
  
  `Http`를 사용하여 영웅들을 로딩하는 것은 `HeroService` 외부의 변경을 필요로 하지는 않았습니다. 그러나 우리는 새로운 기능 역시 추가했죠.
  다음의 섹션에서 영웅을 추가, 수정, 그리고 삭제하기 위한 새로운 메서드를 사용을 위해 컴포넌트를 갱신할 것입니다. 
  
  ### *HeroDetailComponent* 내에서 추가/수정하기
  특정 영웅에 대한 상세 내용을 보기 위한 `HeroDetailComponent`를 이미 가지고 있습니다.
  추가 그리고 수정은 상세 뷰의 자연스러운 확장이므로 몇 가지 개조를 통해 `DetailHeroComponent`를 재사용할 수 있게 됩니다.
  원래의 컴포넌트는 데이터를 렌더링하기 위해 만들어졌지만, 새로운 데이터를 추가하기 위해 `hero` 프로퍼티를 비어있는 `Hero` 객체로 초기화해야 합니다.
  
+makeExample('toh-6/ts/app/hero-detail.component.ts', 'ngOnInit', 'app/hero-detail.component.ts (ngOnInit)')(format=".")

:marked
  추가와 수정을 구별시키기 위해, 아이디가 URL에 전달되어야 하는지를 알아보는 검사를 추가했습니다.
  아이디가 없다면 `HeroDetailComponent`를 비어있는 `Hero` 객체에 바인딩해야 합니다.
  그렇지 않다면, UI를 통해 이루어질 모든 수정들은 동일하게 `hero` 프로퍼티에 바인딩될 것입니다.

  다음 단계는 `HeroDetailComponent`에 저장 메서드를 추가하고 그에 대한 `HeroesService` 내 저장 메서드를 호출하는 것입니다.
  
+makeExample('toh-6/ts/app/hero-detail.component.ts', 'save', 'app/hero-detail.component.ts (save)')(format=".")

:marked
  추가와 수정 양쪽에서 동일한 저장 메서드가 사용되는데, 이는 `HeroService`가 `Hero` 객체의 상태에 따라 `post` 혹은 `put`을 호출해야 할 때를 알고 있기 때문입니다.
  
  영웅을 저장한 이후에는, `goBack()` 메서드를 사용해 이전 페이지로 돌아가도록 브라우저를 뒤로 리다이렉트시킵니다.
  
+makeExample('toh-6/ts/app/hero-detail.component.ts', 'goback', 'app/hero-detail.component.ts (goBack)')(format=".")

:marked
  위에서, 영웅을 방금 전에 추가 혹은 수정했다는 것을 알리기 위해 `emit`을 호출하고 있습니다.
  Here we call `emit` to notify that we just added or modified a hero.
  `HeroesComponent`는 이런 알림을 리스닝하고 있으며 변경사항들을 포함시키기 위해 영웅 목록을 자동으로 리프레시할 겁니다.

.l-sub-section
  :marked
    `HeroDetailComponent`와 `HeroesComponent` 사이의 `emit` "핸드쉐이크"는 컴포넌트 간 커뮤니케이션의 예제입니다.
    이것은 이후의 주제가 될 것이므로 <a href="/docs/ts/latest/cookbook/component-communication.html#!#child-to-parent">컴포넌트 상호작용 쿡북</a>에서 좀 더 자세한 내용을 읽어보시기 바랍니다.

:marked
  다음은 새로이 저장 버튼이 추가된 `HeroDetailComponent`입니다.
  
figure.image-display
  img(src='/resources/images/devguide/toh/hero-details-save-button.png' alt="Hero Details With Save Button")

:marked
  ### *HeroesComponent` 내에서 추가/수정하기
  
  사용자는 버튼을 클릭하고 이름을 입력하여 새로운 영웅을 *추가*할 수 있습니다.

  사용자가 *새로운 영웅 추가* 버튼을 클릭하면, `HeroDetailComponent`를 디스플레이합니다.
  
  컴포넌트로 찾아가지 않으므로 영웅의 `id`를 받지 않아도 됩니다;
  위에서 언급했듯이, 그것은 비어있는 영웅을 만들고 표현하기 위한 컴포넌트 측의 신호입니다.
  
  `heroes.component.html` 영웅 목록(`*ngFor`) 바로 아래에 다음의 HTML을 추가해주세요.
+makeExample('toh-6/ts/app/heroes.component.html', 'add-hero', 'app/heroes.component.ts (add)')(format=".")
:marked
  사용자는 영웅 이름 옆에 있는 삭제 버튼을 클릭하여 영웅을 *삭제*할 수 있습니다.
  
  `heroes.component.html`의 반복되는 `<li>` 태그 오른쪽에 다음의 HTML을 추가해주세요.
+makeExample('toh-6/ts/app/heroes.component.html', 'delete-hero', 'app/heroes.component.ts (delete)')(format=".")

:marked
  이제 템플릿 내에서 *추가*와 *삭제*를 지원하기 위해 'HeroesComponent'를 수정해보도록 하겠습니다.
  *추가*부터 시작해보죠.
  
  우리는 새로운 영웅 정보를 사용자로부터 입력받기 위해 `HeroDetailComponent`를 사용하고 있습니다.
  `HeroDetailComponent`를 임포트하고 컴포넌트 메타데이터 `directives` 배열 내로 참조시켜, 이러한 내용을 Angular에게 알려주어야 합니다.
+makeExample('toh-6/ts/app/heroes.component.ts', 'hero-detail-component', 'app/heroes.component.ts (HeroDetailComponent)')(format=".")  
.l-sub-section
  :marked
    이 내용들은 이전 [라우팅](toh-pt5.html) 챕터에서 제거됐던 것과 동일한 것입니다. 
    우린 그 때 당시 이 *HeroDetailComponent*가 다시 필요할지 몰랐습니다. 그래서 정리했습니다. 
    
    이제는 이 코드들이 반드시 필요합니다. 코드들을 되돌려 놓지 않으면, Anuglar는 `<my-hero-detail>` 태그를 무시할 것이고
    *새로운 영웅 추가* 버튼을 누르면 아무런 효과도 나타나지 않을 겁니다.
:marked
  다음으로 *새로운 영웅 추가* 버튼을 위한 클릭 핸들러를 구현할 겁니다.

+makeExample('toh-6/ts/app/heroes.component.ts', 'add', 'app/heroes.component.ts (add)')(format=".")  
:marked
  `HeroDetailComponent`이 대부분의 일을 합니다. 우리가 하는 모든 것은 영웅이 추가됐을 때 DOM 안으로 그것을 넣어주고
  사용자가 할 일을 완료했을 때 DOM에서 그것을 제거하는 `*ngIf` 플래그를 토글하는 것입니다.
  
  *삭제* 로직은 약간 더 교묘합니다.
+makeExample('toh-6/ts/app/heroes.component.ts', 'delete', 'app/heroes.component.ts (delete)')(format=".")

:marked
  물론 영웅 삭제의 영속성을 `HeroService`에게 일임합니다.
  그러나 컴포넌트는 여전히 디스플레이 갱신에 대해서 책임이 있습니다.
  그러므로 *delete* 메서드는 목록으로부터 제거된 영웅을 제거하게 됩니다.

:marked
  ### 결과를 보죠
  동작하는 노력의 결실을 보면:
figure.image-display
  img(src='/resources/images/devguide/toh/toh-http.anim.gif' alt="Heroes List Editting w/ HTTP")  

:marked
  ### 앱 구조 검토하기
  이 챕터에서 했던 리팩토링 이후의 구조에 대해서 검증해보도록 하죠:
  
.filetree
  .file angular2-tour-of-heroes
  .children
  .file app
  .children
    .file app.component.ts
    .file app.component.css
    .file dashboard.component.css
    .file dashboard.component.html
    .file dashboard.component.ts
    .file hero.ts
    .file hero-detail.component.css
    .file hero-detail.component.html
    .file hero-detail.component.ts
    .file hero.service.ts
    .file heroes.component.css
    .file heroes.component.html
    .file heroes.component.ts
    .file main.ts
    .file hero-data.service.ts
  .file node_modules ...
  .file typings ...
  .file index.html
  .file package.json
  .file styles.css
  .file sample.css
  .file systemjs.config.json
  .file tsconfig.json
  .file typings.json
 
.l-main-section    
:marked
    ## 마지막 코스
    
    이제 우리는 여행의 마지막에 와 있습니다. 그리고 많은 것을 달성했지요.
    - 애플리케이션에서 Http를 사용하기 위해 필요한 의존성을 추가했습니다.
    - API로부터 영웅을 로드하기 위해 HeroService를 리팩토링했습니다.
    - post, put, delete 호출을 지원하기 위해 HeroService를 확장했습니다.
    - 영웅의 추가, 수정, 삭제를 허용하기 위해 컴포넌트를 갱신했습니다.
    - 인메모리 웹 API를 설정했습니다.
    
    아래는 변경했던 파일의 요약입니다.
    
+makeTabs(
  `toh-6/ts/app/app.component.ts,
   toh-6/ts/app/heroes.component.ts,
   toh-6/ts/app/heroes.component.html,
   toh-6/ts/app/hero-detail.component.ts,
   toh-6/ts/app/hero-detail.component.html,
   toh-6/ts/app/hero.service.ts`,
  null,
  `app.comp...ts,
   heroes.comp...ts,
   heroes.comp...html,
   hero-detail.comp...ts,
   hero-detail.comp...html,
   hero.service.ts`
) 

