include ../_util-fns

:marked
  우리의 앱은 점점 커지고 있습니다.
  유스케이스는 컴포넌트 재사용, 컴포넌트로 데이터 전달 그리고 좀 더 재사용 가능한 애셋 만드는 방향으로 흘러가고 있죠.
  영웅 상세로부터 영웅 목록을 분리해내고 상세 컴포넌트를 재사용 가능하도록 만들어보죠.

  [파트 3에 대한 라이브 예제를 실행해보세요](/resources/live-examples/toh-3/ts/plnkr.html)

.l-main-section
:marked
  ## Where We Left Off
  Tour of Heroes를 계속하기 전에, 다음 구조를 확인하시기 바랍니다. 만약 다르다면, 이전 단계로 돌아가서 빠진게 없는지 확인하시기 바랍니다.

.filetree
  .file angular2-tour-of-heroes
  .children
    .file app
    .children
      .file app.component.ts
      .file main.ts
    .file node_modules ...
    .file typings ...      
    .file index.html
    .file package.json
    .file styles.css
    .file systemjs.config.js
    .file tsconfig.json
    .file typings.json
:marked
  ### 앱 트랜스파일링과 실행을 유지하세요
  We want to start the TypeScript compiler, have it watch for changes, and start our server. We'll do this by typing

code-example(format="." language="bash").
  npm start

:marked
  This will keep the application running while we continue to build the Tour of Heroes.

  ## 영웅 상세 컴포넌트 만들기
  영웅 목록과 영웅 상세는 동일한 파일 내에 같은 컴포넌트로 되어 있습니다.
  현재로써는 작지만 그들은 점점 커질 가능성이 있습니다.
  하나의 컴포넌트에 대해서 새로운 요구사항이 나올 뿐 나머지 다른 하나의 컴포넌트에 대해서는 그렇지 않을 것이 뻔합니다.
  모든 변경들이 두 개의 컴포넌트에 영향을 줄 위험성이 아직 존재하고 이점없이 테스팅의 부담만 두 배인 상태입니다. 
  앱 내 다른곳에서도 영웅 상세를 재사용하려면 영웅 목록은 성가신 존재가 되고 맙니다. 
  
  현재의 컴포넌트는[단일 책임 원칙](https://blog.8thlight.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html)을 여기고 있습니다.
  튜토리얼일 뿐이지만 우리는 옳은 일을 행할 수 있고 그래야 합니다 &mdash;
  특히 그렇게 하는 것이 어렵지 않고 Angular 앱을 빌드하는 방법을 배우는 과정이라면 말이죠.
  
  현재 컴포넌트 밖으로 영웅 상세를 끄집어 내도록 합시다.

  ### 영웅 상세 컴포넌트 분리하기
  `app` 폴더에 `hero-detail.component.ts`라는 이름의 파일을 추가하고 `HeroDetailComponent`를 다음과 같이 만들어보세요.

+makeExample('toh-3/ts/app/hero-detail.component.ts', 'v1', 'hero-detail.component.ts (initial version)')(format=".")
.l-sub-section
  :marked
    ### 네이밍 관례
    우리는 어떤 클래스가 컴포넌트인지 어떤 파일이 컴포넌트를 포함하고 있는지를 명확하게 알고싶어 합니다. 
    
    우리는 현재 `app.component.ts`라는 이름의 파일에 `AppComponent`를 가지고 있고
    새로운 `HeroDetailComponent`는 `hero-detail.component.ts`라는 파일에 있다는 것을 다시 한번 상기시키세요.
     
    우리의 모든 컴포넌트들의 이름은 "Component"로 끝납니다. 컴포넌트의 파일 이름은 모두 ".component"로 끝나죠.
    
    우리는 파일 이름을 소문자 대시 케이스("kebab-case"와 같은)로 지었으며 그래서 서버나 소스 컨트롤 상에서의 대소문주 구분을 걱정하지 않아도 됩니다.

    <!-- TODO
    .l-sub-section
      :marked
        네이밍 관례에 관해서는 [네이밍 관례] 챕터에서 좀 더 알아보시기 바랍니다
    :marked
    -->
:marked
  Angular에서 `Component`와 `Input` 데코레이터를 임포트하는 것으로부터 시작하겠습니다. 곧 필요할테니까요.
  
  해당 컴포넌트 요소를 구별짓는 셀렉터 이름을 `@Component` 데코레이터의 메타데이터로 지정하겠습니다.  
  그런 뒤에 다른 컴포넌트에서 사용 가능하도록 클래스를 익스포트(export)해야 합니다.
  
  여기까지 하면, `AppComponent`로 임포트할 수 있고 그에 대한 `<my-hero-detail>` 요소를 만들 수 있을 겁니다.
:marked
  #### 영웅 상세 템플릿
  현재, *Heroes*와 *Hero Detail* 뷰는 `AppComponent` 내에 하나의 템플릿으로 섞여있습니다.
  `AppComponent`로부터 *Hero Detail* 컨텐츠를 **잘라내고** 그것을 `HeroDetailComponent`의 새로운 템플릿 프로퍼티에 **붙여넣으세요**.

  이전에 `AppComponent`의 `selectedHero.name` 프로퍼티에 바인딩했습니다.
  `HeroDetailComponent`는 `selectedHero` 프로퍼티가 아닌 `hero` 프로퍼티를 가지게 될겁니다.
  그러므로 새로운 템플릿 내의 모든 곳에서 `hero`를 `selectedHero`로 대체하도록 합니다. 이것이 유일한 변경사항입니다.
  그 결과는 다음과 같을 겁니다:

+makeExample('toh-3/ts/app/hero-detail.component.ts', 'template', 'hero-detail.component.ts (template)')(format=".")

:marked
  이제 영웅 상세 레이아웃은 `HeroDetailComponent` 내에만 존재합니다.

  #### *hero* 프로퍼티 추가
  컴포넌트 클래스에 관해 이야기하면서 거론했던 `hero` 프로퍼티를 추가해봅시다.
+makeExample('toh-3/ts/app/hero-detail.component.ts', 'hero')
:marked
  어... `hero` 프로퍼티를 `Hero` 타입으로 선언했는데 `Hero` 클래스는 `app.component.ts` 파일 내에 있습니다.
  두 개의 컴포넌트가 각자의 파일 내에 있는데 그들은 `Hero` 클래스를 참조해야 합니다. 
  
  우리는 `Hero` 클래스를 `app.component.ts`에서 `hero.ts` 파일로 옮겨서 이 문제를 해결하고자 합니다.

+makeExample('toh-3/ts/app/hero.ts', null, 'hero.ts (Exported Hero class)')(format=".")

:marked
  `hero.ts`로부터 `Hero` 클래스를 익스포트해야 하는데 두 개의 컴포넌트 파일에서 그것을 참조해야 하기 때문이죠.
  `app.component.ts`와 `hero-detail.component.ts` 두 파일의 상단 근처에 다음의 임포트 구문을 추가해주세요.

+makeExample('toh-3/ts/app/hero-detail.component.ts', 'hero-import', 'hero-detail.component.ts and app.component.ts (Import the Hero class)')

:marked
  #### *hero* 프로퍼티는 ***입력***입니다
  
  `HeroDetailComponent`는 디스플레이해야 하는 영웅이 무엇인지를 알아야 합니다. 그걸 누가 알려줄까요? 바로 부모인 `AppComponent`죠!
  
  `AppComponent`는 보여줘야 하는 영웅이 누구인지 알고 있습니다: 목록에서 사용자가 선택한 영웅이죠. 
  사용자의 선택은 `selectedHero` 프로퍼티입니다.
  
  `AppComponent`의 템플릿을 `selectedHero` 프로퍼티가 `HeroDetailComponent`의 `hero` 프로퍼티에 바인딩되도록 변경할 것입니다.
  바인딩은 *대략* 이런 모습일 겁니다:
code-example(format=".").
  &lt;my-hero-detail [hero]="selectedHero">&lt;/my-hero-detail>
:marked
  `hero` 프로퍼티가 바인딩의 ***대상***임을 기억하세요 &mdash; (=)의 좌측에 있는 대괄호 안에 있습니다.
  
  Angular는 ***대상*** 프로퍼티로 ***입력*** 프로퍼티가 되어야 한다라고 선언했다고 간주합니다.
  만약 제대로 선언하지 않았다면, Angular는 바인딩을 거절하고 오류를 던집니다.
.l-sub-section
  :marked
    입력 프로퍼티에 대해서 좀 더 자세한 내용을 [여기](../guide/attribute-directives.html#why-input)에서 설명하고 있는데
    왜 *대상* 프로퍼티가 이 특별한 조치를 필요로 하는지 그리고 *소스* 프로퍼티는 그렇지 않은지에 대해서 설명하고 있습니다.
:marked
  `hero`가 *입력*임을 선언하는 두 가지 방법이 있습니다.
  우리는 이것을 우리가 선호하는 방법, 즉 `hero` 프로퍼티에 우리가 앞서 임포트했던 `@Input` 데코레이터로 어노테이팅하는 방법으로 할겁니다.
+makeExample('toh-3/ts/app/hero-detail.component.ts', 'hero-input')(format='.')
  
.l-sub-section
  :marked
    [속성 디렉티브](../guide/attribute-directives.html#input) 챕터에서 `@Input()` 데코레이터에 관해 좀 더 알아보세요.

.l-main-section
:marked
  ## AppComponent를 리프레시하기
  `AppComponent`로 돌아와서 `HeroDetailComponent`를 사용하도록 바꿔야 합니다.

  `HeroDetailComponent`를 참조하기 위해 먼저 임포트하는 것으로부터 시작하겠습니다.

+makeExample('toh-3/ts/app/app.component.ts', 'hero-detail-import')

:marked
  *영웅 상세* 컨텐츠를 제거하고 `HeroDetailComponent`를 표현할 요소 태그를 추가할 템플릿 내 위치를 찾도록 합니다.
code-example(format=".").
  &lt;my-hero-detail>&lt;/my-hero-detail>
.l-sub-section
  :marked
    *my-hero-detail*은 `HeroDetailComponent` 메타데이터에서 `selector`로써 설정했던 이름입니다.
:marked
 이 두 컴포넌트는 다음과 같이 `AppComponent`의 `selectedHero` 프로퍼티를 `HeroDetailComponent` 요소의 `hero` 프로퍼티에 바인딩할 때까지 서로 연결되지 않습니다:
code-example(format=".")
  &lt;my-hero-detail [hero]="selectedHero">&lt;/my-hero-detail>
:marked
  `AppComponent`의 템플릿은 이제 다음과 같습니다

+makeExample('toh-3/ts/app/app.component.ts', 'hero-detail-template', 'app.component.ts (Template)')(format='.')
:marked
  바인딩 덕분에, `HeroDetailComponent`는 `AppComponent`로부터 영웅을 수신하게 되고 목록 아래에 영웅의 상세 정보를 표현하게 됩니다.
  이 상세 정보는 사용자가 새로운 영웅을 고를때마다 매번 갱신되어야 합니다.
  
  It's not happening yet!
  
  We click among the heroes. No details. We look for an error in the console of the browser development tools. No error.
  
  It is as if Angular were ignoring the new tag. That's because *it is ignoring the new tag*.
  
  ### The *directives* array
  A browser ignores HTML tags and attributes that it doesn't recognize. So does Angular.
  
  We've imported `HeroDetailComponent`, we've used it in the template, but we haven't told Angular about it.
  
  We tell Angular about it by listing it in the metadata `directives` array. Let's add that array property to the bottom of the
  `@Component` configuration object, immediately after the `template` and `styles` properties.
+makeExample('toh-3/ts/app/app.component.ts', 'directives', 'app/app.component.ts (Directives)')

:marked
  ### It works!
  When we view our app in the browser we see the list of heroes. 
  When we select a hero we can see the selected hero’s details. 
  
  What's fundamentally new is that we can use this `HeroDetailComponent`
  to show hero details anywhere in the app.

  We’ve created our first reusable component!

  ### Reviewing the App Structure
  Let’s verify that we have the following structure after all of our good refactoring in this chapter:

.filetree
  .file angular2-tour-of-heroes
  .children
    .file app
    .children
      .file app.component.ts
      .file hero.ts
      .file hero-detail.component.ts
      .file main.ts
    .file node_modules ...
    .file typings ...
    .file index.html
    .file package.json
    .file tsconfig.json
    .file typings.json
:marked
  Here are the code files we discussed in this chapter.

+makeTabs(`
  toh-3/ts/app/hero-detail.component.ts,
  toh-3/ts/app/app.component.ts,
  toh-3/ts/app/hero.ts
  `,'',`
  app/hero-detail.component.ts,
  app/app.component.ts,
  app/hero.ts
  `)

.l-main-section
:marked
  ## The Road We’ve Travelled
  Let’s take stock of what we’ve built.

  * We created a reusable component
  * We learned how to make a component accept input
  * We learned to bind a parent component to a child component.
  * We learned to declare the application directives we need in a `directives` array.

  [Run the live example for part 3](/resources/live-examples/toh-3/ts/plnkr.html).

.l-main-section
:marked
  ## The Road Ahead
  Our Tour of Heroes has become more reusable with shared components. 
  
  We're still getting our (mock) data within the `AppComponent`.
  That's not sustainable. 
  We should refactor data access to a separate service
  and share it among the components that need data. 
  
  We’ll learn to create services in the [next tutorial](toh-pt4.html) chapter.
