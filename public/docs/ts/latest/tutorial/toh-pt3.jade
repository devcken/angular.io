include ../_util-fns

:marked
  우리의 앱은 점점 커지고 있습니다.
  유스케이스는 컴포넌트 재사용, 컴포넌트로 데이터 전달 그리고 좀 더 재사용 가능한 애셋 만드는 방향으로 흘러가고 있죠.
  영웅 상세로부터 영웅 목록을 분리해내고 상세 컴포넌트를 재사용 가능하도록 만들어보죠.

  [파트 3에 대한 라이브 예제를 실행해보세요](/resources/live-examples/toh-3/ts/plnkr.html)

.l-main-section
:marked
  ## 어디부터 시작해야 할까요
  Tour of Heroes를 계속하기 전에, 다음 구조를 확인하시기 바랍니다. 만약 다르다면, 이전 단계로 돌아가서 빠진게 없는지 확인하시기 바랍니다.

.filetree
  .file angular2-tour-of-heroes
  .children
    .file app
    .children
      .file app.component.ts
      .file main.ts
    .file node_modules ...
    .file typings ...      
    .file index.html
    .file package.json
    .file styles.css
    .file systemjs.config.js
    .file tsconfig.json
    .file typings.json
:marked
  ### 앱 트랜스파일링과 실행을 유지하세요
  TypeScript 컴파일러 시작, 변경을 위한 watch, 그리고 서버 시작을 원할 겁니다. 다음 명령어를 통해 이런 것들이 가능합니다.

code-example(format="." language="bash").
  npm start

:marked
  이것은 Tour of Heroes을 빌드하는 내내 애플리케이션 실행을 유지시켜줄겁니다.

  ## 영웅 상세 컴포넌트 만들기
  영웅 목록과 영웅 상세는 동일한 파일 내에 같은 컴포넌트로 되어 있습니다.
  현재로써는 작지만 그들은 점점 커질 가능성이 있습니다.
  하나의 컴포넌트에 대해서 새로운 요구사항이 나올 뿐 나머지 다른 하나의 컴포넌트에 대해서는 그렇지 않을 것이 뻔합니다.
  모든 변경들이 두 개의 컴포넌트에 영향을 줄 위험성이 아직 존재하고 이점없이 테스팅의 부담만 두 배인 상태입니다. 
  앱 내 다른곳에서도 영웅 상세를 재사용하려면 영웅 목록은 성가신 존재가 되고 맙니다. 
  
  현재의 컴포넌트는[단일 책임 원칙](https://blog.8thlight.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html)을 여기고 있습니다.
  튜토리얼일 뿐이지만 우리는 옳은 일을 행할 수 있고 그래야 합니다 &mdash;
  특히 그렇게 하는 것이 어렵지 않고 Angular 앱을 빌드하는 방법을 배우는 과정이라면 말이죠.
  
  현재 컴포넌트 밖으로 영웅 상세를 끄집어 내도록 합시다.

  ### 영웅 상세 컴포넌트 분리하기
  `app` 폴더에 `hero-detail.component.ts`라는 이름의 파일을 추가하고 `HeroDetailComponent`를 다음과 같이 만들어보세요.

+makeExample('toh-3/ts/app/hero-detail.component.ts', 'v1', 'hero-detail.component.ts (initial version)')(format=".")
.l-sub-section
  :marked
    ### 네이밍 관례
    우리는 어떤 클래스가 컴포넌트인지 어떤 파일이 컴포넌트를 포함하고 있는지를 명확하게 알고싶어 합니다. 
    
    우리는 현재 `app.component.ts`라는 이름의 파일에 `AppComponent`를 가지고 있고
    새로운 `HeroDetailComponent`는 `hero-detail.component.ts`라는 파일에 있다는 것을 다시 한번 상기시키세요.
     
    우리의 모든 컴포넌트들의 이름은 "Component"로 끝납니다. 컴포넌트의 파일 이름은 모두 ".component"로 끝나죠.
    
    우리는 파일 이름을 소문자 대시 케이스("kebab-case"와 같은)로 지었으며 그래서 서버나 소스 컨트롤 상에서의 대소문주 구분을 걱정하지 않아도 됩니다.

    <!-- TODO
    .l-sub-section
      :marked
        네이밍 관례에 관해서는 [네이밍 관례] 챕터에서 좀 더 알아보시기 바랍니다
    :marked
    -->
:marked
  Angular에서 `Component`와 `Input` 데코레이터를 임포트하는 것으로부터 시작하겠습니다. 곧 필요할테니까요.
  
  해당 컴포넌트 요소를 구별짓는 셀렉터 이름을 `@Component` 데코레이터의 메타데이터로 지정하겠습니다.  
  그런 뒤에 다른 컴포넌트에서 사용 가능하도록 클래스를 익스포트(export)해야 합니다.
  
  여기까지 하면, `AppComponent`로 임포트할 수 있고 그에 대한 `<my-hero-detail>` 요소를 만들 수 있을 겁니다.
:marked
  #### 영웅 상세 템플릿
  현재, *Heroes*와 *Hero Detail* 뷰는 `AppComponent` 내에 하나의 템플릿으로 섞여있습니다.
  `AppComponent`로부터 *Hero Detail* 컨텐츠를 **잘라내고** 그것을 `HeroDetailComponent`의 새로운 템플릿 프로퍼티에 **붙여넣으세요**.

  이전에 `AppComponent`의 `selectedHero.name` 프로퍼티에 바인딩했습니다.
  `HeroDetailComponent`는 `selectedHero` 프로퍼티가 아닌 `hero` 프로퍼티를 가지게 될겁니다.
  그러므로 새로운 템플릿 내의 모든 곳에서 `hero`를 `selectedHero`로 대체하도록 합니다. 이것이 유일한 변경사항입니다.
  그 결과는 다음과 같을 겁니다:

+makeExample('toh-3/ts/app/hero-detail.component.ts', 'template', 'hero-detail.component.ts (template)')(format=".")

:marked
  이제 영웅 상세 레이아웃은 `HeroDetailComponent` 내에만 존재합니다.

  #### *hero* 프로퍼티 추가
  컴포넌트 클래스에 관해 이야기하면서 거론했던 `hero` 프로퍼티를 추가해봅시다.
+makeExample('toh-3/ts/app/hero-detail.component.ts', 'hero')
:marked
  어... `hero` 프로퍼티를 `Hero` 타입으로 선언했는데 `Hero` 클래스는 `app.component.ts` 파일 내에 있습니다.
  두 개의 컴포넌트가 각자의 파일 내에 있는데 그들은 `Hero` 클래스를 참조해야 합니다. 
  
  우리는 `Hero` 클래스를 `app.component.ts`에서 `hero.ts` 파일로 옮겨서 이 문제를 해결하고자 합니다.

+makeExample('toh-3/ts/app/hero.ts', null, 'hero.ts (Exported Hero class)')(format=".")

:marked
  `hero.ts`로부터 `Hero` 클래스를 익스포트해야 하는데 두 개의 컴포넌트 파일에서 그것을 참조해야 하기 때문이죠.
  `app.component.ts`와 `hero-detail.component.ts` 두 파일의 상단 근처에 다음의 임포트 구문을 추가해주세요.

+makeExample('toh-3/ts/app/hero-detail.component.ts', 'hero-import', 'hero-detail.component.ts and app.component.ts (Import the Hero class)')

:marked
  #### *hero* 프로퍼티는 ***입력***입니다
  
  `HeroDetailComponent`는 디스플레이해야 하는 영웅이 무엇인지를 알아야 합니다. 그걸 누가 알려줄까요? 바로 부모인 `AppComponent`죠!
  
  `AppComponent`는 보여줘야 하는 영웅이 누구인지 알고 있습니다: 목록에서 사용자가 선택한 영웅이죠. 
  사용자의 선택은 `selectedHero` 프로퍼티입니다.
  
  `AppComponent`의 템플릿을 `selectedHero` 프로퍼티가 `HeroDetailComponent`의 `hero` 프로퍼티에 바인딩되도록 변경할 것입니다.
  바인딩은 *대략* 이런 모습일 겁니다:
code-example(format=".").
  &lt;my-hero-detail [hero]="selectedHero">&lt;/my-hero-detail>
:marked
  `hero` 프로퍼티가 바인딩의 ***대상***임을 기억하세요 &mdash; (=)의 좌측에 있는 대괄호 안에 있습니다.
  
  Angular는 ***대상*** 프로퍼티로 ***입력*** 프로퍼티가 되어야 한다라고 선언했다고 간주합니다.
  만약 제대로 선언하지 않았다면, Angular는 바인딩을 거절하고 오류를 던집니다.
.l-sub-section
  :marked
    입력 프로퍼티에 대해서 좀 더 자세한 내용을 [여기](../guide/attribute-directives.html#why-input)에서 설명하고 있는데
    왜 *대상* 프로퍼티가 이 특별한 조치를 필요로 하는지 그리고 *소스* 프로퍼티는 그렇지 않은지에 대해서 설명하고 있습니다.
:marked
  `hero`가 *입력*임을 선언하는 두 가지 방법이 있습니다.
  우리는 이것을 우리가 선호하는 방법, 즉 `hero` 프로퍼티에 우리가 앞서 임포트했던 `@Input` 데코레이터로 어노테이팅하는 방법으로 할겁니다.
+makeExample('toh-3/ts/app/hero-detail.component.ts', 'hero-input')(format='.')
  
.l-sub-section
  :marked
    [속성 디렉티브](../guide/attribute-directives.html#input) 챕터에서 `@Input()` 데코레이터에 관해 좀 더 알아보세요.

.l-main-section
:marked
  ## AppComponent를 리프레시하기
  `AppComponent`로 돌아와서 `HeroDetailComponent`를 사용하도록 바꿔야 합니다.

  `HeroDetailComponent`를 참조하기 위해 먼저 임포트하는 것으로부터 시작하겠습니다.

+makeExample('toh-3/ts/app/app.component.ts', 'hero-detail-import')

:marked
  *영웅 상세* 컨텐츠를 제거하고 `HeroDetailComponent`를 표현할 요소 태그를 추가할 템플릿 내 위치를 찾도록 합니다.
code-example(format=".").
  &lt;my-hero-detail>&lt;/my-hero-detail>
.l-sub-section
  :marked
    *my-hero-detail*은 `HeroDetailComponent` 메타데이터에서 `selector`로써 설정했던 이름입니다.
:marked
 이 두 컴포넌트는 다음과 같이 `AppComponent`의 `selectedHero` 프로퍼티를 `HeroDetailComponent` 요소의 `hero` 프로퍼티에 바인딩할 때까지 서로 연결되지 않습니다:
code-example(format=".")
  &lt;my-hero-detail [hero]="selectedHero">&lt;/my-hero-detail>
:marked
  `AppComponent`의 템플릿은 이제 다음과 같습니다

+makeExample('toh-3/ts/app/app.component.ts', 'hero-detail-template', 'app.component.ts (Template)')(format='.')
:marked
  바인딩 덕분에, `HeroDetailComponent`는 `AppComponent`로부터 영웅을 수신하게 되고 목록 아래에 영웅의 상세 정보를 표현하게 됩니다.
  이 상세 정보는 사용자가 새로운 영웅을 고를때마다 매번 갱신되어야 합니다.
  
  그것은 아직 구현되지 않았습니다!
  
  영웅 중 하나를 클릭해보죠. 상세 정보가 아직 나오지 않아요. 브라우저 개발자 도구의 콘솔에서 오류를 찾아보지만 오류는 없습니다.
  
  그것은 Angular가 새로운 태그를 무시하는 것 같습니다. 실제로 *새로운 태그를 무시하고 있기* 때문입니다.
  
  ### *디렉티브* 배열
  브라우저는 인식하지 못하는 HTML 태그와 속성을 무시합니다. Angular도 그렇구요.
  
  `HeroDetailComponent`를 임포트했고 템플릿 내에서 사용하고 있습니다만 우린 그것에 관해 Angular에게 알려주지 않았습니다.
  
  메타데이터의 `directives` 배열에 컴포넌트를 나열해 Angular에게 알려주세요. `@Component` 설정 객체의 아래, 그러니까 `template`과 `styles` 프로퍼티 바로 밑에 그 배열 프로퍼티를 추가해보죠.
+makeExample('toh-3/ts/app/app.component.ts', 'directives', 'app/app.component.ts (Directives)')

:marked
  ### 동작하네요!
  브라우저에서 앱을 볼 때 영웅의 목록을 보게 됩니다.
  한 명의 영웅을 선택하게 되면 선택된 영웅의 상세 정보를 보게 되죠. 
   
  근본적으로 새로운 것은 앱 어디서나 영웅의 상세 정보를 보려면 이 `HeroDetailComponent`를 사용할 수 있다는 겁니다.

  처음으로 재사용 가능한 컴포넌트를 만들었습니다!

  ### 앱 구조 재검토
  이 챕터에서 모든 리팩토링을 하고 나서 다음의 구조를 갖는지 확인해보죠:

.filetree
  .file angular2-tour-of-heroes
  .children
    .file app
    .children
      .file app.component.ts
      .file hero.ts
      .file hero-detail.component.ts
      .file main.ts
    .file node_modules ...
    .file typings ...
    .file index.html
    .file package.json
    .file tsconfig.json
    .file typings.json
:marked
  다음은 우리가 이 챕터에서 다루었던 코드 파일들입니다.

+makeTabs(`
  toh-3/ts/app/hero-detail.component.ts,
  toh-3/ts/app/app.component.ts,
  toh-3/ts/app/hero.ts
  `,'',`
  app/hero-detail.component.ts,
  app/app.component.ts,
  app/hero.ts
  `)

.l-main-section
:marked
  ## 지금까지 알아본 것들
  우리가 빌드해 온 내용들을 점검해보죠.

  * 재사용 가능한 컴포넌트를 만들었습니다
  * 어떻게 하면 컴포넌트가 입력을 받을 수 있는지 배웠습니다
  * 상위 컴포넌트를 하위 컴포넌트에 바인드하는 법을 배웠습니다
  * `directives` 배열 내에 필요한 애플리케이션 디렉티브를 선언하는 방법에 대해 배웠습니다

  [파트 3를 위한 라이브 예제를 실행해 보세요](/resources/live-examples/toh-3/ts/plnkr.html).

.l-main-section
:marked
  ## 앞으로 가야할 길
  Tour of Heroes는 공용 컴포넌트와 함께 좀 더 재사용 가능한 모습으로 변해갈 겁니다. 
  
  `AppComponent` 사이에서 여전히 (가짜) 데이터를 사용하고 있습니다.
  그것은 유지되기 어렵습니다.
  별도의 서비스에서 데이터 접근을 위한 리팩토링을 해야 하고 데이터를 필요로 하는 컴포넌트에서 그 서비스를 공유해야 합니다. 
  
  [다음 튜토리얼](toh-pt4.html)에서 서비스를 만드는 방법을 배우도록 하죠.
