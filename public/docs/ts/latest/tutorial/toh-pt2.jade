include ../_util-fns

:marked
  # 많은 영웅들이 있습니다
  우리의 이야기는 좀 더 많은 영웅들을 필요로 합니다.
  영웅의 목록을 디스플레이하고 사용자가 영웅을 선택하여 영웅의 상세정보를 디스플레이하도록 Tour of Heroes를 확장해 볼겁니다.
  
p 이 파트에 대한 #[+liveExampleLink2('', 'toh-2')]을 실행해보세요.
:marked
  영웅의 목록을 디스플레이하는데 필요한 것들을 잠시 점검해보죠.
  먼저, 영웅의 목록이 필요합니다. 뷰의 템플릿 내에서 영웅들을 디스플레이하고자 하므로 그렇게 할 수 있는 방법이 필요합니다.

.l-main-section
:marked
  ## 어디부터 시작해야 할까요
  Tour of Heroes의 파트 2를 계속 진행하기 전에,
  [파트 1](./toh-pt1.html) 이후에 다음 구조를 가지고 있는지를 확인해보죠.
  만약 그렇지 않다면, 파트 1으로 돌아가 무엇을 놓쳤는지 알아내야 합니다.

.filetree
  .file angular2-tour-of-heroes
  .children
    .file app
    .children
      .file app.component.ts
      .file main.ts
    .file node_modules ...
    .file typings ...      
    .file index.html
    .file package.json
    .file styles.css
    .file systemjs.config.js
    .file tsconfig.json
    .file typings.json
:marked
  ### 앱 트랜스파일링과 실행을 유지하세요
  TypeScript 컴파일러 시작, 변경을 위한 watch, 그리고 서버 시작을 원할 겁니다. 다음 명령어를 통해 이런 것들이 가능합니다.

code-example(language="bash").
  npm start

:marked
  이것은 Tour of Heroes을 빌드하는 내내 애플리케이션 실행을 유지시켜줄겁니다.

.l-main-section
:marked
  ## 영웅들을 디스플레이하기
  ### 영웅 만들기
  `app.component.ts` 하단에 열명의 영웅 배열을 만들어보죠.

+makeExample('toh-2/ts/app/app.component.ts', 'hero-array', 'app.component.ts (hero array)')

:marked
  `HEROES` 배열은 `Hero` 타입의 것으로 영웅의 배열을 만들기 위해 파트 1에서 정의된 클래스입니다.
  웹 서비스로부터 영웅의 목록을 가져오길 간절히 원하지만 처음이니 간단하게 가짜(mock) 영웅들을 디스플레이해보죠.

  ### 영웅들을 드러내기
  `AppComponent`에 바인딩을 위해 영웅들을 드러내는 프로퍼티를 만들어보세요.

+makeExample('toh-2/ts-snippets/app.component.snippets.pt2.ts', 'hero-array-1', 'app.component.ts (hero array property)')

:marked
  우리는 `heroes` 타입을 정의하지 않았습니다. TypeScript는 `HEROES` 배열로부터 타입을 추론할 수 있습니다.
.l-sub-section
  :marked
    우리는 이 컴포넌트 클래스에서 영웅들의 목록을 정의할 수 있습니다.
    그러나 결국에는 데이터 서비스로부터 영웅들을 받게 될 것입니다. 
    우리가 어디를 향하고 있는지를 알고 있기 때문에 처음부터 클래스 구현에서 영웅 데이터를 분리하는 것이 맞습니다.
:marked
  ### 템플릿에서 영웅들을 디스플레이하기
  우리의 컴포넌트는 `heroes`를 가지고 있습니다. 그들을 디스플레이하기 위해 템플릿 내에 순서가 정해지지 않은 목록을 만들어보죠.
  다음의 HTML 조각을 제목 아래, 영웅 상세 위에 삽입해보죠.

+makeExample('toh-2/ts-snippets/app.component.snippets.pt2.ts', 'heroes-template-1', 'app.component.ts (heroes template)')

:marked
  이제 우리는 우리의 영웅들로 채울 수 있는 템플릿을 갖게 되었습니다.

  ### ngFor로 영웅을 나열하기

  우리는 컴포넌트 내 템플릿에 `heroes` 배열을 바인딩하고 그것들을 순회하여 그것들을 개별적으로 디스플레이하고자 합니다.
  이걸 하기 위해서는 Angular로부터 몇 가지 도움을 받아야 합니다. 차례 차례해보죠.

  먼저 빌트 디렉티브인 `*ngFor`을 추가하여 `<li>` 태그를 수정합니다.

+makeExample('toh-2/ts-snippets/app.component.snippets.pt2.ts', 'heroes-ngfor-1', 'app.component.ts (ngFor)')

.alert.is-critical
  :marked
    `ngFor`의 앞에 asterisk(`*`)는 이 문법의 결정적인 부분입니다.

.l-sub-section
  :marked
    `ngFor`의 접두사(`*`)는 `<li>` 요소와 그것의 하위 요소들이 마스터 템플릿을 구성함을 가르킵니다.

    `ngFor` 디렉티브는 `AppComponent.heroes` 프로퍼티에 의해 반환되는 `heroes` 배열을 순회하여 이 템플릿의 인스턴스를 찍어냅니다.

    `ngFor`에 할당된 따옴표로 둘러쌓인 텍스트는 "*`heroes` 배열 내에서 각각의 영웅을 가져와 `hero`라는 지역 변수에 넣고, 대응되는 템플릿 인스턴스에서 이용 가능하도록 만드는 것"을 의미합니다.

    "hero" 앞에 `let` 키워드는 `hero`를 템플릿 입력 변수로 보겠다는 것입니다. 
    우리는 영웅의 프로퍼티에 접근하기 위해 템플릿 사이에서 이 변수를 참조할 수 있습니다. 

    [데이터 디스플레이](../guide/displaying-data.html#ngFor)와 [템플릿 문법](../guide/template-syntax.html#ngFor) 챕터에서
     `ngFor`와 템플릿 입력 변수에 관해 좀 더 알아보세요.

:marked
  이제 `<li>` 태그 사이에 영웅의 프로퍼티를 디스플레이하기 위한 `hero` 템플릿 변수를 사용하는 어떤 내용을 추가할 겁니다.

+makeExample('toh-2/ts-snippets/app.component.snippets.pt2.ts', 'ng-for', 'app.component.ts (ngFor template)')(format=".")

:marked
  브라우저가 리프레시되면 영웅들의 목록을 보게 될 겁니다~
  When the browser refreshes, we see a list of heroes!

  ### 영웅들을 스타일링하기
  영웅들의 목록은 꽤나 지루해보입니다. 
  마우스가 위에 올려진 영웅 그리고 선택된 영웅이 사용자에게 시각적으로 명확해 보였으면 합니다.

  다음의 CSS 클래스들을 `@Component` 데코레이터 상에 `styles` 프로퍼티를 설정하여 컴포넌트에 스타일을 추가해보죠:

+makeExample('toh-2/ts/app/app.component.ts', 'styles', 'app.component.ts (styles)')(format=".")

:marked
  멀티라인 문자열을 위해 다시 한번 back-tick 표기법을 사용했음을 알아두세요.

  꽤 많은 스타일이 있군요! 여기서 보이는데로 인라인으로 작성할 수도 있고 컴포넌트를 좀 더 쉽게 만들도록 각자의 파일로 만들 수도 있습니다. 
    그건 나중에 해보겠습니다. 지금은 하던 걸 계속해보죠.

  컴포넌트에 스타일을 할당하게 되면, 지정된 컴포넌트에 한정됩니다.
  스타일은 `AppComponent`에만 적용되어 외부 HTML에는 "누수"되지 않습니다.

  영웅들을 디스플레이하기 위한 템플릿은 이제 다음과 같습니다:
  
+makeExample('toh-2/ts-snippets/app.component.snippets.pt2.ts', 'heroes-styled', 'app.component.ts (styled heroes)')

.l-main-section
  :marked
    ## 영웅 선택하기
    영웅 목록을 가지고 있고 앱 내에 디스플레이되는 단일 영웅을 위한 뷰도 있습니다.
    그 목로과 단일 영웅의 뷰는 어떤 방법으로도 아직 연결되지 않았습니다.
    사용자가 목록으로부터 영웅을 선택하고 선택된 영웅이 상세 뷰에서 나오기를 바랍니다. 
    이 UI 패턴은 "master-detail"라고 널리 알려져 있습니다.
    경우에 마스터는 영웅 목록이고 상세는 선택된 영웅입니다.

    클릭 이벤트에 바인딩된 `selectedHero`라는 컴포넌트 프로퍼티를 통해 마스터를 상세로 연결해보죠.

    ### 클릭 이벤트
    `<li>`에 클릭 이벤트를 위해 Angular 이벤트 바인딩을 추가해주세요.

  +makeExample('toh-2/ts-snippets/app.component.snippets.pt2.ts', 'selectedHero-click', 'app.component.ts (template excerpt)')

  :marked
    이벤트 바인딩에 주목해보죠
  code-example(format="." language="bash").
    (click)="onSelect(hero)"
  :marked
    소괄호는 그 대상이 `<li>` 요소의 `click` 이벤트임을 확실히 해줍니다. 
    등부호의 오른편 표현식은 인자로 템플릿 입력 변수인 `hero`를 전달하는 `AppComponent` 메서드인 `onSelect()`를 호출합니다.
    그것은 예전에 `ngFor`에서 선언했던 `hero` 변수와 동일합니다.
  .l-sub-section
    :marked
      [사용자 입력](../guide/user-input.html)과 [템플릿 문법](../guide/template-syntax.html#event-binding) 챕터에서 이벤트 바인딩에 관해 좀 더 알아보세요.
  :marked
    ### 클릭 핸들러 추가
    이벤트 바인딩은 아직 존재하지 않는 `onSelect` 메서드를 참조합니다.
    이제 컴포넌트에 그 메서드를 추가해보죠.

    그런데 그 메서드는 무슨 일을 하는 걸까요? 그것은 사용자가 클릭한 영웅을 컴포넌트에서 선택된 영웅으로 설정해야 합니다.

    우리의 컴포넌트는 "선택된 영웅"도 아직 갖고 있지 않습니다. 그것부터 해보죠.

    ### 선택된 영웅을 드러내기

    `AppComponent`의 정적 `hero` 프로퍼티는 더 이상 필요치 않습니다.
    이것을 `selectedHero` 프로퍼티로 **대체**해보겠습니다:

  +makeExample('toh-2/ts/app/app.component.ts', 'selected-hero', 'app.component.ts (selectedHero)')

  :marked
    사용자가 영웅을 선택하기 전에 어떤 영웅도 선택하지 않기로 결정했기에 `hero`를 초기화했던 것과 다르게 `selectedHero`는 초기화하지 않기로 했습니다. 

    이제 사용자가 클릭하는 `hero`를 `selectedHero` 프로퍼티로 설정하는 **`onSelect` 메서드를 추가**해보겟습니다.
  +makeExample('toh-2/ts/app/app.component.ts', 'on-select', 'app.component.ts (onSelect)')

  :marked
    템플릿 내에 선택된 영웅의 상세 정보를 보여지도록 할 것입니다.  
    지금 이 순간에도, 템플릿은 예전의 `hero` 프로퍼티를 여전히 참조하고 있습니다. 
    템플릿이 새로운 `selectedHero` 프로퍼티에 바인딩되도록 변경해보죠.

  +makeExample('toh-2/ts-snippets/app.component.snippets.pt2.ts', 'selectedHero-details', 'app.component.ts (template excerpt)')
  :marked
    ### ngIf로 비어있는 상세 뷰를 숨기기

    앱이 로드되면 영웅의 목록을 볼 수 있지만 영웅은 아직 선택된 상태가 아닙니다.
    `selectedHero`는 `undefined`인 것이지요.
    그것이 브라우저의 콘솔에서 다음의 오류를 보게되는 이유입니다:

  code-example(language="html").
    EXCEPTION: TypeError: Cannot read property 'name' of undefined in [null]

  :marked
    템플릿 내에서 `selectedHero.name`을 디스플레이하고 있음을 기억하세요.
    이 name 프로퍼티는 `selectedHero`가 undefined이므로 존재하지 않습니다.

    우리는 선택된 영웅이 존재하기 전까지는 이 영웅 상세 뷰를 DOM 밖으로 놓아 이 문제를 해결하고자 합니다.

    `<div>`로 템플릿의 영웅 상세 내용 HTML을 감쌉니다.
    그런 뒤에 `ngIf` 빌트인 디렉티브를 추가하고 컴포넌트의 `selectedHero` 프로퍼티를 설정하면 됩니다.

  +makeExample('toh-2/ts-snippets/app.component.snippets.pt2.ts', 'ng-if', 'app.component.ts (ngIf)')

  .alert.is-critical
    :marked
      `ngIf` 앞의 asterisk(`*`)은 이 문법의 결정적인 부분임을 기억하세요.
  :marked
    `selectedHero`가 없을 때에는 `ngIf` 디렉티브가 DOM으로부터 영웅 상세 HTML을 제거합니다.
    영웅 상세 요소와 바인딩이 없으니 걱정할게 없습니다.

    영웅이 선택되면, `selectedHero`는 "truthy"가 되고 `ngIf`는 DOM 내로 영웅 상세 내용을 위치시키고 내재된 바인딩들을 평가하게 됩니다.
  .l-sub-section
    :marked
      `ngIf`와 `ngFor`는 "구조적 디렉티브"라고 불리는데, DOM의 일부분의 구조를 변경할 수 있기 때문입니다.
      다른 말로, Angular가 DOM 내에서 컨텐츠를 디스플레이하는 방법에 구조를 제공한다는 것입니다.
      
      [구조적 디렉티브](../guide/structural-directives.html)와 [템플릿 문법](../guide/template-syntax.html#directives)에서
      `ngIf`, `ngFor` 그리고 다른 구조적 디렉티브에 관해서 좀 더 알아보시기 바랍니다.

  :marked
    브라우저가 리프레시되면 영웅의 목록이 보이겠지만 선택된 영웅의 상세 정보는 보이지 않을 것입니다.
    `ngIf`는 `selectedHero`가 undefined인 이상 그것을 DOM 밖에서 유지할 겁니다.
    목록에서 영웅를 클릭하면, 선택된 영웅이 영웅 상세에 디스플레이됩니다.
    모든 것이 우리가 기대한 대로 동작하고 있을 겁니다.

    ### 선택을 스타일링하기

    우리는 이제 아래 상세 영역에서 선택된 영웅을 볼 수 있지만 위에 목록에서는 그 영웅의 위치를 빠르게 알 수 없습니다.
    마스터 목록에서 해당되는 `<li>`에 `selected` CSS 클래스를 적용하면 이것을 고칠 수 있습니다.
    예를 들어, 영웅 목록에서 Magneta를 선택하면 아래 보여지는 것처럼 서브 타이틀의 배경색을 달리하여 시각적으로 튀어나와 보이도록 만들 수 있습니다.

  figure.image-display
    img(src='/resources/images/devguide/toh/heroes-list-selected.png' alt="Selected hero")
  :marked
    템플릿에서 `selected` 클래스를 위해 `class` 상에 프로퍼티 바인딩을 추가할 것입니다. 현재의 `selectedHero`를 `hero`와 비교하는 비교식을 해당 바인딩에 설정할 것입니다.  

    키는 CSS 클래스의 이름(`selected`)이고 값은 두 영웅들이 동일하다면 `true` 그렇지 않으면 `false`가 됩니다. 
    즉 "*영웅들이 일치하면 `selected` 클래스를 적용하고 그렇지 않다면 제거하라*"라고 말하고 있는 겁니다.
  +makeExample('toh-2/ts-snippets/app.component.snippets.pt2.ts', 'class-selected-1', 'app.component.ts (setting the CSS class)')(format=".")
  :marked
    템플릿 내에서 `class.selected`가 대괄호(`[]`)로 둘러쌓여져 있는 것을 눈여겨 보십시오.
    이것은 프로퍼티 바인딩의 문법인데, 해당 바인딩은 데이터가 데이터 소스(`hero === selectedHero`라고 하는 표현식)로부터 `class`의 프로퍼티로, 단방향으로 흐르는 것을 말합니다.
  +makeExample('toh-2/ts-snippets/app.component.snippets.pt2.ts', 'class-selected-2', 'app.component.ts (styling each hero)')(format=".")

  .l-sub-section
    :marked
      템플릿 문법 챕터에서 [프로퍼티 바인딩](../guide/template-syntax.html#property-binding)에 대해 좀 더 알아보시기 바랍니다.

  :marked
    브라우저가 앱을 리로드하고 나서, 영웅 Magenta를 선택하면 배경색 덕분에 선택된 것을 분명히 알 수 있습니다.

  figure.image-display
    img(src='/resources/images/devguide/toh/heroes-list-1.png' alt="Output of heroes list app")

  :marked
    다른 영웅을 선택해보면 해당 영웅의 색상이 바뀌는 것을 분명히 볼 수 있습니다.  

    다음은 `app.component.ts'의 현재 상태입니다:

  +makeExample('toh-2/ts/app/app.component.ts', '', 'app.component.ts')

.l-main-section
:marked
  ## 지금까지 알아본 것들
  다음은 이 챕터에서 달성한 것들입니다:

  * Tour of Heroes는 이제 선택 가능한 영웅들의 목록을 디스플레이합니다
  * 영웅을 선택하고 선택된 영웅의 상세정보가 보여지는 기능을 추가했습니다
  * 빌트인 디렉티브인 `ngIf`와 `ngFor`를 컴포넌트의 템플릿 내에서 어떻게 사용해야 하는지에 대해서 배웠습니다
  
p 이 파트에 대한 #[+liveExampleLink2('', 'toh-2')]를 실행해보세요.
:marked
  ### 앞으로 가야할 길
  Tour of Heroes는 점점 발전하고 있지만 아직 완벽하지는 않습니다.
  전체 앱을 단일 컴포넌트에 집어넣을 수는 없으므로 하위 컴포넌트 내로 잘게 쪼게야 하며 [다음 챕터](toh-pt3.html)에서 배우게 될 내용처럼 상호작용하여 동작하도록 만들어야 합니다.
