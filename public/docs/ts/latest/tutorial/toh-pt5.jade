include ../_util-fns

:marked
  # 앱 여기 저기를 라우트하기
  Tour of Heroes 애플리케이션의 새로운 요구사항을 받았습니다: 
  * *대시보드* 뷰를 추가하세요.
  * *영웅들*과 *대시보드* 뷰 사이를 돌아다닐 수 있게 해주세요.
  * 어떤 뷰에서든 영웅을 클릭하면 선택한 영웅의 상세 뷰로 이동하도록 해주세요.
  * 이메일 내 *딥 링크*를 클릭하면 특정 영웅에 대한 상세 뷰가 열리도록 해주세요; 
  
  우리가 완료하고 나면, 사용자는 다음과 같이 앱을 돌아다닐 수 있게 될 겁니다:
figure.image-display
  img(src='/resources/images/devguide/toh/nav-diagram.png' alt="View navigations")
:marked
  이런 요구사항을 만족시키기 위해 앱에 Angular의 *컴포넌트 라우터*를 추가해보죠.
.l-sub-section
  :marked
    [라우팅과 네비게이션](../guide/router-deprecated.html) 챕터는 여기보다 좀 더 자세히 라우터를 다룹니다.
:marked
  [라이브 예제를 실행해보세요](/resources/live-examples/toh-5/ts/plnkr.html). 
.l-sub-section
  img(src='/resources/images/devguide/plunker-separate-window-button.png' alt="pop out the window" align="right" style="margin-right:-20px")
  :marked
    브라우저 주소창에서 URL이 변경되는 것을 보려면,
    오른쪽 위 구석에 'X' 버튼을 클릭하여 미리보기 윈도우를 새창에서 보세요:

.l-main-section
:marked
  ## 어디부터 시작해야 할까요
  Tour of Heroes를 계속하기 전에, 다음 구조를 확인하시기 바랍니다. 만약 다르다면, 이전 단계로 돌아가서 빠진게 없는지 확인하시기 바랍니다.

.filetree
  .file angular2-tour-of-heroes
  .children
    .file app
    .children
      .file app.component.ts
      .file hero.ts
      .file hero-detail.component.ts
      .file hero.service.ts
      .file main.ts
      .file mock-heroes.ts
    .file node_modules ...
    .file typings ...      
    .file index.html
    .file package.json
    .file styles.css
    .file systemjs.config.js
    .file tsconfig.json
    .file typings.json
:marked
  ### 앱 트랜스파일링과 실행을 유지하세요
  TypeScript 컴파일러 시작, 변경을 위한 watch, 그리고 서버 시작을 원할 겁니다. 다음 명령어를 통해 이런 것들이 가능합니다.

code-example(format="." language="bash").
  npm start

:marked
  이것은 Tour of Heroes을 빌드하는 내내 애플리케이션 실행을 유지시켜줄겁니다.

  ## 액션 계획
  다음은 우리의 계획입니다
  
  * `AppComponent`를 오로지 네비게이션만 다루는 애플리케이션 껍데기로 바꿉니다.
  * 현재의 `AppComponent`내의 *Heroes* 관심사를 `HeroesComponent`로 분리시킵니다.
  * 라우팅을 추가합니다
  * 새로운 `DashboardComponent`를 추가합니다
  * *대시보드*를 네비게이션 구조에 묶습니다.

.l-sub-section
  :marked
    *라우팅*은 *네비게이션*의 또 다른 이름입니다. *라우터*는 뷰와 뷰 사이를 이동하기 위한 메카니즘입니다.
    
.l-main-section    
:marked
  ## *AppComponent* 쪼개기
  
  현재의 앱은 `AppComponent`를 로드하고 영웅들의 목록을 즉시 디스플레이합니다.
  
  수정된 앱은 선택된 뷰(*대시보드*와 *영웅들*)로 껍데기를 표현해야 하고 그들 중 하나를 기본 뷰로 해야 합니다.

  `AppComponent`는 오직 네비게이션만 다뤄야 합니다.
  *Heroes*의 디스플레이를 `AppComponent`의 밖으로 즉 `HeroesComponent` 내로 옮겨보죠.

  ### *HeroesComponent*
  `AppComponent`는 *Heroes*에게 이미 헌식적입니다.
  `AppComponent` 밖으로 무엇을 이동시키는 대신, `HeroesComponent`로 이름을 바꾸고 새로운 `AppComponent` 껍데기를 따로 만듭니다.

  이 과정은:
  * `app.component.ts` 파일을 `heroes.component.ts`로 이름을 바꿉니다.
  * `AppComponent` 클래스를 `HeroesComponent`로 이름을 바꿉니다.
  * `my-app` 셀렉터를 `my-heroes`로 이름을 바꿉니다.

:marked
+makeExample('toh-5/ts/app/heroes.component.ts', 'heroes-component-renaming', 'app/heroes.component.ts (renaming)')(format=".")

:marked
  ## *AppComponent* 생성하기
  새로운 `AppComponent`이 애플리케이션 껍데기가 될 것입니다. 
  그것은 상단에 네비게이션 링크가 있고 이동한 페이지에 대한 디스플레이 영역을 아래에 두고 있습니다.
  
  초기화 단계는:
  
  * `app.component.ts'라는 새로운 파일을 만듭니다.
  * `AppComponent` 클래스를 정의합니다.
  * 그것을 `export`하면 `main.ts` 내에서 부트스트래핑 중에 그것을 참조할 수 있게 됩니다.
  * 애플리케이션의 `title` 프로퍼티를 드러냅니다.
  * 해당 클래스 위에 `my-app`이라는 셀렉터와 함께 `@Component` 메타데이터 데코레이터를 추가합니다.
  * `title` 프로퍼티 바인딩을 둘러싸는 `<h1>` 태그가 포함된 템플릿을 추가합니다.
  * 템플릿에 `<my-heroes>` 태그를 추가하여 다시 영웅들을 볼 수 있게 됩니다.
  * `directives` 배열에 `HeroesComponent`를 추가하면 Angular는 `<my-heroes>` 태그를 인식하게 됩니다.
  * `providers` 배열에 `HeroService`를 추가해야 하는데, 모든 다룬 뷰에서 그것을 필요로 하기 때문입니다.
  * 지원되는 `import` 구문을 추가하세요.
  
  첫번째 드래프트는 다음과 같습니다:
+makeExample('toh-5/ts/app/app.component.1.ts', null, 'app/app.component.ts (v1)')
:marked
.callout.is-critical
  header Remove <i>HeroService</i> from the <i>HeroesComponent</i> providers
  :marked
    `HeroesComponent`로 돌아가서 `providers` 배열로부터 **`HeroService`를 제거하세요**.
    우리는 이 서비스를 `HeroesComponent`로부터 `AppComponent`로 *끌어올리고 있습니다*.
    앱의 서로 다른 계층에서 이 서비스의 ***두 개 복사본을 원하지는 않습니다***.
:marked
  앱은 여전히 실행되고 있고 영웅들을 디스플레이합니다.
  `AppComponent`를 새로운 `AppComponent`와 `HeroesComponent`로 리팩토링한 것이 잘 동작합니다! 
  손실없이 끝냈군요.

:marked
  ## 라우팅 추가
  
  다음 단계를 진행할 준비가 됐습니다.
  영웅들을 자동으로 디스플레이하는 대신에, 사용자가 버튼을 클릭한 *이후에* 보여주고 싶습니다. 
  달리 말하자면, 영웅들의 목록으로 이동하고 싶은 것이죠.
  
  Angular의 *컴포넌트 라우터*를 필요로 합니다.
  
  ### 기본 태그 설정
  `index.html`을 열고 `<head>` 섹션의 위쪽에 `<base href="/">`을 추가하세요.
+makeExample('toh-5/ts/index.html', 'base-href', 'index.html (base href)')(format=".")
.callout.is-important
  header base href는 필수입니다
  :marked
    왜 이게 중요한지 알고 싶다면 [라우터](../guide/router-deprecated.html#!#base-href) 챕터의 *base href*를 보시기 바랍니다.
:marked
  ### 라우터를 이용 가능하도록 만드세요.
  *컴포넌트 라우터*는 서비스입니다. 서비스처럼, 그것을 임포트하고 `providers` 배열에 그것을 추가하여 애플리케이션에서 이용 가능하도록 만들어야 합니다.
  
  Angular 라우터는 여러 서비스(`ROUTER_PROVIDERS`), 여러 directives(`ROUTER_DIRECTIVES`) 그리고 설정 데코레이터(`RouteConfig`)의 결합으로 이루어집니다.
  그것들을 모두 함께 임포트할 것입니다:
+makeExample('toh-5/ts/app/app.component.2.ts', 'import-router', 'app.component.ts (router imports)')(format=".")
:marked
  다음으로 라우터 에셋을 *포함시키기* 위해 `directives`와 `providers` 메타데이터 배열을 갱신해야 합니다.
+makeExample('toh-5/ts/app/app.component.2.ts', 'directives-and-providers', 'app.component.ts (directives and providers)')(format=".")
:marked
  `directives` 배열에서 `HeroesComponent`를 제거했다는 것을 기억하시기 바랍니다.
  `AppComponent`는 더 이상 영웅들을 보여주지 않습니다; 그건 이제 라우터의 일이 될 것입니다.
  템플릿으로부터 `<my-heroes>`도 곧 제거할 것입니다.
  
  ### 라우터를 추가하고 설정하세요
 
  `AppComponent`는 아직 라우터를 가지고 있지 않습니다. 동시에 (a) 컴포넌트에 라우터를 추가하고 (b) 그 라우터를 *영웅들*과 함께 설정하기 위해서
  `@RouteConfig` 데코레이터를 사용할 것입니다.
  
  *라우트*는 라우터에게 사용자가 링크를 클릭하거나 브라우저 주소창에 URL을 붙여넣었을 때 어떤 뷰를 디스플레이할지를 알려줍니다.

  `HeroesComponent`에 첫번째 라우트를 정의해보죠.
+makeExample('toh-5/ts/app/app.component.2.ts', 'route-config', 'app.component.ts (RouteConfig for heroes)')(format=".")
:marked
  `@RouteConfig`는 *라우트 정의*의 배열을 받습니다.
  지금으로써 우리는 오직 한 개의 라우트를 갖고 있지만 나머지도 가능합니다. 더 추가할 예정이죠. 
  
  이 *라우트 정의*는 세 가지 파트를 가지고 있습니다:
  * **path**: 라우터는 이 라우트의 경로를 브라우저 주소 창 내 URL에 일치시킵니다(`/heroes`).
  
  * **name**: 라우트의 공식적인 이름입니다; *path*와의 혼선을 피하기 위해 *반드시* 소문자로 시작해야 합니다(`Heroes`).
  
  * **component**: 이 라우트로 이동하게 될 때 라우터가 만들어야 하는 컴포넌트입니다(`HeroesComponent`).

.l-sub-section
  :marked
    [라우팅](../guide/router-deprecated.html) 챕터에서 @RouteConfig로 라우트를 정의하는 방법에 대해서 알아보시기 바랍니다.
:marked
  ### 라우터 아울렛

  브라우저 주소 창에 `/heores` 경로를 붙여넣는다면, 
  라우터는 `'Heroes'` 라우트를 그것과 일치시키고 `HeroesComponent`를 디스플레이하려고 할 겁니다. 
  그러나 어디에 디스플레이해야 할까요?
  
  ***어디에 디스플레이해야 할지 알려주기 위해*** 템플릿 하단에 `<router-outlet>` 마커 태그를 추가해야 합니다.
  `RouterOutlet`은 `ROUTER_DIRECTIVES` 중 하나입니다.
  라우터는 우리가 애플리케이션을 통해 이동하면 `<router-outlet>` 아래에 각각의 컴포넌트를 즉시 디스플레이합니다.
  
  ### 라우터 링크
  실제로는 사용자가 주소창에 라우트 URL을 붙여넣을 거라고 기대하지 않습니다. 
  클릭됐을 때 `HeroesComponent`로 이동시키는 앵커 태그를 추가할 겁니다.
  
  수정된 템플릿은 다음과 같을 겁니다:
+makeExample('toh-5/ts/app/app.component.2.ts', 'template', 'app.component.ts (template for Heroes)')(format=".")
:marked
  앵커 태그 내 `[routerLink]` 바인딩에 주목하시기 바랍니다.
  `RouterLink` 디렉티브(`ROUTER_DIRECTIVES`의 또 다른 이름)를 배열에 바인드했는데, 사용자가 링크를 클릭했을 때 어디로 이동해야 하는지 라우터에게 알려줍니다.
  
  *링크 파라메터 배열*로 *라우팅 지시사항*을 정의하게 됩니다.
  위 작은 샘플에서는 해당 배열이 작은 따옴표로 둘러쌓인 라우트 이름인 오직 하나의 요소만 갖고 있습니다. 
  라우트 설정으로 돌아가, `'Heroes'`가 `HeroesComponent`를 바라보는 라우트 이름인지 확인해보세요.
.l-sub-section
  :marked
    [라우팅](../guide/router-deprecated.html#link-parameters-array) 챕터에서 *링크 파라메터 배열*에 관해 좀 더 알아보시기 바랍니다.
:marked
  브라우저를 리프레시하면 타이틀만 보일 뿐 영웅들의 목록이 보이지 않을 겁니다.
  Refresh the browser.  We see only the app title. We don't see the heroes list. 
.l-sub-section
  :marked
    브라우저 주소 창은 `/`일 겁니다.
    `HeroesComponent`의 라우트 경로는 `/`가 아니라 `/heroes`죠. 
    `/`와 일치하는 라우트는 없기 때문에 보여줄 것도 없습니다. 
    고쳐야 할 부분이지요.
:marked
  "Heroes" 네비게이션 링크를 클릭하면, 브라우저의 주소 창은 `/heroes`로 갱신되고
  이제 영웅들의 목록을 볼 수 있습니다. 마침내 이동하게 됐어요!

  이쯤에서 `AppComponent`는 다음과 같을 겁니다.
+makeExample('toh-5/ts/app/app.component.2.ts',null, 'app/app.component.ts (v2)')
:marked
  *AppComponent`는 이제 라우터에 붙게 되고, 라우트된 뷰를 디스플레이할 겁니다.
  이런 이유로 그리고 다른 컴포넌트와 구분하기 위해,
  이런 유형을 *라우터 컴포넌트*라고 부릅니다.

:marked
  ## *대시보드* 추가하기
  라우팅은 우리가 다중 뷰를 가질 때에만 그 의미가 있습니다. 다른 뷰를 추가해보죠.
  
  어딘가로부터 그리고 어딘가로 이동할 수 있는 `DashboardComponent` 플레이스홀더를 추가하겠습니다.
+makeExample('toh-5/ts/app/dashboard.component.1.ts',null, 'app/dashboard.component.ts (v1)')(format=".")
:marked
  나중에 좀 더 유용하게 만들어보겠습니다.

  ### 대시보드 라우트 설정하기
  `app.component.ts`로 돌아가서 대시보드로 이동할 수 있게 해보죠.
  
  대시보드 라우트 정의로 참조하도록 `DashboardComponent`를 임포트해주세요. 
  
  `@RouteConfig` 배열에 다음의 `'Dashboard'` 라우트 정의를 추가해주세요.
  Add the following `'Dashboard'` route definition to the `@RouteConfig` array of definitions.
+makeExample('toh-5/ts/app/app.component.ts','dashboard-route', 'app.component.ts (Dashboard Route)')(format=".")
.l-sub-section
  :marked
    **useAsDefault**
    
    우리는 앱이 시작됐을 때 대시보드를 보여주길 원하고
    브라우저 주소 창에 `/dashboard`라고 하는 URL을 보여주길 원합니다.
    브라우저는 주소창에 `/`로 시작된다는 것을 기억해두세요.
    하지만 그런 경로에 대한 라우트는 없고 만든 적도 없습니다. 
    
    운 좋게도 *라우트 정의*에 `useAsDefault: true` 프로퍼티를 추가할 수 있고
    라우터는 브라우저 URL와 일치하는 라우트가 없을 경우 대시보드를 디스플레이하게 될 겁니다.
:marked
  마지막으로 템플릿의 *Heroes* 링크 위에 대시보드 네비게이션 링크를 추가하세요.

+makeExample('toh-5/ts/app/app.component.ts','template', 'app.component.ts (template)')(format=".")
.l-sub-section
  :marked
    앞서 `<nav>` 태그 사이에 두 개의 링크를 두었습니다.
    그들은 아직 아무것도 하지 않지만 이 챕터에서 잠시 후에 링크를 꾸며주고 나면 좀 더 편리해질겁니다.
:marked
  브라우저를 리프레시해보세요. 앱은 대시보드를 디스플레이하고
  대시보드와 영웅들의 목록 사이를 이동할 수 있습니다.

  ## 대시보드의 탑 영웅들
  상위 4명의 영웅들을 단번에 알아볼 수 있도록 디스플레이하여 대시보드를 좀 더 좋게 만들어보죠.
  
  `template` 메타데이터를, 새로운 템플릿 파일을 지정하는 `templateUrl`로 대체해보죠.
  
+makeExample('toh-5/ts/app/dashboard.component.ts', 'template-url', 'app/dashboard.component.ts (templateUrl)')(format=".")
.l-sub-section
  :marked
    해당 경로를 _애플리케이션 루트로부터의 경로로_ 지정했는데 &mdash; 여기서는 `app/` &mdash;
    이는 Angular가 _기본적으로_ 상대 경로를 지원하지 않기 때문입니다. 
    원한다면 [컴포넌트 상대 경로](../cookbook/component-relative-paths)로 전환_할 수_ 있습니다.
:marked
  다음 내용으로 해당 파일을 만들어보세요:
+makeExample('toh-5/ts/app/dashboard.component.html', null, 'dashboard.component.html')(format=".")
:marked
  영웅 목록을 선회하고 이름들을 디스플레이하기 위해 다시 한번 `*ngFor`를 사용했습니다.
  이후 스타일링을 해주기 위해 여분의 `<div>` 요소를 추가했습니다.
  
  거기에는 우리가 아직 구현한 적 없는 `gotoDetail` 메서드에 대한 `(click)` 바인딩이 있고
  우리가 갖고 있지 않은 heroes 목록을 디스플레이하고 있습니다. 
  heroes에 대한 처리가 우리가 해야 할 일입니다.
  
  ### *HeroService* 공유
  
  컴포넌트의 `heroes` 배열에 값을 넣기 위해 `HeroService`를 재사용하고자 합니다.
  
  이 챕터 초기에 `HeroService`를 `HeroesComponent`의 `providers` 배열에서 제거한 뒤 최상위 컴포넌트인 `AppComponent`의 `providers` 배열에 그것을 추가했던 것을 상기시켜보세요.
  
  그러한 이동이 싱글턴의 `HeroService` 인스턴스를 만들어 냈고, 애플리케이션의 *모든* 컴포넌트에서 이용 가능합니다.
  우리는 `DashboardComponent`에 그것을 주입하여 사용하려고 합니다. 

  ### 영웅들을 가져오기
  `dashboard.component.ts`을 열고 필수적인 `import` 구문을 추가하세요.
+makeExample('toh-5/ts/app/dashboard.component.2.ts','imports', 'app/dashboard.component.ts (imports)')(format=".")
:marked
  `OnInit` 인터페이스가 필요한데, 이전에 했던 것처럼 `ngOnInit` 메서드에서 영웅들을 초기화할 것이기 때문이죠.
  그 타입들을 참조해야 하기에 `Hero`와 `HeroService`가 필요합니다.

  이제 다음과 같이 `DashbaordComponent` 클래스를 구현합니다:
+makeExample('toh-5/ts/app/dashboard.component.2.ts','component', 'app/dashboard.component.ts (class)')
:marked
  전에 `HeroesComponent`에서 이런 종류의 로직을 본 적이 있습니다.
  * `heroes` 배열 프로퍼티를 만듭니다
  * 생성자에서 `HeroService`를 주입하고 그것을 `heroService`라는 private 필드로 지정합니다
  * Angular `ngOnInit` 생명주기 후크 내에서 영웅들을 가져오기 위해 서비스를 호출합니다
  
  주목할 만한 차이점: *slice*로 네 명의 영웅(2번째, 3번째, 4번째 그리고 5번째)을 선별하여 가져오고
  `gotoDetail` 메서드를 구현할 준비가 되기 전까지 그대로 둡니다.
  
  브라우저를 리프레시해보면 새로운 대시보드에 네 명의 영웅들이 보일 겁니다.

.l-main-section  
:marked
  ## 영웅 상세 정보로 이동하기

  `HeroesComponent`의 아래 쪽에 선택된 영웅의 상세정보를 디스플레이하고 있지만,
  요구사항 중에 지정된 세가지 방법으로 `HeroDetailComponent`로 아직 *이동*하지는 않고 있습니다.
  1. *대시보드*에서 선택된 영웅으로 
  1. *Heroes* 목록에서 선택된 영웅으로
  1. 브라우저 주소 창에 붙여넣기된 "deep link" URL을 통해
  
  `'HeroDetail'` 라우트 추가가 우리가 시작할 지점임에 틀림없습니다.
  Adding a `'HeroDetail'` route seem an obvious place to start.
  
  ### 영웅 상세정보로 라우팅하기
  
  다른 라우트들이 설정되어 있는 `AppComponent`에 `HeroDetailComponent`로의 라우트를 추가할 겁니다.
  
  이 새로운 라우트는 *보여줘야 할 영웅이 누구인지*를 `HeroDetailComponent`에게 알려줘야 하기에 약간 특이합니다. 
  `HerosComponent` 혹은 `DashboardComponent`에게는 알려줘야 할 것이 없습니다.
  
  이제 상위 `HeroesComponent`는 다음과 같은 바인딩으로 영웅 객체를 컴포넌트의 `hero` 프로퍼티에 설정합니다.
code-example(format='').
  &lt;my-hero-detail [hero]="selectedHero">&lt;/my-hero-detail>
:marked
  그것은 분명히 우리의 라우팅 시나리오 중 어떤 것에서도 동작하지 않습니다.
  틀림없이 마지막 시나리오는 아닐 겁니다; 우리는 URL에 영웅 객체 전체를 임베드할 수 있습니다! 그러길 바라는 것도 아닙니다. 
  
  ### 파라메터화된 라우트
  우리는 URL에 영웅의 `id`를 추가*할 수 있습니다*. `id`가 11인 영웅으로 라우팅할 때, 다음과 같은 URL을 기대할 수 있습니다:
code-example(format='').
  /detail/11
:marked
  URL의 `/detail/`은 상수입니다. 숫자로 이어지는 `id` 부분은 영웅마다 변경될 겁니다.
  
  영웅의 `id`를 위해 존재하는 *파라메터*(혹은 *토큰*)으로 라우터의 변수 파트를 기술할 필요가 있습니다.
  
  ### 파라메터로 라우트 설정하기
  
  다음은 우리가 사용하게 될 *라우트 정의*입니다.
+makeExample('toh-5/ts/app/app.component.ts','hero-detail-route', 'app/app.component.ts (Route to HeroDetailComponent)')(format=".")
:marked
  경로 내의 콜론은 `:id`가 `HeroDetailComponent`로 이동할 때 특정 영웅의 `id`로 채워질 플레이스홀더임을 가르킵니다.
.l-sub-section
  :marked
    물론 이 라우트를 만들기 이전에 `HeroDetailComponent`를 임포트해야 합니다.
  +makeExample('toh-5/ts/app/app.component.ts','hero-detail-import')(format=".")
:marked
  `AppComponent`로 해야 할 일은 모두 끝났습니다.
  
  템플릿 `'Hero Detail'` 링크를 추가하지는 않을 건데
  사용자들이 개별적인 영웅을 보기 위해 네비게이션 *링크*를 클릭하지 않을 것이기 때문입니다.
  영웅이 대시보드에 표시되든 영웅 목록에 표시되든 *영웅*을 클릭할 것입니다. 
  
  이 챕터의 나중에 *영웅*을 클릭할 수 있게 될 겁니다.  
  `HeroDetailComponent`*로* 이동될 준비가 완료되기 전까지는 그에 관한 작업을 하는 것은 아무런 소용이 없습니다.
  
  그것은 `HeroDetailComponent` 정비를 필요로 할 겁니다.

.l-main-section  
:marked
  ## *HeroDetailComponent* 수정하기
  
  `HeroDetailComponent`를 다시 작성하기 이전에, 그것이 어떻게 구현되어 있는지 상기시켜보겠습니다:
+makeExample('toh-4/ts/app/hero-detail.component.ts', null, 'app/hero-detail.component.ts (current)')
:marked
  템플릿은 변하지 않을 겁니다. 동일한 방법으로 영웅을 디스플레이할 것입니다. 큰 변화는 영웅을 어떻게 가져오는지에 달려 있습니다.
  
  더 이상 상위 컴포넌트의 프로퍼티 바인딩으로 영웅을 가져오지 않을 겁니다.
  새로운 `HeroDetailComponent`는 라우터의 `RouteParams` 서비스로부터 `id` 파라메터를 가져와야 하고
  스토리지에서 그 `id`에 해당하는 영웅을 가져오기 위해서 `HeroService`를 사용해야 합니다.

  `RouteParams`를 참조하기 위해서는 임포트 구문이 필요합니다.
+makeExample('toh-5/ts/app/hero-detail.component.ts', 'import-route-params')(format=".")
:marked
  `HeroService`를 임포트했기에 영웅을 가져올 수 있습니다.
+makeExample('toh-5/ts/app/hero-detail.component.ts', 'import-hero-service')(format=".")
:marked
  `OnInit` 인터페이스를 임포트했는데 이는 `ngOnInit` 컴포넌트 생명주기 후크 내에서 `HeroService`를 호출할 것이기 때문입니다.
+makeExample('toh-5/ts/app/hero-detail.component.ts', 'import-oninit')(format=".")
:marked
  이전에 그랬듯이 생성자내로 private 변수로 만들어 `RouteParams` 서비스와 `HeroService` 모두 주입합니다:
+makeExample('toh-5/ts/app/hero-detail.component.ts', 'ctor', 'app/hero-detail.component.ts (constructor)')(format=".")
:marked
  클래스에게 `OnInit` 인터페이스를 구현해야 한다고 알려줄 것입니다.
+makeExample('toh-5/ts/app/hero-detail.component.ts', 'implement')(format=".")
:marked
  `ngOnInit` 생명주기 후크 내에서, `RouteParams` 서비스로부터 `id` 파라메터 값을 추출하고 그 `id`에 대한 영웅을 가져오기 위해 `HeroService`를 사용합니다.
+makeExample('toh-5/ts/app/hero-detail.component.ts', 'ng-oninit', 'app/hero-detail.component.ts (ngOnInit)')(format=".")
:marked
  `RouteParams.get` 메서드를 호출하여 `id`를 추출하는 방법을 알아두세요.
+makeExample('toh-5/ts/app/hero-detail.component.ts', 'get-id')(format=".")
:marked
  영웅의 `id`는 숫자입니다. 라우트 파라메터는 *항상 문자열*이죠.
  그래서 우리는 라우트 파라메터를 JavaScript (+) 연산자를 이용해 숫자로 바꿔준 것입니다. 
  
  ### *HeroService.getHero* 추가하기
  이 코드 상의 약간의 문제는 `HeroService`가 `getHero` 메서드를 가지고 있지 않다는 것입니다!
  앱이 고장났다는 것을 누군가가 알아차리기 전에 빨리 이 문제를 해결하는 것이 좋을 거 같습니다.
  
  `HeroService`를 열고 `getHero` 메서드를 추가하세요. 여전히 데이터 접근이 거짓이므로 별거 아닙니다.
+makeExample('toh-5/ts/app/hero.service.ts', 'get-hero', 'app/hero.service.ts (getHero)')(format=".")
:marked
  나머지 부분을 처리하기 위해 `HeroDetailComponet`를 반환합니다.
  
  ### 되돌아 가는 길 찾기
  
  `HeroDetailComponent`로 이동하는 방법에는 여러 가지가 있습니다.
  볼일을 마치고 어딘가 다른 곳으로 이동하는 방법에는 무엇이 있을까요?
  
  사용자는 `AppComponent` 내 두 링크 중 하나를 클릭할 수 있습니다. 혹은 브라우저의 뒤로 가기 버튼을 클릭할 수도 있죠.
  우리는 세번째 옵션인 `goBack` 메서드를 추가할 것입니다. 브라우저의 히스토리 스택 내에서 한 단계 뒤로 이동시켜주는 메서드를 말이죠.
 
+makeExample('toh-5/ts/app/hero-detail.component.ts', 'go-back', 'app/hero-detail.component.ts (goBack)')(format=".")
.l-sub-section
 :marked
   뒤로 계속 가는 것은 애플리케이션 영역 밖의 일입니다.
   데모에서는 받아들여질 수 있습니다. 실제 애플리케이션에서는
   , 아마도 [*routerCanDeactivate* 후크](../api/router/CanDeactivate-interface.html)로, 
   그런 일이 벌어지지 않도록 해야 합니다.
:marked
  그런 뒤에 이 메서드를 컴포넌트 템플릿의 아래쪽에 추가한 *뒤로 가기* 버튼에 대한 이벤트 바인딩과 연결하도록 합니다.
+makeExample('toh-5/ts/app/hero-detail.component.html', 'back-button')(format=".")
:marked
  이 버튼을 추가하기 위해 템플릿은 수정하는 것은 한 가지 이상의 점진적인 개선을 이끌어내고
  해당 템플릿을 `hero-detail.component.html`이라고 하는 파일로 이주시키도록 자극시킵니다.
+makeExample('toh-5/ts/app/hero-detail.component.html', '', 'app/hero-detail.component.html')(format=".")
:marked
  컴포넌트 메타데이터를 지금 막 만들어진 템플릿 파일을 가르키는 `templateUrl`을 가지도록 갱신하도록 합니다.
+makeExample('toh-5/ts/app/hero-detail.component.ts', 'template-url', 'app/hero-detail.component.ts (templateUrl)')(format=".")
:marked
  다음은 (거의) 완료된 `HeroDetailComponent`입니다.
+makeExample('toh-5/ts/app/hero-detail.component.ts', 'v2', 'app/hero-detail.component.ts (latest)')(format=".")
:marked


.l-main-section
:marked
  ## *대시보드* 영웅 선택하기
  사용자가 대시보드에서 영웅을 선택하면, 선택한 영웅을 보고 수정할 수 있도록 앱은 `HeroDetailComponent`로 이동해야 합니다.  
  
  대시보드 템플릿에서, 각각의 영웅에 대한 클릭 이벤트를, 선택된 `hero` 엔티티를 전달하는 `gotoDetail` 메서드에 바인딩했었습니다.
+makeExample('toh-5/ts/app/dashboard.component.html','click', 'app/dashboard.component.html (click binding)')(format=".")
:marked
  `DashboardComponent`를 다시 작성했을 때 `gotoDetail` 메서드를 그냥 남겨뒀었습니다.
  이제 그것을 실제로 구현할 겁니다.
+makeExample('toh-5/ts/app/dashboard.component.ts','goto-detail', 'app/dashboard.component.ts (gotoDetail)')(format=".")
:marked
  `gotoDetail` 메서드는 두 가지 단계에 걸쳐 살행됩니다:
  1. 라우트 *링크 파라메터 배열* 설정
  1. 배열을 라우터의 이동 메서드로 전달
  
  *링크 파라메터 배열*은 네비게이션 링크를 위해 `AppComponent`에 작성한 적이 있습니다.
  이 배열들은 목적지 라우트의 이름인 오직 하나의 요소만 가지고 있었습니다.
  
  이 배열은 목적지 라우트의 ***이름*** 그리고 ***라우트 파라메터 객체*** 이렇게 두 가지 요소를 가지는데, 이 중 라우트 파라메터 객체의 경우
  `id` 필드를 가지고 있고 이것이 선택된 영웅의 `id` 값이 됩니다.
  
  두 배열 아이템은 이 챕터의 초기에 `AppComponent`에 추가했던 파라메터화 했던 `HeroDetail` 라우트 설정 내의 ***이름***과 ***:id***가 됩니다.
+makeExample('toh-5/ts/app/app.component.ts','hero-detail-route', 'app/app.component.ts (hero detail route)')(format=".")
:marked
  `DashboardComponent`는 아직 라우터를 가지고 있지 않습니다. 우리는 그 라우터를 흔한 방법으로 만들려고 합니다:
  `router` 참조를 `import`하고 생성자에 주입하세요(`HeroService`와 마찬가지로):

+makeExample('toh-5/ts/app/dashboard.component.ts','import-router', 'app/dashboard.component.ts (excerpts)')(format=".")
+makeExample('toh-5/ts/app/dashboard.component.ts','ctor')(format=".")
:marked
  브라우저를 리프레시하고 대시보드에서 영웅을 선택해보세요; 앱은 직접 영웅의 상세정보로 이동해야 합니다.

.l-main-section
:marked
  ## *HeroesComponent*에서 영웅 선택하기
  `HerosComponent`에서 유사한 일들을 할 겁니다.
  
  해당 컴포넌트의 현재 템플릿은 위쪽에 영웅의 목록을, 아래쪽에 선택된 영웅의 상태를 보여주는 "master/detail" 스타일을 띄고 있습니다.
+makeExample('toh-4/ts/app/app.component.ts','template', 'app/heroes.component.ts (current template)')(format=".")
:marked
  템플릿의 마지막 줄에 `<my-hero-detail>` 태그로 된 부분을 삭제하세요.
  
  이제 더 이상 여기서 `HeroDetailComponent`을 볼 수 없을 겁니다. 
  영웅 상세 정보는 별도 페이지에서 디스플레이할 것이며 대시보드에서 그랬던 것처럼 해당 페이지로 이동하게 할 겁니다.
  
  그러나 조금 혼란스러울 수도 있습니다.
  사용자가 목록에서 영웅을 선택할 경우, 상세 페이지로 가길 *원하지 않을 수도* 있습니다. 
  대신 *이* 페이지에서 *작은 상세*를 보여줘야 하며, 그럴 경우 *완전한 상세* 페이지로 이동하도록 해주는 버튼을 클릭할 수 있도록 해줘야 합니다.
  
  ### *작은 상세* 추가하기
  `<my-hero-detail>`이 사용되었던 템플릿의 아래쪽에 다음의 HTML 코드 조각을 추가하세요:
+makeExample('toh-5/ts/app/heroes.component.html','mini-detail')(format=".")
:marked
  영웅을 클릭하고 난 뒤에, 사용자는 영웅 목록 아래에서 다음과 비슷한 무언가를 볼 수 있어야 합니다:
  
figure.image-display
  img(src='/resources/images/devguide/toh/mini-hero-detail.png' alt="Mini Hero Detail" height="70")
:marked
  ### *UpperCasePipe*로 형식화하기
  
  영웅의 이름이 대문자로 디스플레이되었다는 것을 상기하시기 바랍니다. 그것은 인터폴레이션 바인딩에 살짝 포함된 `UpperCasePipe`의
  효과입니다. pipe 오퍼레이터, ( | ) 뒤에 있는 것을 보시기 바랍니다.
+makeExample('toh-5/ts/app/heroes.component.html','pipe')(format=".")
:marked
  Pipe는 형식 문자열, 통화량, 날짜, 그리고 다른 디스플레이 데이터에 대해 좋은 방법입니다.
  Angular는 몇 가지 pipe를 제공하고 그것을 재정의할 수도 있습니다.
.l-sub-section
  :marked
    Pipe에 관해서는 [Pipes](../guide/pipes.html) 챕터를 참고하시기 바랍니다.
:marked
  ### 컨텐츠를 컴포넌트 파일 밖으로 내보내기
  아직 끝나지 않았습니다. 사용자가 *View Details* 버튼을 클릭하면 `HeroDetailComponent`로의 이동을 지원하도록 컴포넌트를 클래스를 변경해야 하기 때문이죠.
  
  이 컴포넌트 파일은 실제로 큽니다. 그것의 대부분은 템플릿 혹은 CSS 스타일 혹은 둘 다 입니다.
  
  HTML과 CSS가 있는 가운데서 컴포넌트 로직을 찾기란 쉽지 않습니다.
  
  컴포넌트를 변경하기에 앞서 템플릿과 스타일을 각자의 파일로 분리시키도록 해보죠: 
  1. 템플릿 내용물을 `heroes.component.html` 파일 내로 *잘라내고 붙여넣으세요*.
  1. 스타일 내용물을 `heroes.component.css` 파일 내로 *잘라내고 붙여넣으세요*.
  1. 두 파일을 참조하기 위해 컴포넌트 메타데이터의 `templateUrl`과 `styleUrls` 프로퍼티를 설정해주세요.
  
  우리는 더 이상 `HeroDetailComponent`를 `HeroesComponent` 안에서 디스플레이하지 않습니다. 그 컴포넌트로 이동하기 때문이죠.
  그래서 그것을 메타데이터 중 `directives` 배열에서 제거할 수 있습니다. `directives` 배열은 이제 비어있을테고 그렇기에 그것을 삭제할 겁니다.
  또 `HeroDetailComponent`의 임포트 구문도 삭제해도 됩니다.
  
  수정된 컴포넌트의 메타데이터는 다음과 같습니다:
+makeExample('toh-5/ts/app/heroes.component.ts', 'metadata', 'app/heroes.component.ts (revised metadata)')(format=".")
:marked
  이제 대시보드에서 했던 것처럼 컴포넌트 클래스를 수정하여 어떻게 되가는지를 알 수 있습니다:
  1. `router`를 임포트합니다
  1. 생성자 안으로 `router`를 주입합니다(`HeroService`와 함께)
  1. `HeroDetail`과 *링크 파라메터 배열*를 파라메터로 하는 `router.navigate` 메서드를 호출하도록 `gotoDetail` 메서드를 구현합니다.
  
  다음은 수정된 컴포넌트 클래스입니다:
+makeExample('toh-5/ts/app/heroes.component.ts', 'class', 'app/heroes.component.ts (class)')
:marked
  브라우저를 리프레쉬하고 클릭해보세요.
  대시보드부터 영웅 상세 정보 그리고 뒤로 가기까지 앱 내를 찾아다닐 수 있습니다.
  영웅 목록에서 작은 상세 정보 그리고 영웅 상세 정보로, 그리고 다시 영웅 목록으로 돌아가기까지 말이죠.
  대시보드와 영웅 목록 사이를 앞뒤로 뛰어넘어 이동할 수 있게 된겁니다. 
  
  우린 이 챕터에서 진행하려고 했던 네비게이션 요구사항을 모두 달성했습니다.

.l-main-section
:marked
  ## 앱 스타일링
  이 앱은 기능은 문제없지만 약간 못생겼죠.
  우리의 크리에이티브 디자이너 팀이 앱을 좀 더 나아보이게 만들어줄 몇 가지 CSS 파일을 제공해주었습니다.

  ### 대시보드 스타일링
  디자이너는 한 줄의 사각형 내에 대시보드 영웅들을 디스플레이해야 한다고 생각했나봅니다.
  그들은 그런 목적을 위해 반응형 디자인을 위한 몇 가지 간단한 미디어 쿼리들이 포함되어 있는 60 라인 정도의 CSS를 주었습니다.

  만약 컴포넌트 `styles` 메타데이터에 이 60 라인을 붙여넣을 경우,  
  컴포넌트 로직이 완전히 그것들에 의해 묻혀버릴 것이 분명합니다. 
  그렇게 하지 않을 겁니다. 어쨋거나 개별적인 `*.css`에서 CSS를 수정하는 것이 더 쉬우니까요

  `dashboard.component.css` 파일을 `app` 폴더에 추가하고 다음과 같이 컴포넌트 메타데이터인 `styleUrls` 배열 프로퍼티에 그 파일을 참조시키도록 하죠:
+makeExample('toh-5/ts/app/dashboard.component.ts', 'css', 'app/dashboard.component.ts (styleUrls)')(format=".")
:marked
.l-sub-section
  :marked
    `styleUrls` 프로퍼티는 스타일 파일 이름(경로를 포함하여)들을 요소들로 하는 배열입니다.
    필요하다면 서로 다른 위치 상의 여러 스타일 파일들을 나열할 수 있습니다.
    `templateUrl`로, _애플리케이션 루트로 되돌아 가는 모든 경로_를 지정해야 합니다.
:marked
  ### 스타일리쉬한 영웅 상세
  디자이너들은 특히 `HeroDetailComponent`를 위한 CSS 스타일도 주었습니다.
  
  `app` 폴더에 `hero-detail.component.css`를 추가하고 `DashboardComponent`에서 했던 것처럼 `styleUrls` 배열 안에 참조시키기 바랍니다.
  
  다음은 앞서 말한 컴포넌트의 CSS 파일들입니다.
+makeTabs(
  `toh-5/ts/app/hero-detail.component.css,
  toh-5/ts/app/dashboard.component.css`,
  null,
  `app/hero-detail.component.css,
  app/dashboard.component.css`)
:marked
  ### 네비게이션 링크 스타일링
  디자이너들은 `AppComponent` 안의 네이게이션 링크를 좀 더 선택 가능한 버튼처럼 보이도록 만들어 주기 위한 CSS를 주었습니다.
  `<nav>` 태그 안의 그 링크들을 감싸기로 했습니다.
  
  `app` 폴더에 다음의 내용으로 `app.component.css` 파일을 추가합니다.
+makeExample('toh-5/ts/app/app.component.css', 'css', 'app/app.component.css (Navigation Styles)')
.l-sub-section
  :marked
    ***router-link-active* 클래스**
    
    Angular 라우터는 활성화된 라우트와 일치하는 HTML 네비게이션 요소에 `router-link-active` 클래스를 추가합니다. 
    우리가 해야 할 것은 그것을 위한 스타일을 정의하는 것 뿐입니다. 좋아요!
:marked
  `AppComponent`의 `styleUrls` 프로퍼티에 이 CSS 파일을 설정합니다.
+makeExample('toh-5/ts/app/app.component.ts','style-urls', 'app/app.component.ts (styleUrls)')(format=".")
:marked
  ### 글로벌 애플리케이션 스타일
  컴포넌트에 스타일을 추가하면, 컴포넌트가 필요로 하는 모든 것들을 &mdash; HTML, CSS, 코드 &mdash; 하나의 편리한 곳에
  함께 모아둘 수 있습니다. 그것들을 모두 패키지하고 컴포넌트를 또 다른 곳에서 재사용하는 것은 꽤 쉽습니다.
  
  우리는 모든 컴포넌트의 외부인 *애플리케이션 계층*에서 스타일을 만들 수도 있습니다.

  디자이너들은 전체 앱에 걸치 요소들에 적용할 어떤 기본적인 스타일들을 제공해주었습니다.
  최상위 폴더에 `styles.css` 라는 이름의 새로운 파일을 만들고 다음을 추가해주시기 바랍니다.
+makeExample('toh-5/ts/styles.1.css', '', 'styles.css (App Styles)')(format=".")

:marked
  전통적인 방법으로 `index.html`에 위에서 만든 스타일시트를 참조시킵니다.
+makeExample('toh-5/ts/index.html','css', 'index.html (link ref)')(format=".")
:marked
 이제 앱을 보시기 바랍니다. 우리의 대시보드, 영웅들, 그리고 네비게이션 링크들이 달라졌습니다!
 
figure.image-display
  img(src='/resources/images/devguide/toh/dashboard-top-heroes.png' alt="View navigations")

.l-main-section
:marked
  ## 애플리케이션 구조와 코드
  
  [이 챕터의 라이브 예제의](/resources/live-examples/toh-5/ts/plnkr.html) 샘플 소스 코드를 검토해보세요.
  다음 구조를 가지고 있는지 검증해보시기 바랍니다:

.filetree
  .file angular2-tour-of-heroes
  .children
    .file app
    .children
      .file app.component.ts
      .file app.component.css
      .file dashboard.component.css
      .file dashboard.component.html
      .file dashboard.component.ts
      .file hero.ts
      .file hero-detail.component.css
      .file hero-detail.component.html
      .file hero-detail.component.ts
      .file hero.service.ts
      .file heroes.component.css
      .file heroes.component.html
      .file heroes.component.ts
      .file main.ts
      .file mock-heroes.ts
    .file node_modules ...
    .file typings ...      
    .file index.html
    .file package.json
    .file styles.css
    .file systemjs.config.json
    .file tsconfig.json
    .file typings.json
:marked

.l-main-section
:marked
  ## 되돌아보기

  ### 해왔던 일
  우린 이 챕터에서 굉장한 일들을 했습니다.
  - 다른 컴포넌트 사이를 찾아 돌아다니도록 하기 위해 Angular의 *컴포넌트 라우터*를 추가했습니다
  - 네비게이션 메뉴 아이템들을 표현하기 위해 라우터 링크를 만드는 방법을 배웠습니다
  - 사용자가 선택한 영웅의 상세 정보로 이동하기 위해 라우터 파라메터를 사용해봤습니다
  - 여러 컴포넌트 사이에서 `HeroService`를 공유했습니다.
  - HTML와 CSS를 컴포넌트 파일 밖의 그들 자신의 파일로 이동시켰습니다.
  - 형식 데이터에 `uppercase` 파이프를 추가했습니다

  ### 앞으로 할 일
  애플리케이션을 빌드하는 데 필요로 하는 기본적인 것들을 많이 이루었습니다.
  여전히 안되어 있는 중요한 것도 있습니다: 원격 데이터 접근이죠.
   
  다음 튜토리얼 챕터에서, 우리는 가짜 데이터를 http를 사용해 서버에서 가져온 데이터로 교체할 것입니다.
