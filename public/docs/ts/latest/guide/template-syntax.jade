block includes
  include ../_util-fns
  - var _JavaScript = 'JavaScript';
  //- Double underscore means don't escape var, use !{__var}.
  - var __chaining_op = '<code>;</code> or <code>,</code>';
  - var __new_op = '<code>new</code>';
  - var __objectAsMap = 'object';

:marked
  우리의 Angular 애플리케이션은 컴포넌트 클래스의 인스턴스(*component*)와 그에 대해 사용자가 사용하게 될 템플릿의 상호작용을 통해 사용자가 보게 되는 것과 하는 것을 가능하도록 관리해줍니다.
  
  우리 중 많은 이들이 모델-뷰-컨트롤러(MVC) 혹은 모델-뷰-뷰모델(MVVM)에 대한 경험으로 컴포넌트/템플릿의 이중성에 친숙합니다.
  Angular에서, 컴포넌트는 컨트롤러/뷰모델의 일부 역할을 하고 템플릿은 뷰를 나타냅니다.

  뷰을 위한 템플릿을 작성하기 위해 갖춰야 것들을 알아보도록 하죠.
  템플릿 문법의 기본적인 요소들을 다룰 것입니다:
  We’ll cover these basic elements of template syntax:

  * [HTML](#html)
  * [어구 삽입](#interpolation)
  * [템플릿 표현식](#template-expressions)
  * [템플릿 구문](#template-statements)
  * [바인딩 문법](#binding-syntax)
  * [프로퍼티 바인딩](#property-binding)
  * [어트리뷰트, 클래스, 그리고 스타일 바인딩](#other-bindings)
  * [이벤트 바인딩](#event-binding)
  * [`NgModel`을 이용한 양방향 데이터 바인딩](#ngModel)
  * [빌트인 디렉티브](#directives)
    * [NgClass](#ngClass)
    * [NgStyle](#ngStyle)
    * [NgIf](#ngIf)
    * [NgSwitch](#ngSwitch)
    * [NgFor](#ngFor)
  * [* 와 &lt;template>](#star-template)
  * [템플릿 참조 변수](#ref-vars)
  * [입출력 프로퍼티](#inputs-outputs)
  * [템플릿 표현식 연산자](#expression-operators)
    * [파이프](#pipe)
    * [안전한 네비게이션 연산자 (?.)](#safe-navigation-operator)

p.
  #[+liveExampleLink2()]은 이 챕터 내에서 설명하고 있는 모든 문법과 코드 조각을 다룹니다.

.l-main-section
:marked
  ## HTML
  HTML은 Angular 템플릿의 언어입니다.
  [퀵스타트](../quickstart.html) 애플리케이션은 순수한 HTML로 되어 있는 템플릿을 가지고 있었죠:

code-example(language="html" escape="html").
  <h1>My First Angular 2 App</h1>

:marked
  거의 대부분의 모든 HTML 문법은 유효한 템플릿 문법입니다. `<script>` 요소는 확실히 예외입니다; 스크립트 주입 공격의 위험을 제거하려고 금지시켰습니다. (실제로, `<script>`는 무시됩니다.)

  몇 가지 합법적인 HTML들이 템플릿 내에서는 허용되지 않습니다. `<html>`, `<body>`, `<base>` 요소들은 유용한 역할을 하지 못합니다. 그외의 거의 모든 것들은 문제가 되지 않습니다.

  템플릿의 HTML 어휘는 컴포넌트, 그리고 새로운 요소와 어트리뷰트로 표현되는 디렉티브로 확장될 수 있습니다.
  그리고 데이터 바인딩을 통해 동적으로 DOM 값들을 가져오고 설정하는 방법을 배울려고 합니다.

  HTML이 얼마나 더 고급스러운 템플릿이 될 수 있는지 보기 위해 데이터 바인딩의 첫번째 형식인 어구 삽입를 보도록 하죠.

.l-main-section
:marked
  ## 어구 삽입
  Angular 문서 앞부분에서 중괄호 두개, `{{`와 `}}`로 이루어진 어구 삽입을 보았습니다.
+makeExample('template-syntax/ts/app/app.component.html', 'first-interpolation')(format=".")
:marked
  HTML 요소 태그 사이 혹은 어트리뷰트 할당문 사이의 텍스트 안으로 계산된 문자열을 넣기 위해 어구 삽입을 사용합니다.

+makeExample('template-syntax/ts/app/app.component.html', 'title+image')(format=".")
:marked
  괄호 사이의 구성 요소들은 일반적으로 컴포넌트 프로퍼티의 이름이 됩니다. Angular는 이 이름을 그와 연관된 컴포넌트 프로퍼티의 문자열 값으로 대체합니다.
  이 예제에서, Angular는 `title`과 `heroImageUrl` 프로퍼티를 평가하고
  먼저 볼드체로 애플리케이션 타이틀을 디스플레이하고 그후 영웅의 이미지를 디스플레이하도록 "빈 칸을 채웁니다".

  더 일반적으로 말하자면, 괄호 사이의 구성 요소들은 Angular가 먼저 **평가한** 뒤 **문자열로 변환한** **템플릿 표현식**입니다.
  다음의 어구 삽입은 괄호 사이의 두개의 번호를 더하는 부분을 나타냅니다:
+makeExample('template-syntax/ts/app/app.component.html', 'sum-1')(format=".")
:marked
  여기서 `getVal()`한 것처럼 표현식은 호스트 컴포넌트의 메서드를 실행할 수 있습니다:
+makeExample('template-syntax/ts/app/app.component.html', 'sum-2')(format=".")
:marked
  Angular는 겹중괄호 내의 모든 표현식을 평가하고, 표현식의 결과를 문자열로 변환하며 근처의 리터럴 문자열과 합칩니다.
  끝으로, 결합된 삽입결과를 **요소 혹은 디렉티브 프로퍼티**에 할당하게 됩니다.

  요소 태그 사이에는 결과를 삽입되고 어트리뷰트에는 할당되는 것처럼 보입니다.
  그렇게 생각하는 것이 편리하고, 이런 실수로 무척이나 고통받습니다.
  그러나 엄밀히 말하자면 옳습니다. 어구 삽입은, Angular가, 아래에서 설명하게 될 [프로퍼티 바인딩](#property-binding) 내로 변환하는 특별한 문법입니다.

  그러나  먼저, 템플릿 표현식과 구문에 대해 자세히 들여다 보겠습니다.

<a id="template-expressions"></a>
.l-main-section
:marked
  ## 템플릿 표현식
  템플릿 **표현식**은 값을 만들어 냅니다.
  Angular는 표현식을 실행하고 그것을 바인딩 대상의 프로퍼티에 할당합니다;
  그 대상은 HTML 요소, 컴포넌트 혹은 디렉티브가 되겠죠.

  어구 삽입 괄호 사이에 템플릿 표현식을 두게 됩니다. `{{1 + 1}}`과 같이 말이죠. 
  [프로퍼티 바인딩](#property-binding) 섹션에서 템플릿 표현식을 다시 보게 될텐데,
  이는 `[property]="expression"`에서 처럼 `=` 심볼의 오른쪽 따옴표 내에서 표현됩니다.
  
  #{_JavaScript}처럼 보이는 언어로 템플릿 표현식을 작성하게 됩니다.
  많은 #{_JavaScript} 표현식을 템플릿 표현식으로 사용할 수 있지만, 모두는 아닙니다.

  부수 효과가 있거나 유발시킬 가능성이 있는 #{_JavaScript} 표현식은 다음을 포함하여 금지되었습니다:

  * 할당 (`=`, `+=`, `-=`, ...)
  * !{__new_op}
  * !{__chaining_op}을 이용한 체이닝 표현식
  * 증감 연산자 (`++` and `--`)

:marked
  #{_JavaScript} 문법과 다른 주목할 만한 차이점들이 있습니다:

block notable-differences
  :marked
    * 비트와이즈 연산자 `|`와 `&`를 지원하지 않음 
    * `|`와 `?.`와 같은 새로운 [템플릿 표현식 연산자](#expression-operators) 

h3#expression-context 표현식 컨텍스트

block template-expressions-cannot
  :marked
    아마도 좀 더 놀라겠지만, 템플릿 표현식은 글로벌 네임스페이스에서 아무것도 참조할 수 없습니다.
    `window` 혹은 `document`를 참조할 수 없습니다.
    `console.log` 혹은 `Math.max`를 호출할 수 없죠.
    템플릿 표현식은 표현식 컨텍스트의 멤버들만 참조하도록 제한되어 있습니다.

:marked
  *표현식 컨텍스트*는 전형적으로 바인딩 값들의 소스가 되는 **컴포넌트 인스턴스**입니다.

  겹중괄호로 둘러쌓인 *title*, 즉 `{{title}}`를 보게 된다면, `title`이 데이터가 바인딩된 컴포넌트의 프로퍼티라는 것을 알 수 있습니다. 
  `[disabled]="isUnchanged"`에서 *isUnchanged*를 보게 된다면, 해당 컴포넌트의 `isUnchanged` 프로퍼티를 참조하고 있다는 것을 알 수 있습니다.

  컴포넌트 그 자체는 보통 표현식 *컨텍스트*인데, 어떤 경우든지 템플릿 표현식은 보통 해당 컴포넌트를 참조합니다

  표현식 컨텍스트는 컴포넌트 외의 객체들을 포함할 수 있습니다.
  [템플릿 참조 변수](#ref-vars)는 하나의 대안 컨텍스트 객체입니다.

:marked
  <a id="no-side-effects"></a>
  ### 표현식 가이드라인
  템플릿 표현식은 애플리케이션 만들거나 망가뜨릴 수 있습니다.
  다음의 가이드라인을 따르길 바랍니다:

  * [보이지 않는 부수 효과](#no-visible-side-effects)
  * [빠른 실행](#quick-execution)
  * [단순](#simplicity)
  * [멱등 법칙](#idempotence)

  이 가이드라인에 대한 예외는 오직 당신이 완벽하게 이해하는 특정 환경에서 존재할 수 있습니다.

  #### 보이지 않는 부수 효과

  템플릿 표현식은 대상 프로퍼티의 값 이외에는 애플리케이션의 어떤 상태도 바꿀 수 없습니다.

  이 규칙은 Angular의 "양방향 데이터 흐름" 정책에 있어 필수적인 것입니다.
  컴포넌트의 값을 읽는 것이 어떤 다른 디스플레이드되고 있는 값을 변경해서는 결코 안됩니다.
  뷰는 단일 렌더링 단계 내내 안정되어야 합니다.

  #### 빠른 실행
  Angular는 우리의 생각보다 더 자주 템플릿 표현식을 실행합니다.
  모든 keypress 혹은 mousemove 이후에 실행될 수 있습니다.
  표현식은 빠르게 끝나야 하는데 사용자 경험은, 특히 상대적으로 느린 디바이스 상에서, 더딜 수 있습니다.
  연산 비용이 비싼 경우 다른 값으로부터 연산된 캐싱 값들을 생각해보세요.

  #### 단순함
  상당히 복잡한 템플릿 표현식 작성이 가능하다고 할지라도, 실제로는 그래서는 안됩니다.

  프로퍼티 이름 혹은 메서드 호출은 평균 수준이 되어야 합니다.
  경우에 따라서는 Boolean의 부정(`!`)은 괜찮습니다.
  그 외의 경우에는, 애플리케이션과 비지니스 로직을 컴포넌트 자체로 국한시키는 것이 개발하고 테스트하기 더 쉬울 것입니다.

  #### 멱등 법칙
  [멱등](https://en.wikipedia.org/wiki/Idempotence) 표현식은 부수 효과로부터 자유롭고 Angular의 변경 감지 성능을 향상시켜주므로 이상적입니다.

  Angular 용어 중, 멱등 표현식은 의존적인 값 중 하나가 변경될 때까지 항상 *정확하게 같은 것*을 반환합니다.
:marked
  의존 값들은 이벤트 루프의 단일 턴 동안 변경되어서는 안됩니다.
  멱등 표현식이 문자열 혹은 숫자를 반환한다면, 연달아 두 번 호출된 경우 동일한 문자열 혹은 숫자를 반환합니다.
  만약 표현식이 객체(#{_an} `#{_Array}`를 포함하는)를 반환한다면, 연달아 두 번 호출된 경우 동일한 객체 *참조*를 반환합니다.

.l-main-section#template-statements
:marked
  ## 템플릿 구문

  템플릿 **구문은** 요소, 컴포넌트 혹은 디렉티브와 같은 바인딩 대상에 의해 일어나는 **이벤트**에 답합니다.

  [이벤트 바인딩](#event-binding) 섹션에서 템플릿 구문을 보게 될텐데, `(event)="statement"`와 같이 `=` 심볼의 우측 따옴표 내에서 표현됩니다.

  템플릿 구문은 *부수 효과를 가지고 있습니다*.
  그것은 사용자 입력으로부터 애플리케이션 상태를 갱신하는 방법입니다.
  이벤트에 대응하는 것 외에는 다른 역할이 불가능합니다.

.l-sub-section
  :marked
    이벤트에 대응하는 것은 Angular의 "양방향 데이터 흐름"의 또 다른 면입니다.
    이벤트 루트의 턴 동안 무엇이 변하든, 어디에서 변환든 자유롭습니다.

:marked
  템플릿 표현식과 같이, 템플릿 *구문*은 #{_JavaScript}처럼 보이는 언어를 사용합니다.
  템플릿 구문 파서는 템플릿 표현식 파서와는 좀 다르며, 특히 기본적인 할당(`=`) 그리고 표현식 체이닝(!{__chaining_op}을 이용한)을 지원합니다.

  하지만, 약간의 #{_JavaScript} 문법은 따르지 않습니다:
  * !{__new_op}
  * 증감 연산자, `++` 와 `--`
  * `+=`과 `-=`와 같은 연산자 할당
  * 비트와이즈 연산자 `|` 과 `&`
  * [템플릿 표현식 연산자](#expression-operators)

:marked
  ### 구문 컨텍스트

  표현식과 마찬가지로, 구문은 구문 컨텍스트 내에 있는 것만 참조 가능합니다 - 일반적으로 이벤트를 바인딩하고 있는 **컴포넌트 인스턴스**가 되겠지요.

block statement-context
  :marked
    템플릿 구문은 글로벌 네임스페이스 내의 어떤 것도 참조할 수 없습니다.
    `window` 혹은 `document`를 참조할 수 없으며, `console.log` 혹은 `Math.max`를 호출할 수 없습니다.

:marked
  `(click)="onSave()"`의 *onSave*은 데이터가 바인딩된 컴포넌트 인스턴스의 메서드가 되어야 한다는 것은 틀림없습니다.

  구문 컨텍스트는 컴포넌트 외에 다른 객체를 포함할 수도 있습니다.
  [템플릿 참조 변수](#ref-vars)는 하나의 대안 컨텍스트 객체입니다.
  우리는 이벤트 바인딩된 구문 내에서 예약어인 `$event` 심볼을 빈번히 보게 될텐데,
  이는 발생한 이벤트의 "메시지" 혹은 "페이로드"를 말합니다.

  ### 구문 가이드라인

  표현식과 마찬가지로, 복잡한 템플릿 구문 작성을 피하시기 바랍니다.
  메서지 호출 혹은 단순한 프로퍼티 할당이 모범적입니다.

  이제 템플릿 표현식과 구문에 대해, 어구 삽입을 뛰어넘어 데이터 바인딩 문법의 여러 변형에 관해 배울 준비가 되었다는 것을 느낄 것입니다.

.l-main-section
:marked
  <a id="binding-syntax"></a>
  ## 바인딩 문법: 개요
  데이터 바인딩은 사용자들이 애플리케이션 데이터 값들로 보게 될 내용들을 코디네이트하기 위한 메커니즘입니다.
  HTML에 값을 밀어넣거나, HTML로부터 값을 가져올 때,
  그런 자질구레한 일들을 바인딩 프레임워크에 맡길 수 있다면, 애플리케이션은 작성하고 읽고 유지보수하기 더욱 쉬워질 겁니다. 
  바인딩 소스와 대상 HTML 요소 사이에 바인딩을 선언하여 프레임워크가 일을 대신하도록 해볼 겁니다.

  Angular는 많은 종류의 데이터 바인딩을 제공하며, 이 챕터 속에서 각각의 내용들을 다룰 것입니다.
  먼저 Angular의 데이터 바인딩과 문법에 대한 고수준의 관점을 살펴볼 것입니다.  

  데이터 흐름의 방향으로 모든 바인딩을 세 개의 카테고리로 그룹지을 수 있습니다.
  각각의 카테고리는 개별적인 문법을 가지고 있습니다:
table
  tr
    th 데이터 흐름
    th 문법
    th 바인딩 타입
  tr
    td 단방향<br>데이터 소스로부터<br>뷰 대상으로
    td
      code-example().
        {{expression}}
        [target] = "expression"
        bind-target = "expression"
    td.
      어구 삽입<br>
      프로퍼티<br>
      어트리뷰트<br>
      클래스<br>
      스타일
    tr
      td 단방향<br>뷰 대상으로부터<br>데이터 소스로
      td
        code-example().
          (target) = "statement"
          on-target = "statement"
      td 이벤트
    tr
      td 양방향
      td
        code-example().
          [(target)] = "expression"
          bindon-target = "expression"
      td 양방향

:marked
  어구 삽입 이외의 바인딩 타입은 등호 좌측에 구두법(`[]`, `()`)으로 둘러쌓이거나 접두사(`bind-`, `on-`, `bindon-`)로 전처리된 **대상의 이름**을 두고 있습니다.

  그 대상이란 것은 무엇일까요? 그 질문에 대답하기 전에, 새로운 방법으로 템플릿 HTML을 바라보도록 우리 자신을 시험해야 합니다.

  ### 새로운 멘탈 모델

  데이터 바인딩의 모든 힘과 커스텀 마크업으로 HTML 어휘를 확장하기 위한 우리의 능력으로, 템플릿 HTML을 *HTML 플러스*로 생각하려고 노력하고 있습니다. 

  음, 그게 HTML 플러스*입니다*.
  그러나 우리가 사용해왔던 HTML과 상당히 다릅니다.
  그래서 새로운 멘탈 모델이 진정 필요한 겁니다.

  HTML 개발의 일반적인 과정에서, HTML 요소로 시각적 구조를 만들어 내고 문자열 상수로 요소의 어트리뷰트를 설정하여 요소들을 수정하게 됩니다.

+makeExample('template-syntax/ts/app/app.component.html', 'img+button')(format=".")
:marked
  Angular 템플릿에서도 그와 같은 방법으로 구조를 만들고 어트리뷰트 값들을 초기화합니다.

  그런 뒤 HTML을 인캡슐화하는 컴포넌트로 새로운 요소들을 만들고 그것들이 네이티브 HTML 요소인 것인양 템플릿 안에 위치시키는 방법을 배우게 됩니다.
+makeExample('template-syntax/ts/app/app.component.html', 'hero-detail-1')(format=".")
:marked
  그게 HTML 플러스입니다.

  이제 데이터 바인딩에 대해 배우기 시작했습니다. 우리가 제일 먼저 만났던 바인딩은 다음과 같습니다:

+makeExample('template-syntax/ts/app/app.component.html', 'disabled-button-1')(format=".")
:marked
  순식간에 그 특유의 괄호 표기법에 대해서 알게 되었습니다.
  그것을 넘어서, 버튼의 `disabled` 어트리뷰트에 바인딩하고 있으며 컴포넌트의 `isUnchanged` 프로퍼티의 현재 값을 그것에 설정하고 있다는 것을 직관적으로 알 수 있습니다. 

  우리의 직관은 틀렸습니다! 우리의 지난 모든 날의 HTML에 관한 멘탈 모델은 우리를 잘못 이끌고 있습니다. 
  사실, 데이터 바인딩을 시작하고 나면, 더 이상 HTML *어트리뷰트*로 작업하는 것이 불가능합니다. 어트리뷰트를 설정할 수는 없습니다.
  DOM 요소, 컴포넌트 그리고 디렉티브의 *프로퍼티*를 설정하게 되는 것이죠.

.l-sub-section
  :marked
    ### HTML 어트리뷰트 vs. DOM 프로퍼티

    HTML 어트리뷰트와 DOM 프로퍼티 사이의 차이점은 Angular 바인딩이 어떻게 동작하는지에 대한 이해로부터 생겨납니다.

    **어트리뷰트는 HTLM에 의해 정의됩니다. 프로퍼티는 DOM(Document Object Model)에 의해 정의되죠.**

    * 몇몇 HTML 어트리뷰트들은 프로퍼티와 1:1 매핑을 가지고 있습니다. `id`가 그에 대한 한 가지 예죠.

    * 몇몇 HTML 어트리뷰트들은 대응하는 프로퍼티가 없습니다. `colspan`이 그에 대한 하나의 예입니다.

    * 몇 가지 DOM 프로퍼티들은 대응하는 어트리뷰트가 없습니다. `textContent`가 그에 대한 하나의 예입니다.

    * 많은 HTML 어트리뷰트들은 프로퍼티에 대한 맵으로 표현됩니다... 그러나 우리가 생각한 방식은 아닙니다.

    저 마지막 카테고리가 특히 혼란스러울 수 있습니다... 다음의 일반적인 규칙을 이해하기 전까지는요:

    **어트리뷰트들은 DOM 프로퍼티를 *초기화*한 뒤에 그들도 초기화됩니다.
    프로퍼티 값들은 변할 수 있습니다; 어트리뷰트 값들은 그럴 수 없죠.**

    예를 들어, 브라우저가 `<input type="text" value="Bob">`를 렌더링하는 경우,
    "Bob"이라고 *초기화된* `value` 프로퍼티로 그에 상응하는 DOM 노드를 만들어 냅니다.

    사용자가 입력 박스 안에 "Sally"라고 입력하면, DOM 요소의 `value` *프로퍼티*는 "Sally"가 됩니다.
    그러나 HTML `value` *어트리뷰트*는, 우리가 해당 속성에 대해 입력 요소에 질의한 경우라면(`input.getAttribute('value') // returns "Bob"`),
    우리가 처음 봤던 것처럼 변하지 않고 유지되어 있을 겁니다.

    HTML 어트리뷰트 `value`는 *초기* 값을 지정합니다; DOM의 `value` 프로퍼티는 *현재* 값이죠.

    `disabled` 어트리뷰트는 또 다른 특이한 예입니다. 버튼의 `disabled` *프로퍼티*는 기본적으로 `false` 값을 가져 버튼은 활성 상태가 됩니다.
    `disabled` *어트리뷰트*를 추가하면, 그것으로 버튼의 `disabled` *프로퍼티*가 `true`로 초기화되어 버튼이 비활성 상태가 됩니다.

    `disabled` *어트리뷰트*를 추가하거나 제거하는 것이 버튼을 비활성시키거나 활성시킵니다.
    *어트리뷰트*의 값 자체는 관계가 없는데, `<button disabled="false">Still Disabled</button>`이라고 작성한다고 해서 버튼을 활성화시키지 못한다는 얘기입니다.

    버튼의 `disabled` *프로퍼티* 설정(Angular 바인딩을 생각해보세요)이 버튼을 비활성화하거나 활성화시키는 거죠.
    *프로퍼티*의 값은 문제가 되지 않습니다.

    **둘이 같은 이름을 갖고 있더라도 HTML 어트리뷰트와 DOM 프로퍼티는 같은 것이 아닙니다.**

:marked
  이것은 매우 중요합니다. 이에 대해 다시 얘기할만큼요.

  **템플릿 바인딩은 *프로퍼티* 그리고 *이벤트*와 함께 동작하지 *어트리뷰트*는 아닙니다.*.

.callout.is-helpful
  header A world without attributes
  :marked
    Angular2의 세계에서, 어트리뷰트의 유일한 역할은 요소와 디렉티브의 상태를 초기화하는 것입니다.
    우리가 데이터를 바인딩하는 경우, 요소와 디렉티브의 프로퍼티와 이벤트와 함께 배타적으로 다루게 됩니다. 
    어트리뷰트는 전혀 효과를 발휘하지 못합니다.
:marked
  이런 모델을 마음 속에 굳게 간직하고, 바인딩 대상에 대해 배워보도록 하죠.

  ### 바인딩 대상
  **데이터 바인딩의 대상**은 DOM 내의 어떤 것이 됩니다.
  바인딩 타입에 의존하여, 그 대상은 (요소 | 컴포넌트 | 디렉티브)의 프로퍼티, (요소 | 컴포넌트 | 디렉티브)의 이벤트, 혹은 (드물게) 어트리뷰트 이름이 될 수 있습니다.
  다음은 요약 내용입니다"

// If you update this table, UPDATE it in Dart & JS, too.
<div width="90%">
table
  tr
    th 바인딩 타입
    th 대상
    th 예제
  tr
    td 프로퍼티
    td.
      요소&nbsp;프로퍼티<br>
      컴포넌트&nbsp;프로퍼티<br>
      디렉티브&nbsp;프로퍼티
    td
      +makeExample('template-syntax/ts/app/app.component.html', 'property-binding-syntax-1')(format=".")
  tr
    td 이벤트
    td.
      요소&nbsp;이벤트<br>
      컴포넌트&nbsp;이벤트<br>
      디렉티브&nbsp;이벤트
    td
      +makeExample('template-syntax/ts/app/app.component.html', 'event-binding-syntax-1')(format=".")
  tr
    td 양방향
    td.
      이벤트와 프로퍼티
    td
      +makeExample('template-syntax/ts/app/app.component.html', '2-way-binding-syntax-1')(format=".")
  tr
    td 어트리뷰트
    td.
      어트리뷰트
      (예외)
    td
      +makeExample('template-syntax/ts/app/app.component.html', 'attribute-binding-syntax-1')(format=".")
  tr
    td 클래스
    td.
      <code>class</code> 프로퍼티
    td
      +makeExample('template-syntax/ts/app/app.component.html', 'class-binding-syntax-1')(format=".")
  tr
    td 스타일
    td.
      <code>style</code> 프로퍼티
    td
      +makeExample('template-syntax/ts/app/app.component.html', 'style-binding-syntax-1')(format=".")
</div>

:marked
  구조적인 클라우드로부터 내려와 각각의 바인딩 타입을 자세하게 들여다보도록 하겠습니다.

.l-main-section
:marked
  ## 프로퍼티 바인딩
  뷰 요소의 프로퍼티에 [템플릿 표현식](#template-expressions)의 값을 설정하고자 하는 경우 템플릿의 **프로퍼티 바인딩**을 작성합니다.

  대부분의 일반적인 프로퍼티 바인딩은 요소 프로퍼티를 컴포넌트 프로퍼티 값에 설정하게 됩니다.
  다음은 이미지 요소의 `src` 프로퍼티를 컴포넌트의 `heroImageUrl` 프로퍼티에 설정하는 예입니다:
+makeExample('template-syntax/ts/app/app.component.html', 'property-binding-1')(format=".")
:marked
  다음은 컴포넌트가 `isUnchanged` 상태일 경우 버튼을 비활성화하는 예입니다:
+makeExample('template-syntax/ts/app/app.component.html', 'property-binding-2')(format=".")
:marked
  다음은 디렉티브의 프로퍼티를 설정하는 예입니다:
+makeExample('template-syntax/ts/app/app.component.html', 'property-binding-3')(format=".")
:marked
  이제 또 다른 예제는 커스텀 컴포넌트의 모델 프로퍼티를 설정하는 것입니다(상위 컴포넌트와 하위 컴포넌트가 커뮤니케이션하기 위한 좋은 방법):
+makeExample('template-syntax/ts/app/app.component.html', 'property-binding-4')(format=".")
:marked
  ### *내부를 향하는* 단방향
  사람들은 자주 프로퍼티 바인딩을 *단방향 데이터 바인딩*으로 설명하는데, 컴포넌트의 데이터 프로퍼티로부터 대상 요소 프로퍼티내로,
  단뱡향으로 값을 흘려보내기 때문입니다.

  우리는 대상 요소의 *밖으로* 값을 내보내기 위해서 프로퍼티 바인딩을 사용할 수는 없습니다.
  프로퍼티의 값을 읽기 위해 대상 요소의 프로퍼티를 바인딩할 수 없다는 것이죠. 오직 설정만 가능합니다.

.l-sub-section
  :marked
    그 외에 대상 요소의 메서드를 *호출*하기 위해 프로퍼티 바인딩을 사용할 수 있습니다.

    요소가 이벤트를 발생시키면 [이벤트 바인딩](#event-binding)으로 이벤트를 리스닝할 수 있습니다.

    대상 요소의 프로퍼티를 읽어야 한다던가 메서드 중 하나를 호출해야 한다면, 다른 기술이 필요할 겁니다.
    [viewChild](../api/core/ViewChild-var.html)와 [contentChild](../api/core/ContentChild-var.html)에 대한
    API 레퍼런스를 참고하시기 바랍니다.

// TODO (global): once we have api docs everywhere, change /docs/ts/latest/ to ../

:marked
  ### 바인딩 대상
  대괄호 사이의 요소 프로퍼티는 대상 프로퍼티를 나타냅니다.
  다음 코드의 대상 프로퍼티는 이미지 요소의 `src` 프로퍼티입니다.

+makeExample('template-syntax/ts/app/app.component.html', 'property-binding-1')(format=".")
:marked
  어떤 이들은 *정규 형태*로 알려진, `bind-` 접두사 대안을 좀 더 선호합니다:
+makeExample('template-syntax/ts/app/app.component.html', 'property-binding-5')(format=".")
:marked
  대상의 이름은 항상 프로퍼티의 이름인데, 다른 것들이 이름과 같은 경우에도 그렇습니다.
  `src`를 보았다면 그것이 어트리뷰트의 이름일거라고 생각할수도 있습니다. 하지만 그렇지 않습니다. 그것은 이미지 요소 프로퍼티의 이름입니다.

  요소 프로퍼티들은 좀 더 일반적인 대상이 될 수도 있는데, Angular는, 다음 예제에서 처럼, 그 이름이 알고 있는 디렉티브의 프로퍼티인지를 먼저 알아보게 됩니다:
+makeExample('template-syntax/ts/app/app.component.html', 'property-binding-3')(format=".")

.l-sub-section
  :marked
    기술적으로, Angular는 해당 이름을 디렉티브의 `inputs` 배열 혹은 `@Input()`으로 데코레이트된 프로퍼티 내에서 나열된 프로퍼티의 이름들과 일치시켜 봅니다.  
    어떤 inputs들은 디렉티브 자체의 프로퍼티와 매핑되겠죠.
:marked
  해당 이름이 알려진 디렉티브 혹은 요소의 프로퍼티와 일치하지 않는다면, Angular는 "알수없는 디렉티브" 오류를 보고합니다. 

  ### 부수 효과 피하기
  이미 알아본 데로, 템플릿 표현식 평가는 보이지 않는 부수 효과를 가지고 있습니다.
  표현식 언어 자체는 안전하게 유지하기 위한 부분이 됩니다.
  프로퍼티 바인딩 표현식 내에서는 어떤 것에도 값을 할당할 수 없으며 증감 연산자를 사용할 수도 없습니다.

  물론, 표현식은 부수 효과를 가지고 있는 프로퍼티 혹은 메서드를 실행할 수도 있습니다. Angular는 그것을 알거나 멈출 방법을 갖고 있지 않습니다.

  표현식은 `getFoo()`와 같은 것을 호출할 수 있는데, 알 수 있는 거라곤 `getFoo()`가 하는 일입니다.
  `getFoo()`가 무언가 변화시키고 어떤 것과 바인딩된다면, 달갑지 않은 경험을 각오해야 할 겁니다.
  Angular는 변경된 값을 디스플레이할 수도 있고 그렇지 않을 수도 있습니다.
  Angular는 변경을 감지하고 경고 오류를 던질 수도 있습니다.
  한 가지 일반적인 충고: 데이터 프로퍼티나 값을 반환하는 메서드만 연결하고 그 이상으로 표현식을 길어지게 하지 마세요.

  ### 적당한 타입 반환하기
  템플릿 표현식은 대상 프로퍼티가 원하는 값의 타입을 평가해야 합니다.
  대상 프로퍼티가 문자열을 원하면 문자열을 반환해야 하고, 숫자를 원하면 숫자를, 객체를 원하면 객체를 반환해야 합니다.

  `HeroDetail` 컴포넌트의 `hero` 프로퍼티는 `Hero` 객체를 원하는데, 이것이 바로 프로퍼티 바인딩에서 보내야 하는 것입니다:
+makeExample('template-syntax/ts/app/app.component.html', 'property-binding-4')(format=".")

block dart-type-exceptions
  //- N/A

:marked
  ### 괄호를 기억하세요
  괄호는 Angular에게 템플릿 표현식을 평가하라고 알려줍니다.
  괄호를 잊는다면, Angular는 문자열을 상수로 다루고 그 문자열로 *대상 프로퍼티를 초기화*합니다.
  그것은 문자열을 평가하지 *않습니다*!

  다음과 같은 실수는 하지 마세요:
+makeExample('template-syntax/ts/app/app.component.html', 'property-binding-6')(format=".")

block dart-type-exception-example
  //- N/A

a(id="one-time-initialization")
:marked
  ### 1회용 문자열 초기화
  다음의 모든 것들이 참이라면 괄호를 생략*해야* 합니다:
  * 대상 프로퍼티가 문자열 값을 받아들이는 경우
  * 문자열이 템플릿 내로 고정되는 고정 값일 경우
  * 이 초기값이 결코 변경되지 않는 경우

  일상적으로 일반적인 HTML에서는 이런 방법으로 어트리뷰트를 초기화하고 디렉티브와 컴포넌트 프로퍼티 초기화에 대해서 잘 동작합니다.
  다음의 예제는 `HeroDetailComponent`의 `prefix` 프로퍼티를 템플릿 표현식이 아닌 고정 문자열로 초기화합니다.
  Angular는 그것을 설정한 뒤 더 이상 관여하지 않습니다.
+makeExample('template-syntax/ts/app/app.component.html', 'property-binding-7')(format=".")
:marked
  반면, `[hero]` 바인딩은 컴포넌트의 `currentHero` 프로퍼티에 라이브 바인딩을 유지하게 됩니다.

  ### 프로퍼티 바인딩 혹은 어구 삽입?
  우리는 자주 어구 삽입과 프로퍼티 바인딩 중 하나를 선택하게 됩니다. 다음의 바인딩들은 동일한 동작을 합니다:
+makeExample('template-syntax/ts/app/app.component.html', 'property-binding-vs-interpolation')(format=".")
:marked
  어구 삽입은 여러 경우에 사용되는 프로퍼티 바인딩의 편리한 대안입니다.
  사실, Angular는 뷰를 렌더링하기 이전에 대응하는 프로퍼티 바인딩 내로 어구 삽입들을 옮깁니다.
  
  어떤 것을 더 선호할 만한 기술적인 이유는 없습니다.
  그렇기에 우리는 가독성 쪽을 좀 더 우선시하는데, 이는 어구 삽입 쪽일 가능성이 큽니다.
  우리는 코딩 스타일 규칙을 만들고 그 규칙에 따르고 수정 중인 업무에 가장 알맞다고 느껴지는 형식을 선택하기를 제안합니다.

.l-main-section
:marked
  <a id="other-bindings"></a>
  ## 어트리뷰트, 클래스, 그리고 스타일 바인딩
  템플릿 문법은 프로퍼티 바인딩과는 잘 맞지 않는 시나리오를 위해 특수한 단방향 바인딩을 제공합니다. 

  ### 어트리뷰트 바인딩
  **어트리뷰트 바인딩**로 직접 어트리뷰트의 값을 설정할 수 있습니다.
.l-sub-section
  :marked
    이것은 바인딩이 대상 프로퍼티를 설정하는 규칙에 대한 유일한 예외입니다. 이것은 어트리뷰트를 만들고 설정하는 유일한 바인딩이기도 합니다.

:marked
  우리는 이 챕터 내내 프로퍼티 바인딩으로 요소의 프로퍼티를 설정하는 것이 문자열로 어트리뷰트를 설정하는 것보다 항상 좋다고 강요받아 왔습니다.
  Angular는 왜 어트리뷰트 바인딩을 제공하는 걸까요?

  **바인딩해야 할 요소 프로퍼티가 없는 경우라면 어트리뷰트 바인딩을 사용해야 합니다.**

  [ARIA](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA), [SVG](https://developer.mozilla.org/en-US/docs/Web/SVG)
  그리고 table span 어트리뷰트를 생각해보세요. 그들은 순수한 어트리뷰트입니다.
  요소 프로퍼티와는 관계가 없고, 요소 프로퍼티를 설정하지도 않습니다. 
  바인딩할 프로퍼티 대상이 없는거죠.

  우린 다음과 같은 것들을 작성하려고 했을 때 이 사실을 깨닫고 고통스러워 했습니다:
code-example(language="html").
  &lt;tr>&lt;td colspan="{{1 + 1}}">Three-Four&lt;/td>&lt;/tr>
:marked
  다음과 같은 오류를 받게 됐지요:
code-example(format="nocode").
  Template parse errors:
  Can't bind to 'colspan' since it isn't a known native property
:marked
  위 메시지가 알려주듯이, `<td>` 요소는 `colspan` 프로퍼티를 가지고 있지 않습니다.
  그것은 "colspan" *어트리뷰트*를 가지고 있을 뿐이고, 어구 삽입과 프로퍼티 바인딩은 어트리뷰트가 아닌, *프로퍼티*만을 설정할 수 있죠.

  그런 어트리뷰트를 바인딩하 줄 어트리뷰트 바인딩이 필요하게 된 겁니다.

  어트리뷰트 바인딩 문법은 프로퍼티 바인딩을 닮아있습니다.
  괄호 사이에 요소 프로퍼티를 두는 대신, **`attr`**라는 접두사로 시작해 마침표(`.`)를 찍고 뒤에 어트리뷰트를 이름을 두도록 했습니다. 
  그런 뒤 문자열로 해석될 표현식을 사용하여 어트리뷰트 값을 설정합니다.

  다음은 계산된 값에 `[attr.colspan]`을 바인딩한 것입니다:
+makeExample('template-syntax/ts/app/app.component.html', 'attrib-binding-colspan')(format=".")
:marked
  다음은 테이블이 어떻게 렌더링되는지 보여줍니다:
  <table border="1px">
    <tr><td colspan="2">One-Two</td></tr>
    <tr><td>Five</td><td>Six</td></tr>
   </table>

  어트리뷰트 바인딩에 대한 최우선의 유스케이스 중 하나는 ARIA 어트리뷰트를 설정하는 것입니다. 다음 예제처럼요:
+makeExample('template-syntax/ts/app/app.component.html', 'attrib-binding-aria')(format=".")
:marked
  ### 클래스 바인딩

  우리는 **클래스 바인딩**으로 요소의 `class` 어트리뷰트로부터 CSS 클래스 이름들을 추가하거나 제거할 수 있습니다.

  클래스 바인딩 문법은 프로퍼티 바인딩과 닮아 있습니다.
  괄호 사이에 요소 프로퍼티를 두는 대신에, `class`라는 접두사로 시작해, 부가적으로 마침표(`.`)를 찍고 CSS 클래스의 이름을 두도록 했습니다: `[class.class-name]`.

  다음 예제들에서는 클래스 바인딩으로 애플리케이션의 "special"이라는 클래스를 추가하거나 제거하는 방법을 보겠습니다.
  여기서는 바인딩없이 어트리뷰트를 설정해보겠습니다:
+makeExample('template-syntax/ts/app/app.component.html', 'class-binding-1')(format=".")
:marked
  바인딩을 이용해 위 내용을 원하는 클래스 이름의 문자열로 대체할 수 있습니다; 이게 대치 바인딩의 전부입니다.
+makeExample('template-syntax/ts/app/app.component.html', 'class-binding-2')(format=".")

block dart-class-binding-bug
  //- N/A

:marked
  마지막으로, 우리는 특정 클래스 이름에 바인딩할 수 있습니다.
  Angular는 템플릿 표현식 결과가 #{_truthy}인 경우 클래스를 추가합니다.
  표현식 결과가 #{_falsey}인 경우에는 클래스를 제거하게 됩니다.
+makeExample('template-syntax/ts/app/app.component.html', 'class-binding-3')(format=".")

.l-sub-section
  :marked
    단일 클래스 이름을 토글하기 위해서 이게 좋은 방법이긴 하지만,
    동시에 여러 클래스 이름을 관리하기 위해서는 대체로 [NgClass directive](#ngClass) 더 선호합니다.

:marked
  ### 스타일 바인딩

  **스타일 바인딩**으로 인라인 스타일을 설정할 수 있습니다.

  스타일 바인딩 문법은 프로퍼티 바인딩과 닮아 있습니다.
  괄호 사이에 요소 프로퍼티를 두는 대신에, `style`이라는 접두사로 시작해, 마침표(`.`)를 찍고, CSS 스타일 프로퍼티의 이름을 두는 것입니다: `[style.style-property]`.

+makeExample('template-syntax/ts/app/app.component.html', 'style-binding-1')(format=".")
:marked
  어떤 스타일 바인딩의 스타일들은 단위 확장을 가지고 있을 수도 있습니다. 다음 예제에서는 조건에 따라 폰트 사이즈를 “em”과 “%”으로 설정하고 있습니다.
+makeExample('template-syntax/ts/app/app.component.html', 'style-binding-2')(format=".")

.l-sub-section
  :marked
    이것이 단일 스타일을 설정하는 좋은 방법이긴 하나,
    동시에 여러 인라인 스타일을 설정하는 경우 [NgStyle directive](#ngStyle)을 대체적으로 더 선호합니다.

.l-sub-section
  :marked
    _style property_의 이름은 위에서 보았던 데로 [dash-case](glossary.html#dash-case)로 작성되거나
    혹은 `fontSize`처럼 [camelCase](glossary.html#camelcase)로 작성될 수 있다는 것을 알아두시기 바랍니다.

block style-property-name-dart-diff
  //- N/A

.l-main-section
:marked
  ## 이벤트 바인딩
  먼저 다루었던 바인딩들은 데이터를 한방향으로 보냅니다: *컴포넌트로부터 요소로*.

  사용자는 스크린을 그저 쳐다보고만 있지는 않습니다. 입력 박스에 텍스트를 입력하기도 하고, 목록에서 아이템을 선택하기도 합니다.
  버튼도 클릭할 수 있죠. 어떤 사용자의 행동은 반대 방향의 데이터 흐름의 결과가 되기도 합니다: *요소로부터 컴포넌트로*.

  사용자의 행동에 관해 알 수 있는 유일한 방법은 키눌림, 마우스 이동, 클릭, 그리고 터치와 같은 이벤트들을 리스닝하는 것입니다.
  이를 위해 Angular 이벤트 바인딩을 통해 사용자 행동에 대한 대응하면 됩니다.

  이벤트 바인딩 문법은 등호 왼편의 괄호 내에 **대상 이벤트**를 구성하고 오른 편에는 따옴표 안에 [템플릿 구문](#template-statements)을 두면 됩니다.
  다음의 이벤트 바인딩은 버튼 클릭 이벤트를 리스닝하는데, 클릭이 발생할 때마다 컴포넌트의 `onSave()` 메서드가 호출됩니다:
+makeExample('template-syntax/ts/app/app.component.html', 'event-binding-1')(format=".")
:marked
  ### 대상 이벤트
  **괄호 사이의 이름** &mdash; 예를 들어, `(click)` &mdash;은 대상 이벤트를 지정합니다.
  다음 예제에서, 대상은 버튼의 클릭 이벤트입니다.
+makeExample('template-syntax/ts/app/app.component.html', 'event-binding-1')(format=".")
:marked
  어떤 사람들은 *정규 형식*으로 알려진 `on-` 접두사 대안을 더 선호합니다:
+makeExample('template-syntax/ts/app/app.component.html', 'event-binding-2')(format=".")
:marked
  요소의 이벤트들은 일반적인 대상이 될테지만, Angular는, 다음 예제에서처럼, 먼저 해당 이름이 알려진 디렉티브의 이벤트 프로퍼티와 일치하는지를 먼저 알아봅니다:
+makeExample('template-syntax/ts/app/app.component.html', 'event-binding-3')(format=".")

.l-sub-section
  :marked
    `myClick` 디렉티브는 [Aliasing input/output properties](#aliasing-io)의 섹션 아래 쪽에서 더 설명해두었습니다.

:marked
  해당 이름이 요소의 이벤트 혹은 알려진 디렉티브의 출력 프로퍼티와 일치하지 않는다면,
  Angular는 "알 수 없는 디렉티브" 오류를 보고합니다.

  ### *$event* 그리고 이벤트 핸들링 구문
  이벤트 바인딩에서, Angular는 대상 이벤트를 위한 이벤트 핸들러를 설치합니다.

  이벤트가 일어나면, 핸들러가 템플릿 구문을 실행하게 되죠.
  템플릿 구문은 일반적으로 이벤트에 대한 응답으로 무언가 하고자 하는 수신자를 관여시키기 되는데,
  예를 들자면 HTML 컨트롤로부터 값을 가져와 그것을 모델에 저장하는 식이죠.

  바인딩은 **`$event`라는 이름의 이벤트 객체**를 통해 데이터 값들을 포함하고 있는 이벤트에 관한 정보를 실어보냅니다.

  이벤트 객체의 모양은 대상 이벤트 자체에 의해 결정됩니다.
  대상 이벤트가 네이티브 DOM 요소 이벤트라면, `$event`는 `target` 그리고 `target.value`와 같은 프로퍼티를 갖는
  [DOM 이벤트 객체]( https://developer.mozilla.org/en-US/docs/Web/Events)가 됩니다.

  다음 예제를 보시죠:
+makeExample('template-syntax/ts/app/app.component.html', 'without-NgModel')(format=".")
:marked
  입력 박스에서 `value`를 `firstName` 프로퍼티에 바인딩하고 있고, 입력 박스의 `input` 이벤트에 대한 바인딩에 의한 변경 사항을 리스닝하고 있습니다. 
  사용자가 변경을 일으키면, `input` 이벤트가 발생하고 바인딩은 DOM 이벤트 객체, `$event`를 포함하는 컨텍스트 내에서 구문을 실행합니다.

  `firstName` 프로퍼티를 갱신하려면, 다음의 경로 `$event.target.value`에 의해 변경된 텍스트를 가져와야 합니다.
  
  이벤트가 디렉티브(컴포넌트는 디렉티브라는 것을 기억하세요)에 속한다면 `$event`는 디렉티브가 선택한 모양으로 만들어집니다.
  If the event belongs to a directive (remember: components are directives), `$event` has whatever shape the directive chose to produce.

  <a id="eventemitter"></a>
  <a id="custom-event"></a>
  ### EventEmitter를 이용한 커스텀 이벤트

  디렉티브는 대체적으로 Angular의 [EventEmitter](../api/core/EventEmitter-class.html)으로 커스텀 이벤트를 일으킵니다.
  디렉티브는 `EventEmitter`을 생성하고 그것을 프로퍼티로써 드러냅니다.
  디렉티브는 이벤트를 일으키기 위해 `EventEmitter.emit(payload)`을 호출하는데, 어떤 것이든지 될 수 있는 메시지 페이로드를 전달합니다.
  상위 디렉티브는 이 프로퍼티를 바인당하고 `$event` 객체를 통해 페이로드에 접근하여 이벤트를 리스닝합니다.

  영웅의 정보를 보여주고 사용자 동작에 반응하는 `HeroDetailComponent`를 생각해보세요. 
  `HeroDetailComponent`가 삭제 버튼이 가지고 있다 할지라도 영웅 자체를 삭제하는 방법은 모릅니다.
  할 수 있는 최고의 방법은 사용자의 삭제 요청을 알려주는 이벤트를 일으키는 겁니다.

  다음은 `HeroDetailComponent`에서 적절한 부분을 발췌한 것입니다:
+makeExample('template-syntax/ts/app/hero-detail.component.ts',
'template-1', 'HeroDetailComponent.ts (template)')(format=".")
+makeExample('template-syntax/ts/app/hero-detail.component.ts',
'deleteRequest', 'HeroDetailComponent.ts (delete logic)')(format=".")

:marked
  컴포넌트는 `EventEmitter`를 반환하는 `deleteRequest` 프로퍼티를 정의합니다.
  사용자가 *delete*를 클릭하면, 컴포넌트는 `EventEmitter`에게 `Hero` 객체를 보내라고 알려주는 `delete()` 메서드를 실행합니다.

  이제 `HeroDetailComponent`의 `deleteRequest` 이벤트를 바인딩하는 상위 컴포넌트를 상상해보세요.

+makeExample('template-syntax/ts/app/app.component.html',
'event-binding-to-component')(format=".")
:marked
  `deleteRequest` 이벤트가 일어나면, Angular는, `$event` 변수 안에 *지우려고 하는 영웅*(`HeroDetail`에 의해 전달된)을 전달하는,
  상위 컴포넌트의 `deleteHero` 메서드를 호출합니다.

  ### 템플릿 구문은 부수 효과를 가지고 있습니다
  `deleteHero` 메서드는 부수 효과를 가지고 있습니다: 영웅을 삭제한다는 것이죠.
  템플릿 구문의 부수 효과는 그저 괜찮은 것은 아니지만, 모두 예측된 것입니다.

  영웅을 삭제하는 것은, 아마도 쿼리를 포함하는 다른 변경사항들을 촉발시키는, 모델을 갱신하고 원격 서버에 저장합니다.
  이 변경 사항들은 시스템을 통해 걸러지며 시스템과 다른 뷰 안에서 결국에는 디스플레이됩니다.
  모든 것이 괜찮습니다.

//
  :marked
    ### Event bubbling and propagation [TODO: reinstate this section when it becomes true]
    Angular invokes the event-handling statement if the event is raised by the current element or one of its child elements.
  +makeExample('template-syntax/ts/app/app.component.html', 'event-binding-bubbling')(format=".")
  :marked
    Many DOM events, both [native](https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Overview_of_Events_and_Handlers ) and [custom](https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events ), bubble up their ancestor tree of DOM elements until an event handler along the way prevents further propagation.

  .l-sub-section
    :marked
      `EventEmitter` events don’t bubble.

  :marked
    The result of an event binding statement determines whether
    [event propagation](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Examples#Example_5:_Event_Propagation)
    continues or stops with the current element.

    Event propagation stops if the binding statement returns a falsey value (as does a method with no return value).
    Clicking the button in the next example triggers a save;
    the click doesn't make it to the outer `<div>` so the div's save handler is not called.
  +makeExample('template-syntax/ts/app/app.component.html', 'event-binding-no-propagation')(format=".")
  :marked
    Propagation continues if the statement returns a truthy value. In the next example, the click is heard by both the button
    and the outer `<div>`, causing a double save.
  +makeExample('template-syntax/ts/app/app.component.html', 'event-binding-propagation')(format=".")


.l-main-section
:marked
  <a id="ngModel"></a>
  ## NgModel을 이용한 양방향 바인딩
  데이터 엔트리 폼을 개발하는 경우라면, 사용자가 변경을 준 경우 데이터 프로퍼티 디스플레이와 프로퍼티 갱신 모두 원할 겁니다. 

  `[(ngModel)]` 양방향 바인딩 문법은 그런 일을 쉽게 해줍니다. 다음 예제를 보시죠:
+makeExample('template-syntax/ts/app/app.component.html', 'NgModel-1')(format=".")
.callout.is-important
  header [()] = 상자 안 바나나
  :marked
    소괄호가 대괄호 안에 들어간다는 것을 기억하려면, *상자 안 바나나*를 상상하세요.
:marked
  대안으로, 정규 접두사 방식을 사용할 수도 있습니다:
+makeExample('template-syntax/ts/app/app.component.html', 'NgModel-2')(format=".")
:marked
  이런 형태를 만들게 된 이유에는, 앞서 배웠던 프로퍼티와 이벤트 바인딩의 기술과 관련이 있습니다.

  ### [(ngModel)] 내부
  `<input>` 요소의 `value` 프로퍼티와 `input` 이벤트에 대한 개별 바인딩으로 동일한 결과를 달성할 수 있었습니다.
+makeExample('template-syntax/ts/app/app.component.html', 'without-NgModel')(format=".")
:marked
  여기에는 약간 성가신 부분이 있습니다. 어떤 요소 프로퍼티를 설정해야 하고 어떤 이벤트가 사용자 변경을 보고할지를 누가 기억할 수 있을까요?
  입력 박스로부터 현재 디스플레이되고 있는 텍스트를 어떻게 추출하고 데이터 프로퍼티를 갱신할 수 있을까요?
  누가 그걸 매번 들여다 보길 원할까요? 

  `ngModel` 디렉티브는 짐이 되는 세세한 내용들을 자신의 `ngModel` 입력과 `ngModelChange` 출력 프로퍼티 뒤로 숨깁니다.
+makeExample('template-syntax/ts/app/app.component.html', 'NgModel-3')(format=".")
.l-sub-section
  :marked
    `ngModel` 입력 프로퍼티는 요소의 값 프로퍼티를 설정하고 `ngModelChange` 출력 프로퍼티는 요소 값의 변화를 리스닝합니다.
    세세한 내용은 요소 각각의 종류마다 특화되어 있고 그래서 `NgModel` 디렉티브는 입력 텍스트 박스와 같은 요소들에서만 동작하며,
    이는 [ControlValueAccessor](../api/common/ControlValueAccessor-interface.html)에 의해 지원됩니다.
    딱 들어맞는 *value accessor*(이 챕터의 범주를 넘어서는 기술입니다)를 작성하기 전까지는, 커스텀 컴포넌트에 `[(ngModel)]`을 적용할 수 없습니다.

:marked
  분리된 `ngModel` 바인딩은 개선 사항입니다. 좀 더 좋게 만들 수 있을 겁니다.

  데이터 프로퍼티에 대해 두 번 언급해서는 안됩니다.
  Angular는 컴포넌트의 데이터 프로퍼티를 포착하고 단일 선언 &mdash; `[( )]` 문법이 될 수 있는 &mdash; 으로 그것을 설정할 수 있게 되어야 합니다:
+makeExample('template-syntax/ts/app/app.component.html', 'NgModel-1')(format=".")

.l-sub-section
  :marked
    `[(ngModel)]`은 Angular가 `[(x)]` 문법에서 프로퍼티 바인딩에 대한 `x` 입력 프로러티와 이벤트 바인딩에 대한 `xChange` 출력 프로퍼티를 분석하는 것과 같은
    좀 더 일반적인 패턴의 특정 예입니다. Angular는 템플릿 표현식의 리터럴 문자열에 `=$event`를 덧붙여 이벤트 프로퍼티 바인딩의 템플릿 구문을 만들어냅니다.

    > <span style="font-family:courier">[(_x_)]="_e_" &lt;==> [_x_]="_e_" (<i>x</i>Change)="_e_=$event"</span>

    이런 동작을 활용하여 우리 자신의 양방향 바인딩 디렉티브를 작성할 수 있습니다.

:marked
  `[(ngModel)]`이 우리가 필요로 하는 전부일까요? 그것의 확장 형식을 대체할 어떤 이유라도 있을까요?

  `[( )]` 문법은 오로지 데이터가 바인딩된 프로퍼티만 _설정_할 수 있습니다.
  좀 더 복잡한, 또는 어떤 다른 일을 하게 하려면, 스스로 확장된 형식을 작성할 필요가 있습니다. 

  입력된 값을 대문자로 강제 변경하는 것과 같은 멍청한 짓을 해보죠:
+makeExample('template-syntax/ts/app/app.component.html', 'NgModel-4')(format=".")
:marked
  대문자로 변경하는 버전을 포함한, 모든 버전들은 다음과 같이 동작합니다:
figure.image-display
    img(src='/resources/images/devguide/template-syntax/ng-model-anim.gif' alt="NgModel variations")

.l-main-section
:marked
  <a id="directives"></a>
  ## 빌트인 디렉티브

  Angular의 초창기 버전은 7개가 넘는 빌트인 디렉티브를 포함하고 있었습니다.
  커뮤니티에서는 더 많은 것들이 만들어졌고, 셀 수 없이 많은 사적인 디렉티브들이 내부 애플리케이션을 위해 만들어져 왔습니다. 

  Angular2에서는 그렇게 많은 디렉티브들을 필요로 하지 않습니다.
  좀 더 유능하고 표현력이 있는 Angular 2의 바인딩 시스템으로 훨씬 자주 동일한 결과를 달성할 수 있습니다.
  왜 이와 같이 단순한 바인딩을 작성할 때 클릭을 다루기 위한 디렉티브를 만들어야 하는 걸까요?
+makeExample('template-syntax/ts/app/app.component.html', 'event-binding-1')(format=".")
:marked
  우리는 여전히 복잡한 업무를 단순화시켜주는 디렉티브로부터 이득을 얻고 있습니다.
  Angular는 여전히 빌트인 디렉티브들을 제공하고 있죠; 그렇게 많이는 아닙니다.
  우리는 그렇게 많이는 아니지만 자체 디렉티브도 작성하게 되겠죠.

  이 세그먼트에서는 굉장히 자주 사용되는 빌트인 디렉티브를 살펴보도록 하겠습니다.

<a id="ngClass"></a>
.l-main-section
:marked
  ### NgClass

  우리는 대체로 동적으로 CSS 클래스를 추가하고 제거하므로써 요소를 보여줄 방법을 제어합니다.
  우리는 몇 가지 클래스를 동시에 추가하거나 제거하기 위해 `NgClass`에 바인딩할 수 있습니다.

  [클래스 바인딩](#class-binding)은 *단일* 클래스를 추가하거나 제거하기에 좋은 방법입니다.
+makeExample('template-syntax/ts/app/app.component.html', 'class-binding-3a')(format=".")
:marked
  `NgClass` 디렉티브는 동시에 *많은* CSS 클래스들을 추가하거나 제거하려고 할 때 더 나은 선택이 될 수도 있습니다.

  `NgClass`를 적용하는 좋은 방법은 그것을 키(value control !{__objectAsMap})에 바인딩하는 것입니다.
  객체의 각각의 키가 CSS 클래스 이름이 됩니다; 클래스가 추가되어야 한다면 그것의 값이 `true`가 되어야 하고, 제거되어야 한다면 `false`가 되어야 합니다.

:marked
  세 가지 CSS 클래스의 상태를 관리하는 `setClasses` 메서드와 같은 컴포넌트를 생각해보세요:
+makeExample('template-syntax/ts/app/app.component.ts', 'setClasses')(format=".")
:marked
  이제 `setClasses`를 호출하고 요소의 클래스들을 적절히 설정하는 `NgClass` 프로퍼티 바인딩을 추가할 수 있습니다:
+makeExample('template-syntax/ts/app/app.component.html', 'NgClass-1')(format=".")

<a id="ngStyle"></a>
.l-main-section
:marked
  ### NgStyle
  컴포넌트 상태에 따라, 동적으로 인라인 스타일을 설정할 수 있습니다.
  `NgStyle`에 바인딩하는 것은 동시에 많은 인라인 스타일을 설정하도록 해줍니다.

  [스타일 바인딩](#style-binding)은 *단일* 스타일 값을 설정하기에 쉬운 방법입니다.
+makeExample('template-syntax/ts/app/app.component.html', 'NgStyle-1')(format=".")
:marked
  `NgStyle` 디렉티브는 동시에 *많은* 인라인 스타일을 설정하고 할 때 더 나은 선택이 될 수 있습니다.

  그것을 키(value control !{__objectAsMap})에 바인딩하여 `NgStyle`을 적용합니다.
  객체의 각각의 키는 스타일 이름이 됩니다; 그것의 값은 해당 스타일에 적합한 것이면 무엇이든지 될 수 있습니다.

  세 가지 스타일을 정의하는 객체를 반화하는 `setStyles`과 같은 컴포넌트 메서드를 생각해보세요:
+makeExample('template-syntax/ts/app/app.component.ts', 'setStyles')(format=".")
:marked
  이제 `setStyles`를 호출하고 요소의 스타일을 적당하게 설정하는 `NgStyle` 프로퍼티 바인딩을 추가하기만 하면 됩니다:
+makeExample('template-syntax/ts/app/app.component.html', 'NgStyle-2')(format=".")

<a id="ngIf"></a>
.l-main-section
:marked
  ### NgIf
  `NgIf` 디렉티브에 #{_truthy} 표현식을 바인딩하여 요소의 하위 트리(요소와 그것의 하위 요소들)를 DOM에 추가할 수 있습니다.
+makeExample('template-syntax/ts/app/app.component.html', 'NgIf-1')(format=".")

.alert.is-critical
  :marked
    `ngIf` 앞에 아스테리스크(`*`)을 잊지 마세요.
    자세한 내용은 [\*와 &lt;template>](#star-template)을 읽어보세요.
:marked
  #{_falsey} 표현식을 바인딩하면 DOM에서 요소의 하위 트리가 제거됩니다.
+makeExample('template-syntax/ts/app/app.component.html', 'NgIf-2')(format=".")

block dart-no-truthy-falsey
  //- N/A

:marked
  #### Visibility와 NgIf은 동일하지 않습니다.
  우리는 [클래스](#class-binding) or [스타일](#style-binding) 바인딩으로 요소의 하위 트리(요소와 그것의 하위 요소들)를 보여주거나 감출 수 있습니다:
+makeExample('template-syntax/ts/app/app.component.html', 'NgIf-3')(format=".")
:marked
  하위 트리를 감추는 것은 `NgIf`로 하위 트리를 제외시키는 것과는 상당히 다릅니다.

  요소의 하위 트리를 숨기게 되면, 그것은 DOM 내부에 남아 있습니다.
  하위 트리 내 컴포넌트는 그들의 상태와 함께 보존됩니다.
  Angular는 보이지 않는 프로퍼티들 조차, 변경 사항에 대해 계속 검사될 것입니다.
  하위 트리는 실제 메모리와 연산 자원에 묶여 있게 됩니다.

  `NgIf`가 `false`가 되면, Angular는 요소의 하위 트리를 DOM으로부터 물리적으로 제거합니다.
  그것은 하위 트리 내에서 컴포넌트와 컴포넌트 상태까지 제거시키고, 어쩌면 실제 자원에서 해제되고 사용자에게 있어 더 나은 성능을 가져올 것입니다.

  보임/숨김 기술은 작은 요소 트리에 대해서는 아마도 괜찮은 방법일 겁니다.
  큰 트리를 숨기는 경우에는 이를 염려해야 할 겁니다; 그런 경우 `NgIf`가 더 안전한 선택이 될 것입니다. 항상 결론에 도달하기 전에 측정하시기 바랍니다.

<a id="ngSwitch"></a>
.l-main-section
:marked
  ### NgSwitch
  어떤 조건에 따라, 후보 요소 트리 집합 중 *하나의* 요소 트리(하나의 요소와 하위 요소들)를 디스플레이하고 싶은 경우에는 `NgSwitch`를 바인딩합니다.
  Angular는 DOM 내로 *선택된* 요소 트리만 넣습니다.

  다음은 예제입니다:
+makeExample('template-syntax/ts/app/app.component.html', 'NgSwitch')(format=".")
:marked
  *스위칭된 값*을 반환하는 표현식을 상위 `NgSwitch` 디렉티브에 바인딩합니다.
  이 예제에서 값은 문자열이지만, 어떤 타입의 값이든 될 수 있습니다. 

  이 예제에서, 상위 `NgSwitch` 디렉티브는 하위 `<span>` 요소들의 집합을 제어합니다.
  `<span>`은 *일치하는 값* 표현식으로 고정되던가 기본적으로 마크되던가 둘 중 하나입니다.

  ** 어떤 특정 순간이든지 간에, *span*들 중 하나는 DOM 내에 존재하게 됩니다.**

  *span*의 *일치 값*이 스위칭된 값과 동일하다면, Angular는 DOM에 `<span>`을 추가합니다.
  *span* 들 중 일치하는 게 없다면, Anuglar는 DOM에 기본 *span*을 추가합니다.
  Angular는 다른 모든 *span*들을 제거하여 소멸시킵니다.
.l-sub-section
  :marked
    이 예제에서 *span*을 다른 어떤 요소로든 교체할 수 있습니다.
    해당 요소는 엄청 많은 하위 트리를 가진 `<div>`가 될 수도 있습니다.
    오로지 일치한 `<div>`와 그 요소의 하위 트리만이 DOM 내에 나타나겠지요;
    다른 것들은 모두 제거될 겁니다.
:marked
  다음 세 개의 협력 디렉티브가 함께 동작하게 됩니다: 
  1. `ngSwitch`: 스위칭 값을 반환하는 표현식을 바인딩합니다
  1. `ngSwitchWhen`: 일치 값을 반환하게 되는 표현식에 바인딩됩니다
  1. `ngSwitchDefault`: 기본 요소에 대한 마커 어트리뷰트입니다

.alert.is-critical
  :marked
    `ngSwitch` 앞에 아스테리스크(`*`)를 **붙이지 *마세요***. 대신 프로퍼티 바인딩을 사용하시기 바랍니다.

    `ngSwitchWhen`과 `ngSwitchDefault` 앞에는 아스테리스크(`*`)를 **붙이시기** 바랍니다.
    좀 더 자세힌 내용은 [\* 과 &lt;template>](#star-template)을 참고하시기 바랍니다.

<a id="ngFor"></a>
.l-main-section
:marked
  ### NgFor
  `NgFor`는 _반복자_ 디렉티브(데이터 디스플레이를 커스터마이징하기 위한 방법)입니다.

  여기서 목표는 아이템 목록을 표현하는 것입니다. 단일 아이템이 어떻게 디스플레이될지를 정의할 HTML 블록을 정의해야 합니다. 
  목록 내 개별 아이템들을 렌더링하기 위한 템플릿으로 해당 블록을 사용할 거라고 Angular에게 알려줘야 합니다.

  다음은 간단한 `<div>`에 적용한 `NgFor` 예제입니다:
+makeExample('template-syntax/ts/app/app.component.html', 'NgFor-1')(format=".")
:marked
  다음 예제처럼 `NgFor`는 컴포넌트 요소에도 적용할 수 있습니다:
+makeExample('template-syntax/ts/app/app.component.html', 'NgFor-2')(format=".")

.alert.is-critical
  :marked
    `ngFor` 앞에 아스테리스크(`*`)를 잊지 마시기 바랍니다.
    좀 더 자세한 내용은 [\* 과 &lt;template>](#star-template)를 참고하시기 바랍니다.
:marked
  `*ngFor`에 할당된 텍스트는 반복자 프로세스를 가이드해주는 지시사항입니다.

<a id="ngForMicrosyntax"></a>
:marked
  #### NgFor 마이크로 문법
  `*ngFor`에 할당된 문자열은 [템플릿 표현식](#template-expressions)이 아닙니다.
  그건 *마이크로 문법*입니다 &mdash; 그 자체로 Angular 인터프리트의 작은 언어입니다. 예를 들어, `"let hero of heroes"` 문자열이 의미하는 바는 다음과 같습니다:

  > *`heroes` #{_array}에서 각각의 영웅를 가져와, 로컬 `hero` 변수에 담아 각각의 반복 때마다 템플릿화된 HTML에서 이용 가능하도록 만들어.*

  Angular는 이 지시사항을 요소들의 새로운 집합과 바인딩 내로 변환하여 전달합니다.

  이전 두 개의 예제에서, `ngFor` 디렉티브는 상위 컴포넌트의 `heroes` 프로퍼티에 의해 반환된 `heroes` #{_array}를 선회하여,
  In the two previous examples, the `ngFor` directive iterates over the `heroes` #{_array} returned by the parent component’s `heroes` property,
  각각의 배열 요소들이 적용된 요소의 인스턴스를 찍어냅니다.
  Angular는 배열 내 각각의 영웅들에 대한 템플릿의 인스턴스를 만들어 내는 것이죠.

  `hero` 앞에 `let` 키워드는 `hero`라고 불리는 템플릿 입력 변수를 만들어 냅니다.

.alert.is-critical
  :marked
     템플릿 입력 변수는 [템플릿 참조 변수](#ref-vars)와는 **다릅니다**!

:marked
  어구 삽입 시에, 이 영웅 프로퍼티에 접근하기 위해 템플릿 내에서 이 변수를 사용하게 됩니다.
  `hero-detail`에서는, 컴포넌트 요소 바인딩 안으로 이 변수를 전달할 수도 있습니다.

:marked
  #### 인덱스를 이용하는 NgFor
  `ngFor` 디렉티브는 각 반복에 대해 0부터 배열의 길이까지 증가되는 `index`라는 부가 정보를 지원합니다.
  템플릿 입력 변수 내에서 이 인덱스를 가로채 템플릿 내에서 사용할 수 있습니다.

  다음은 `i`라는 이름의 변수로 인덱스를 가로채 "1 - Hercules Son of Zeus"처럼 각 줄마다 찍어내는 예제입니다.
+makeExample('template-syntax/ts/app/app.component.html', 'NgFor-3')(format=".")
.l-sub-section
  :marked
    [NgFor API 레퍼런스](../api/common/NgFor-directive.html)에서 `last`, `event` 그리고 `odd`와 같은 특별한 *인덱스 친화* 변수에 관해 알아보시기 바랍니다.

:marked
  #### NgForTrackBy
  `ngFor` 디렉티브는 좋지 않게도 아주 큰 리스트를 실행하게 될 가능성이 있습니다.
  한 아이템에 대해, 아이템이 제거된다거나 혹은 아이템이 추가된다든지 하는 작은 변화가 DOM을 쭉 펼쳐지게 만드는 행위를 유발시킬 수 있습니다. 

  예를 들어, 서버에 다시 질의함으로써 영웅의 목록을 새롭게 가져올 수 있습니다.
  새로 가져온 목록은 아마도, 전체가 다 그렇지 않을 수도 있지만, 예전에 디스플레이했던 영웅들 대부분을 포함하고 있을 겁니다.

  *우리는* 각각의 영웅의 아이디가 변하지 않을 것이기에 그렇다는 것을 알 수 있습니다.
  그러나 Angular는 새로 가져온 리스트에서 새로운 객체 참조만을 사용합니다.
  다른 방법은 없고 예전의 목록을 없애고, 그 DOM 요소들을 폐기한 뒤, 새로운 DOM 요소로 새로운 목록을 다시 만들게 됩니다.

  우리가 알고 있는 것(동일한 `hero.id`를 가진 두 개의 객체가 동일한 *영웅*이라는 것)을 알려줄 수 있는 *트래킹* 함수를 작성하면 Angular는 이러한 큰 변화를 피할 수 있습니다.
  다음은 앞에 말한 함수의 예입니다:
+makeExample('template-syntax/ts/app/app.component.ts', 'trackByHeroes')(format=".")
:marked
  이제 *트래킹* 함수에 `NgForTrackBy` 디렉티브를 설정해야 합니다.
  Angular는 등가의 문법적 선택지를 제공합니다:
+makeExample('template-syntax/ts/app/app.component.html', 'NgForTrackBy-2')(format=".")
:marked
  *트래킹* 함수는 모든 DOM 변경 사항을 제거하지 않습니다. 
  Angular는 동일한 영웅의 *프로퍼티*가 변경된 경우 DOM 요소를 갱신하도록 되어 있습니다.
  그러나 프로퍼티 변경되지 않았다면 &mdash; 그리고 거의 변할 일이 없다면 &mdash; Angular는 해당 DOM 요소들을 건너뛸 수 있습니다.
  목록 UI는 좀 더 부드러워지고 좀 더 반응적으로 변할 겁니다.

  다음은 `NgForTrackBy` 효과의 예입니다.
figure.image-display
  img(src='/resources/images/devguide/template-syntax/ng-for-track-by-anim.gif' alt="NgForTrackBy")

<a id="star-template"></a>
<a id="structural-directive"></a>
.l-main-section
:marked
  ## * and &lt;template&gt;
  `NgFor`, `NgIf` 그리고 `NgSwitch` 빌트인 디렉티브를 살펴봤을 때, 괴상한 문법들을 호출했었습니다: 디렉티브 이름 앞에 나타난 아스테리스크(`*`) 말이죠.

  이 `*`은 템플릿의 도움으로 HTML 레이아웃을 수정하는 디렉티브를 읽고 쓰기 쉽도록 만들어주는 약간의 문법적 마약입니다. 
  `NgFor`, `NgIf` 그리고 `NgSwitch` 모두 `<template>` 태그로 둘러쌓인 요소의 하위 트리를 추가하고 제거합니다.

  우리는 `<template>`를 보지 못했고 앞으로도 그럴텐데 그 이유는 `*` 접두사 문법이 그 태그를 우리가 다루지 않도록 해줘서
  포함하고 제거하고 반복하는 HTML 요소에만 집중할 수 있도록 해주기 때문입니다.

  이 섹션에서 Angualr가 `*`을 어떻게 벗겨내고 우리 대신에 `<template>` 태그 내로 HTML을 확장시키는지에 대해서 알아보기 위해 좀 더 자세히 들여다보겠습니다.

:marked
  ### `*ngIf` 확장
  Angular가 우리를 대신해 하는 것들을 우리가 할 수 있고 `*` 접두사 문법을 템플릿 문법으로 확장할 수 있습니다. 다음은 `*ngIf`을 이용한 코드입니다:
+makeExample('template-syntax/ts/app/app.component.html', 'Template-1')(format=".")
:marked
  `currentHero`은 두번 참조되는데, 처음에는 `NgIf`의 참/거짓 조건으로, 그 다음에는 `HeroDetailComponent` 내로 전달되는 실제 영웅 정보로 참조됩니다.

  첫번째 확장 단계는 `ngIf`(`*` 접두사 없이)를 전송하고 표현식 내부 내용을 `template` 디렉티브로 할당합니다.
+makeExample('template-syntax/ts/app/app.component.html', 'Template-2a')(format=".")
:marked
  다음(이자 마지막) 단계는 `<template>`과 `[ngIf]` [프로퍼티 바인딩](#property-binding) 내로 HTML을 펼쳐 놓습니다:
+makeExample('template-syntax/ts/app/app.component.html', 'Template-2')(format=".")
:marked
  `[hero]="currentHero"` 바인딩이 템플릿 내부의 하위 `<hero-detail>` 요소 상에 유지된다는 것을 기억하시기 바랍니다.

block remember-the-brackets
  .callout.is-critical
    header 대괄호를 잊지 마세요!
    :marked
      `ngIf="currentHero"`라고 작성하는 실수를 범하지 마세요!
      그렇게 작성하면 `ngIf`에 `"currentHero"`라는 *문자열* 값을 할당합니다.
      자바스크립트에서 비어있지 않은 문자열은 true와 같은 값이므로, `ngIf`은 항상 `참`이 되고 Angular는 항상 `hero-detail`을 디스플레이하게 되겠지요...
      `currentHero`가 없을 때 조차도요!

:marked
  ### `*ngSwitch` 확장
  유사한 변형이 `*ngSwitch`에 적용됩니다. We can de-sugar the syntax ourselves.
  다음 예제에서, 먼저 `*ngSwitchWhen`과 `*ngSwitchDefault`을 활용한 예제를 보고 다시 `<template>` 태그를 적용한 예제를 보겠습니다:
+makeExample('template-syntax/ts/app/app.component.html', 'NgSwitch-expanded')(format=".")
:marked
  `*ngSwitchWhen`과 `*ngSwitchDefault`은 `*ngIf`와 정확히 동일한 기조로 확장되는데,
  이전 요소들을 `<template>` 태그 내로 감싸게 됩니다.

  이제 `ngSwitch` 자체가 왜 아스테리스크(*)를 접두사로 두지 않는지 알게 되었습니다.
  그것은 컨텐츠를 정의하지 않습니다. 그것의 역할은 템플릿의 컬렉션을 제어하는 것입니다.

  `ngSwitch`는 `NgSwitchWhen`와 `NgSwitchDefault` 디렉티브 두 집합을 제어하게 됩니다. 
  우리는, (*)로 접두사 처리된 버전 한번 그리고 확장된 템플릿 버전 한번 이렇게 총 두 번, 선택된 템플릿의 값이 디스플레이될 거라는 것을 예상할 수 있습니다. 
  그것이 정확히 이 다음 예제에서 보게 될 내용입니다:
figure.image-display
    img(src='/resources/images/devguide/template-syntax/ng-switch-anim.gif' alt="NgSwitch")
:marked
  ### `*ngFor` 확장
  `*ngFor`는 유사한 변형을 처리합니다. `*ngFor` 예제로 시작해보죠:
+makeExample('template-syntax/ts/app/app.component.html', 'Template-3a')(format=".")
:marked
  다음은 `ngFor`를 `template` 디렉티브로 변형한 뒤의 모습으로 동일한 내용입니다:
+makeExample('template-syntax/ts/app/app.component.html', 'Template-3')(format=".")
:marked
  그리고 원래의 `<hero-detail>` 요소를 둘러싸는 `<template>` 태그로 확장한 예제입니다:
+makeExample('template-syntax/ts/app/app.component.html', 'Template-4')(format=".")
:marked
  `NgFor` 코드는 `NgIf`보다 약간 더 복잡한데, 반복자가 설정해야 하는 가변부를 갖고 있기 때문입니다. 
  위 예제에서는, 어떤 리스트를 어떻게 이용해야 할 지 알려주는 `NgForOf` 디렉티브와 `NgForTrackBy` 디렉티브를 만들고 할당해야 한다는 것을 기억해야 합니다.
  `*ngFor` 문법 사용은 이렇게 확장된 HTML을 작성하는 것보다 훨씬 쉽습니다.

<a id="ref-vars"></a>
.l-main-section
:marked
  ## 템플릿 참조 변수

  **템플릿 참조 변수**는 템플릿 내의 DOM 요소 혹은 디렉티브에 대한 참조입니다.

  그것은 네이티브 DOM 요소와 함께 사용될 수도 있지만 Angular 2 컴포넌트와도 사용할 수 있습니다 &mdash; 사실, 어떤 커스텀 웹 컴포넌트와도 잘 동작할 겁니다.

:marked
  ### 템플릿 참조 변수 참조하기

  우리는 동일 요소, 형재 요소 혹은 다른 하위 요소 상에서도 템플릿 참조 변수를 참조할 수 있습니다.

  다음은 템플릿 참조 변수를 만들고 사용하는 두 개의 서로 다른 예제입니다:
+makeExample('template-syntax/ts/app/app.component.html', 'ref-phone')(format=".")
:marked
  "phone" 앞의 해쉬(`#`)는 `phone` 변수를 정의하고 있다는 것을 의미합니다.
.l-sub-section
  :marked
    `#` 캐릭터를 사용하고 싶지 않은 분들은 정규 대안인 `ref-` 접두사를 대신 사용할 수 있습니다.
    예를 들어, `phone` 변수는 `#phone` 혹은 `ref-phone` 둘 중 하나를 사용하여 선언할 수 있습니다.

:marked
  ### 변수의 값을 가져오는 방법

  Angular는 그것이 정의된 요소에 변수의 값을 설정합니다.
  우리는 변수를 `input` 요소에 정의했었습니다.
  이 `input` 요소 객체를 버튼 요소에 전달하는데, 이 변수들은 이벤트 바인딩 내에서 `call` 메서드의 인자로 사용되고 있습니다.

:marked
  ### NgForm과 템플릿 참조 변수
  마지막 예제를 보시죠: 폼이라고 하는 템플릿 참조 변수의 전형에 대해서 말이죠. 

  폼에 대한 HTML은 [폼](forms.html)에서 보았던 것처럼 상당히 연관될 수 있습니다.
  다음은 *간소화된* 예제입니다 &mdash; 전혀 간단하지는 않습니다.
+makeExample('template-syntax/ts/app/app.component.html', 'ref-form')(format=".")
:marked
  템플릿 참조 변수인 `theForm`은 예제 상에서 HTML의 여러 곳에서 각각 세 번 나옵니다.
+makeExample('template-syntax/ts/app/app.component.html', 'ref-form-a')(format=".")
:marked
  `theForm`의 값은 무엇일까요?

  Angular가 만약 그것을 받아들이지 않았다면,
  그것은 [HTMLFormElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement)이 됐을 겁니다.
  여기서 그것이라는 것은 실제로 `ngForm`으로, 네이티브 `HTMLFormElement`를 감싸고
  사용자 입력의 유효성을 살펴보는 능력과 같은 추가적인 강력한 힘을 부여하는 Angular 빌트인 `NgForm` 디렉티브에 대한 참조입니다. 

  위 예제에서는 `theForm.form.valid`을 확인하여 확인 버튼을 비활성시키는 방법과
  값진 정보를 담은 객체를 상위 컴포넌트의 `onSubmit` 메서드로 전달하는 방법을 설명하고 있습니다.

<a id="inputs-outputs"></a>
.l-main-section
:marked
  ## 입력 그리고 출력 프로퍼티
  지금까지, 우리는 주로 *바인딩 선언의 오른편*에 나타나는 템플릿 표현식과 구문 사이의 컴포넌트 멤버에 대한 바인딩에 대해 집중해왔습니다.
  해당 위치의 멤버를 데이터 바인딩 **소스**라고 합니다.

  이 섹션에서는 *바인딩 선언 왼편*에 있는 디렉티브 프로퍼티인 **대상**에 대한 바인딩에 집중해보도록 하겠습니다. 
  이 디렉티브 프로퍼티들은 반드시 **입력** 혹은 **출력**으로써 선언되어야 합니다.

.alert.is-important
  :marked
    기억하세요: 모든 **컴포넌트*들은 **디렉티브**입니다.
:marked
.l-sub-section
  :marked
    우리는 지금 데이터 바인딩 **대상**과 데이터 바인딩 **소스** 간의 아주 세밀한 차이점을 알아보려고 합니다.

    바인딩의 *대상*은 `=`의 *왼편*에 있습니다.
    **소스**는 `=`의 *오른편*에 있죠.

    바인딩의 *대상*은 바인딩 구두법(`[]`, `()` 혹은 `[()]`) 안의 프로퍼티 혹은 이벤트입니다.
    *소스*는 따옴표(`" "`) 안의 것 혹은 어구 삽입(`{{}}`) 안의 것, 둘 중 하나입니다.

    **소스** 디렉티브의 모든 멤버는 바인딩에 대해 그냥 이용할 수 있습니다.
    템플릿 표현식이나 구문 내에서 디렉티브 멤버에 접근하기 위해 특별히 해야 할 것은 없습니다. 

    우리는 **대상** 디렉티브의 멤버에 대한 접근을 *제한*하고 있습니다.
    *입력*과 *출력*으로써 명시적으로 선언된 프로퍼티에 대해서만 바인딩이 가능합니다.
:marked
  다음 예제에서, `iconUrl`과 `onSave`는 `=`의 오른편의 따옴표 문법 내부에서 참조되는, 컴포넌트의 멤버입니다.
+makeExample('template-syntax/ts/app/app.component.html', 'io-1')(format=".")
:marked
  그것들은 컴포넌트의 *입력도 아니고 출력도 아닙니다*. 그것들은 바인딩에 대한 데이터 소스입니다.

  이제 **바인딩의 대상**인 `HeroDetailComponent`를 보겠습니다.
+makeExample('template-syntax/ts/app/app.component.html', 'io-2')(format=".")
:marked
  `HeroDetailComponent.hero`과 `HeroDetailComponent.deleteRequest` 모두 바인딩 선언의 **왼편**에 있습니다.
  `HeroDetailComponent.hero`는 대괄호 안쪽에 있습니다; 프로퍼티 바인딩의 대상이죠.
  `HeroDetailComponent.deleteRequest`은 소괄호 안에 있습니다; 이벤트 바인딩의 대상입니다.

  ### 입출력 프로퍼티 선언하기
  대상 프로퍼티들은 명시적으로 입력 혹은 출력으로 표시되어야 합니다. 

  `HeroDetailComponent`를 훑어보니, 이 프로퍼티들은 입력과 출력 프로퍼티를 나타내는 데코레이터로 표시되어 있다는 것을 알 수 있습니다.
+makeExample('template-syntax/ts/app/hero-detail.component.ts', 'input-output-1')(format=".")

:marked
.l-sub-section
  :marked
    다음 예제에서처럼, 디렉티브 메타데이터의 `inputs`과 `outputs` #{_array} 내에 해당되는 멤버들은 선언할 수도 있습니다:
  +makeExample('template-syntax/ts/app/hero-detail.component.ts', 'input-output-2')(format=".")
  <br>
  :marked
    데코레이터 혹은 메타데이터 #{_array} 둘 중 하나에서 입력/출력 프로퍼티를 특정할 수 있습니다.
    두 곳에 동시에 하지는 마세요!
:marked
  ### 입력 혹은 출력?

  *입력* 프로퍼티들은 일반적으로 데이터 값을 받습니다.
  *출력* 프로퍼티들은 `EventEmitter` 객체와 같은 이벤트 프로듀서를 표출합니다.

  _입력_과 _출력_이라는 용어는 대상 디렉티브의 관점을 반영합니다.
figure.image-display
    img(src='/resources/images/devguide/template-syntax/input-output.png' alt="Inputs and outputs")
:marked
  `HeroDetailComponent.hero`는 `HeroDetailComponent`의 관점에서는 **입력** 프로퍼티인데,
  데이터가 템플릿 바인딩 표현식으로부터 해당 프로퍼티 *안으로* 들어오기 때문이죠.

  `HeroDetailComponent.deleteRequest`은 `HeroDetailComponent`의 관점에서는 **출력** 프로퍼티인데,
  이벤트가 템플릿 바인딩 구문 내에서 해당 프로퍼티 밖으로 그리고 핸들러를 향해 흐르기 때문입니다.

h3#aliasing-io 입력/출력 프로퍼티 별명 짓기
:marked
  때때로 입력/출력 프로퍼티의 내부적인 이름과는 다른 이름을 사용하고 싶을 수도 있습니다.
  [어트리뷰트 디렉티브](attribute-directives.html)에서는 자주 있는 일입니다.
  디렉티브 사용 측에서는 디렉티브의 이름에 대한 바인딩을 예상할 겁니다. 
  예를 들어, `<div>` 태그에 `myClick` 셀렉터를 가진 디렉티브를 적용한다고 하면, 
  동일하게 `myClick`라고 불리는 이벤트 프로퍼티가 바인딩될 거라고 예상할 수 있습니다.
+makeExample('template-syntax/ts/app/app.component.html', 'my-click')(format=".")
:marked
  하지만, 디렉티브 이름은 디렉티브 클래스 사이의 프로퍼티 이름으로써는 종종 좋지 않은 선택일 수 있습니다.
  디렉티브 이름은 프로퍼티가 무엇을 하는지 잘 설명해야 합니다.
  `myClick`라는 디렉티브 이름은 클릭 메시지를 내보내는 프로퍼티 입장에서는 좋은 이름은 아닙니다.

  운좋게도, 우리는 내부적인 이름과 다른, 관례적인 기대에 부합되는, 프로퍼티에 대한 공개 이름을 따로 둘 수가 있습니다.
  바로 위 예제에서, 디렉티브 자체의 `clicks` 프로퍼티에 대한 `myClick`이라는 *별칭*을 *통해* 실제 바인딩을 하고 있습니다.

  다음과 같이 입력/출력 데코레이터에게 프로퍼티 이름을 전달하여 별칭을 지정할 수 있습니다:

+makeExample('template-syntax/ts/app/my-click.directive.ts', 'my-click-output-1')(format=".")

.l-sub-section
  :marked
    `inputs`과 `outputs` #{_array} 안에서도 프로퍼티 이름의 별칭을 지정할 수 있습니다.
    *왼편*에는 디렉티브 프로퍼티 이름을, *오른편*에는 공개 별칭을 두고 그 사이에 콜론 구분자(`:`) 문자열을 넣으면 됩니다:
  +makeExample('template-syntax/ts/app/my-click.directive.ts', 'my-click-output-2')(format=".")

<a id="expression-operators"></a>
.l-main-section
:marked
  ## 템플릿 표현식 연산자
  템플릿 표현식 언어는 특정 시나리오를 위해 몇 가지 특별한 연산자를 제공받은 #{_JavaScript} 문법의 서브셋을 차용했습니다.
  우리는 이 세가지 연산자 중 두 가지를 알아볼 것입니다: _pipe_와 _safe navigation operator_을 말이죠.

:marked
  <a id="pipe"></a>
  ### 파이프 연산자( | )
  표현식 결과는 바인딩에 사용될 준비 이전에 몇 가지 변형을 필요로 할 수 있습니다.
  예를 들어, 환율을 숫자로, 텍스트를 대문자로, 혹은 리스트를 필터링하고 정렬하여 디스플레이하고 싶을 수 있습니다. 

  Angular의 [파이프](./pipes.html)는 이와 같은 작은 변형에 있어 좋은 선택이 될 수 있습니다.
  파이프는 입력 값을 받아들여 변형된 값을 반환하는 간단한 함수입니다.
  **파이프 연산자 (`|`)**를 이용하여 템플릿 표현식 내에 아주 쉽게 적용이 가능합니다:
+makeExample('template-syntax/ts/app/app.component.html', 'pipes-1')(format=".")
:marked
  파이프 연산자는 왼편에 있는 표현식의 결과를 우편에 있는 파이프 함수로 전달합니다.

  다중 파이프를 통해 표현식을 체이닝할 수 있습니다:
+makeExample('template-syntax/ts/app/app.component.html', 'pipes-2')(format=".")
:marked
  그리고 파이프에 [파라메터 적용](./pipes.html#parameterizing-a-pipe)을 할 수도 있습니다:
+makeExample('template-syntax/ts/app/app.component.html', 'pipes-3')(format=".")

block json-pipe
  :marked
    `json` 파이프는 바인딩 디버깅에 있어 특히나 도움이 됩니다:
  +makeExample('template-syntax/ts/app/app.component.html', 'pipes-json')(format=".")
  :marked
    생성된 출력은 다음처럼 보일 겁니다
  code-example(language="json").
    { "firstName": "Hercules", "lastName": "Son of Zeus",
      "birthdate": "1970-02-25T08:00:00.000Z",
      "url": "http://www.imdb.com/title/tt0065832/",
      "rate": 325, "id": 1 }

:marked
  <a id="safe-navigation-operator"></a>
  ### 안전한 네비게이션 연산자 ( ?. )와 null 프로퍼티 경로

  Angular의 **안전한 네비게이션 연산자 (`?.`)**는 프로퍼티 경로를 null 그리고 undefined 값으로부터 보호하기 위한 우아하고 편리한 방법입니다.
  다음에서, `currentHero`가 null인 경우 뷰 렌더링 실패로부터 보호하고 있습니다.
+makeExample('template-syntax/ts/app/app.component.html', 'safe-2')(format=".")

block dart-safe-nav-op
  //- N/A
  
:marked
  해당 문제 그리고 이런 특별한 해결책에 대해 좀 더 알아보도록 하죠.

  다음에서 데이터 바인딩된 `title` 프로퍼티가 만약 null인 경우 무슨 일이 발생할까요?
+makeExample('template-syntax/ts/app/app.component.html', 'safe-1')(format=".")
:marked
  뷰는 렌더링되겠지만 디스플레이되는 값은 빈 값일 겁니다; "The title is"만 보일 뿐 그 뒤에는 아무것도 나오지 않습니다.
  이건 충분히 설명이 되는 동작입니다. 적어도 앱은 충돌을 일으키지 않으니까요.

  템플릿 표현식이, 다음 예제에서처럼 값이 null인 영웅의 `firstName`을 디스플레이하고자 프로퍼티 경로를 두었다고 가정해보죠.

code-example(language="html").
  The null hero's name is {{nullHero.firstName}}

block null-deref-example
  :marked
    자바스크립트는 null 참조 오류를 던지고 Angular도 그럴 겁니다:
  code-example(format="nocode").
    TypeError: Cannot read property 'firstName' of null in [null].

:marked
  더 나빠졌네요, *전체 뷰가 사라졌습니다*.

  `hero` 프로퍼티가 결코 null이 되지 않을 거라고 믿었다면, 이것이 충분히 설명 가능한 동작이라고 주장할 수 있었을 겁니다.
  그게 결코 null이 될 수 없는데 여전히 null이라면,
  잡아서 해결해야 할 프로그래밍 오류를 만들고 있는 셈입니다.
  예외 던지기는 해야 할 올바른 일입니다.

  반면, 프로퍼티 경로 내의 null 값들은 이따금씩 괜찮을 수도 있습니다.
  특히 데이터가 결국에는 도착할 거라는 걸 알고 있는 경우에는 말이죠.

  데이터를 기다리는 동안, 뷰는 불평없이 렌더링을 해야 하고 null 프러퍼티 경로는 `title` 프로퍼티가 그랬던 것처럼 빈 칸으로 표시될 겁니다.

  불행히도 우리의 앱은 `currentHero`가 null인 경우 충돌을 일으킵니다.

  이 문제가 되는 부분에 [NgIf](#ngIf)을 코딩할 수 있을 겁니다.
+makeExample('template-syntax/ts/app/app.component.html', 'safe-4')(format=".")

block safe-op-alt
  :marked
    혹은 첫번째 표현식이 null을 만난 경우 표현식 전체를 그냥 지나쳐가도록 `&&`으로 프로퍼티 경로의 부분들을 체이닝해볼 수 있을 겁니다.
  +makeExample('template-syntax/ts/app/app.component.html', 'safe-5')(format=".")

:marked
  이러한 접근법들은 해볼만한 가치가 있지만, 특히 프로퍼티 경로가 긴 경우 꽤 나 성가신 일이 될 수 있습니다.
  `a.b.c.d`와 같이 긴 프로퍼티 경로 내 어딘가에서 null에 대비해본다고 생각해보세요. 

  Angular의 안전한 네비게이션 연산자(`?.`)은 프로퍼티 경로를 null로부터 보호하는데 좀 더 우아하고 편리한 방법입니다.
  첫번째 값이 null이라면 표현식 전체로부터 빠져나올 겁니다.
  디스플레이는 비어있지만, 앱은 오류없이 잘 동작할 겁니다.
+makeExample('template-syntax/ts/app/app.component.html', 'safe-6')(format=".")
:marked
  `a?.b?.c?.d`와 같은 긴 프로퍼티 경로들도 완벽하게 동작합니다.

.l-main-section
:marked
  ## 결론
  우리는 템플릿 문법을 이제 막 다 살펴보았습니다. 이제 자신의 컴포넌트와 디렉티브를 작성하여 좀 더 나은 일을 할 수 있는 지식을 알아볼 차례입니다.
