include ../_util-fns

:marked
  Angular 2 스타일 가이드에 오신 걸 환영합니다.

  ## 목적

  문법, 관례, 그리고 구조화된 Angular 애플리케이션을 위한 완고한 스타일을 가이드를 찾고 있다면, 잘 오셨습니다.

  이 스타일 가이드의 목적은 Angular 애플리케이션을 만듦에 있어 우리가 사용하고 있는 관례 그리고 더 중요한 것은 왜 우리가 그것들을 선택했는지를 보여줌으로써 가이드를 제공하기 위함입니다.
.l-main-section

:marked
  ## 스타일 어휘

  각각의 가이드라인은 좋은 사례와 나쁜 사례 모두를 설명하고, 모두 일관된 표현을 사용합니다.

  각 가이드라인의 어법은 아주 강한 권고를 나타냅니다.

.s-rule.do
  :marked
    **하세요**는 항상 따라야 하는 것을 말합니다.
    _Always_는 좀 강한 의미입니다.
    정확히 항상 따라야 한다는 가이드라인은 극히 드묾니다.
    반면에, *Do* 가이드라인을 깨는 실제로 예외적인 케이스를 필요로 할 겁니다.

.s-rule.consider
  :marked
    **고려하세요** 가이드라인은 대개 따라야 합니다.
    그 가이드라인 너머의 의미를 완전히 이해하고 그것을 어겨야 하는 합당한 이유가 있다면, 그래도 됩니다. 일관성을 지켜주시기 바랍니다.

.s-rule.avoid
  :marked
    **하지마세요**는 왠만하면 해서는 안되는 것을 가르킵니다. *피하기 위한* 코드 예제는 확실히 붉은 헤더를 가지고 있을 겁니다.
.l-main-section

:marked
  ## 파일 구조 관례

  몇 가지 코드 예제는 한 개 이상의 유사하게 이름지어진 파일들을 가진 파일을 보여줄 겁니다. (예, hero.component.ts and hero.component.html).
  
  가이드라인은 여러 가지 파일들을 나타내기 위해 `hero.component.ts|html|css|spec` 숏컷을 사용할 겁니다. 이런 숏컷 사용은 가이드의 파일 구조를 좀 더 읽기 쉽고 좀 더 간결하게 만들어 줄 겁니다.

.l-main-section
a(id='toc')

:marked
  ## 목차

    1. [단일 책임](#single-responsibility)
    1. [네이밍](#naming)
    1. [코딩 컨벤션](#coding-conventions)
    1. [애플리케이션 구조](#application-structure)
    1. [컴포넌트](#components)
    1. [디렉티브](#directives)
    1. [서버스](#services)
    1. [데이터 서비스](#data-services)
    1. [생명주기 후크](#lifecycle-hooks)
    1. [라우팅](#routing)
    1. [부록](#appendix)

.l-main-section
:marked
  ## 단일 책임

  Angular 2에서 생성하게 될 모든 컴포넌트, 서비스 그리고 다른 심볼들 모두 [단일 의존성 원칙](https:\/\/en.wikipedia.org/wiki/Single_responsibility_principle)이 적용됩니다.
  이것은 앱을 좀 더 깨끗하게 만들어주며, 읽거나 유지하기 쉽고 좀 더 테스트 가능하도록 만들어줍니다.

  ### 한 가지 규칙
  <a id="01-01"></a>
  #### 스타일 01-01
.s-rule.do
  :marked
    파일 하나 당 한 가지(예, 서비스 혹은 컴포넌트)를 정의**하세요**.

.s-rule.consider
  :marked
    파일 내 코드를 400 라인을 제한하는 것을 **고려하세요**.

.s-why
  :marked
    **왜냐구요?** 파일 당 하나의 컴포넌트는 읽거나 유지보수하거나 버전 컨트롤 내에서 팀과의 충돌을 피하는데 좀 더 도움을 줍니다.

.s-why
  :marked
    **왜냐구요?** 파일 당 하나의 컴포넌트는 컴포넌트가 혼재되어 있는 파일에서 종종 발생하는 숨겨진 버그를 피할 수 있게 해줍니다. 그런 파일 내에서는 변수가 공유된다든지, 원치 않은 클로저 혹은 원치 않은 의존성 커플링이 발생할 수 있습니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 단일 컴포넌트는 컴포넌트 라우터를 이용한 lazy 로딩를 원활하게 해주는, 파일에 대한 기본 익스포트를 가능하게 해줍니다.
:marked
  요점은 코드를 좀 더 재사용 가능하고, 읽기 편하며, 발생하기 쉬운 실수를 줄여준다는데 있습니다.

  다음의 *나쁜* 예제는 `AppComponent`를 정의하고, 앱을 부트스트랩하고, `Hero` 모델 객체를 정의하며 서버로부터 영웅들을 로드합니다... 하나의 파일 내에서 이 모든 것을요. *이렇게 하지 마세요*.

+makeExample('style-guide/ts/01-01/app/heroes/hero.component.avoid.ts', '', 'app/heroes/hero.component.ts')(avoid=1)
:marked
  컴포넌트를 구분하고 각자의 파일 내에서 자신들의 역할을 하도록 하는 것이 더 좋습니다.

+makeTabs(
  `style-guide/ts/01-01/app/main.ts,
  style-guide/ts/01-01/app/app.component.ts,
  style-guide/ts/01-01/app/heroes/heroes.component.ts,
  style-guide/ts/01-01/app/heroes/shared/hero.service.ts,
  style-guide/ts/01-01/app/heroes/shared/hero.model.ts,
  style-guide/ts/01-01/app/heroes/shared/mock-heroes.ts`,
  '',
  `app/main.ts,
  app/app.component.ts,
  app/heroes/heroes.component.ts,
  app/heroes/shared/hero.service.ts,
  app/heroes/shared/hero.model.ts,
  app/heroes/shared/mock-heroes.ts`)

:marked
  앱이 커져가면서, 이 규칙은 훨씬 더 중요해질 겁니다.

a(href="#toc") Back to top

.l-main-section
:marked
  ### 작은 함수
  <a id="01-02"></a>
  #### 스타일 01-02
.s-rule.do
  :marked
    함수를 작게 정의**하세요**.

.s-rule.consider
  :marked
    75 라인을 넘지 않도록 제한하는 것을 **고려하세요**.

.s-why
  :marked
    **왜냐구요?** 작은 함수가 테스트하기 쉬운데, 특히 함수가 한 가지 역할을 수행하고 한 가지 목적만을 지원하는 경우에 더욱 그렇습니다.

.s-why
  :marked
    **왜냐구요?** 작은 함수는 재사용을 촉진시킵니다.

.s-why
  :marked
    **왜냐구요?** 작은 함수는 읽기 좋습니다.

.s-why
  :marked
    **왜냐구요?** 작은 함수는 유지하기 쉽습니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 작은 함수는 외부 스코프와 변수를 공유하거나, 원치 않는 클로저 혹은 원치 않는 의존성 커플링을 만들어내는 큰 함수가 가져오는 숨겨진 버그들을 피할 수 있도록 도와줍니다.

a(href="#toc") Back to top

.l-main-section
:marked
  ## 네이밍

  네이밍 관례는 유지보수와 읽기를 쉽도록 만드는데 굉장히 중요한 역할을 합니다. 이 가이드는 파일 이름과 심볼 이름에 대한 네이밍 관례를 권고합니다.

.l-main-section
:marked
  ### 일반적 네이밍 가이드라인
  <a id="02-01"></a>
  #### 스타일 02-01

.s-rule.do
  :marked
    모든 심볼에 대해새 일관된 이름을 사용**하세요**.

.s-rule.do
  :marked
    심볼의 기능을 설명한 뒤 그것의 타입을 설명하는 패턴을 따르도록 **하세요**. 추천하는 패턴은 `feature.type.ts`입니다.

.s-why
  :marked
    **왜냐구요?** 네이밍 관례는 즉시 내용을 알아챌 수 있는 일관된 방법을 제공하는데 도움을 줍니다. 프로젝트 내 일관성은 필수적입니다. 팀 내 일관성은 중요하죠. 회사 내의 일관성은 엄청난 효과를 가져다 줍니다.

.s-why
  :marked
    **왜냐구요?** 네이밍 관례는 코드를 좀 더 빠르게 찾고 이해하기 쉽게 만들어줍니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 폴더와 파일 이름은 그것의 의도를 분명히 전달할 수 있어야 합니다. 예를 들어, `app/heroes/hero-list.component.ts`은 아마 영웅들의 목록을 관리하는 컴포넌트를 포함하고 있을 겁니다.

a(href="#toc") Back to top

.l-main-section
:marked
  ### 마침표와 대시로 파일 이름 분리하기
  <a id="02-02"></a>
  #### 스타일 02-02

.s-rule.do
  :marked
    서술적인 이름으로 단어를 분리하기 위해 대시를 사용**하세요**.

.s-rule.do
  :marked
    타입과 서술적인 이름을 구분하기 위해 마침표를 사용**하세요**.

.s-rule.do
  :marked
    컴포넌트의 기능 다음에 그것의 타입을 설명하는 패턴을 따르도록 모든 컴포넌트에 대해 일관된 타입 이름을 사용**하세요**. 추천하는 패턴은 `feature.type.ts`입니다.

.s-rule.do
  :marked
    `.service`, `.component`, `.pipe`을 포함하여 관례적인 타입 이름들을 사용**하세요**.
    필요하다면 추가적인 타입 이름을 만들어내세요. 그러나 너무 많이 만들지 않도록 하세요.

.s-why
  :marked
    **왜냐구요?** 타입 이름은 파일 내에서 하는 일이 무엇인지 빠르게 인지시켜주는 일관된 방법을 제공합니다.

.s-why
  :marked
    **왜냐구요?** 에디터 혹은 IDE의 불분명한 검색 기술을 사용해 특정 파일 타입을 찾는 것이 쉬워집니다.

.s-why
  :marked
    **왜냐구요?** `.service`와 같이 생략되지 않은 타입 이름이 서술적이고 애매모호하지 않습니다.
    `.srv`, `.svc` 그리고 `.serv`와 같은 축약형 이름들은 혼란을 줄 수 있습니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 자동화된 태스크를 위해 패턴 매칭을 제공합니다.

a(href="#toc") Back to top

.l-main-section
:marked
  ### 컴포넌트와 디렉티브
  <a id="02-03"></a>
  #### Style 02-03

.s-rule.do
  :marked
    표현 다음에 이름지어지는 모든 애셋들에 대해 일관된 이름을 사용**하세요**.

.s-rule.do
  :marked
    심볼에 대해서는 대문자 카멜 표기법을 사용**하세요**. 파일의 네이밍과 심볼의 이름을 일치시키세요.

.s-rule.do
  :marked
    심볼이 나타내는 바를 접미사로 하여 이름을 확장**하세요**.

.s-why
  :marked
    **왜냐구요?** 애셋을 빠르게 인지하고 참조하기 위한 일관된 방법을 제공합니다.

.s-why
  :marked
    **왜냐구요?** 대문자 카멜 표기법은 생성자를 사용해 초기화될 수 있는 객체를 식별하기 위한 관례입니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** `Component` 접두사는 좀 더 흔히 사용되며 좀 더 명시적으로 서술합니다.

- var top="vertical-align:top"
table(width="100%")
  col(width="50%")
  col(width="50%")
  tr
    th 심볼 이름
    th 파일 이름
  tr(style=top)
    td
      code-example.
        @Component({ ... })
        export class AppComponent {}
    td
      :marked
        app.component.ts
  tr(style=top)
    td
      code-example.
        @Component({ ... })
        export class HeroesComponent
    td
      :marked
        heroes.component.ts
  tr(style=top)
    td
      code-example.
        @Component({ ... })
        export class HeroListComponent
    td
      :marked
        hero-list.component.ts
  tr(style=top)
    td
      code-example.
        @Component({ ... })
        export class HeroDetailComponent
    td
      :marked
        hero-detail.component.ts
  tr(style=top)
    td
      code-example.
        @Directive({ ... })
        export class ValidationDirective
    td
      :marked
        validation.directive.ts
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### 서비스 이름
  <a id="02-04"></a>
  #### Style 02-04

.s-rule.do
  :marked
    모든 서비스에 대해 기능 뒤에 일관된 이름을 사용**하세요**.

.s-rule.do
  :marked
    서비스에 대해서 대문자 카멜 표기법을 사용**하세요**.

.s-rule.do
  :marked
    서비스의 역할이 분명치 않을 때(예. 명사일 때) `Service`를 접미사로 붙이**세요**.

.s-why
  :marked
    **왜냐규요?** 서비스를 빠르게 익식하고 참조하기 위한 일관된 방법을 제공하세요.

.s-why
  :marked
    **왜냐구요?** `Logger`와 같은 명확한 서비스 이름은 접두사를 필요로 하지 않습니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** `Credit`과 같은 서비스 이름들은 명사인데, 그것이 서비스인지 아니면 다른 것인지 명확하지 않을 것 같다면 접미사를 붙여 이름지어야 합니다.

- var top="vertical-align:top"
table(width="100%")
  col(width="50%")
  col(width="50%")
  tr
    th 심볼 이름
    th 파일 이름
  tr(style=top)
    td
      code-example.
        @Injectable()
        export class HeroDataService {}
    td
      :marked
        hero-data.service.ts
  tr(style=top)
    td
      code-example.
        @Injectable()
        export class CreditService {}
    td
      :marked
        credit.service.ts
  tr(style=top)
    td
      code-example.
        @Injectable()
        export class Logger {}
    td
      :marked
        logger.service.ts
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### 부트스트래핑
  <a id="02-05"></a>
  #### 스타일 02-05

.s-rule.do
  :marked
    `main.ts`라는 파일에 앱에 대한 부트스트래핑과 플랫폼 로직을 두도록 **하세요**.

.s-rule.avoid
  :marked
    `main.ts`에 앱 로직을 두지 **마세요**. 대신 컴포넌트나 서비스를 고려하세요.

.s-why
  :marked
    **왜냐구요?** 앱의 스타트업 로직을 위한 일관된 관례를 따르도록 하기 위해서 입니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 다른 기술 플랫폼과 유사한 관례를 따르도록 하기 위해서 입니다.

a(href="#toc") Back to top

.l-main-section
:marked
  ### 디렉티브 셀렉터
  <a id="02-06"></a>
  #### 스타일 02-06

.s-rule.do
  :marked
    디렉티브의 셀렉터를 네이밍하는데 소문자 카멜 표기법을 사용**하세요**.

.s-why
  :marked
    **왜냐구요?** 어트리뷰트 이름과 밀접한 뷰에 바운드된 디렉티브 내에 정의되어 있는 프로퍼티들의 이름을 유지하기 위해서입니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** Angular 2 HTML 파서는 대소문자를 구분하며 소문자 카멜 표기법을 받아들이기 때문입니다.

a(href="#toc") Back to top

.l-main-section
:marked
  ### 컴포넌트에 대한 커스텀 접두사
  <a id="02-07"></a>
  #### Style 02-07

.s-rule.do
  :marked
    컴포넌트의 셀렉터에 커스텀 접두사를 사용**하세요**. 예를 들어, `toh`라는 접두사는 **T**our **o**f **H**eroes을 나타내면 `admin`이라는 접두사는 어드민 기능 영역을 나타냅니다.

.s-rule.do
  :marked
    기능 영역 혹은 앱 그 자체를 나타내는 접두사를 사용**하세요**.

.s-why
  :marked
    **왜냐구요?** 이름 충돌을 막기 위해서 입니다.

.s-why
  :marked
    **왜냐구요?** 다른 앱에서 기능의 사용을 조성하고 공유하기 쉽도록 만들기 위해서 입니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 컴포넌트와 요소들이 쉽게 식별되게 하기 위해서 입니다.

+makeExample('style-guide/ts/02-07/app/heroes/hero.component.avoid.ts', 'example', 'app/heroes/hero.component.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/02-07/app/users/users.component.avoid.ts', 'example', 'app/users/users.component.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/02-07/app/heroes/hero.component.ts', 'example', 'app/heroes/hero.component.ts')
:marked

+makeExample('style-guide/ts/02-07/app/users/users.component.ts', 'example', 'app/users/users.component.ts')
:marked

:marked
  ### 디렉티브를 위한 커스텀 접두사
  <a id="02-08"></a>
  #### 스타일 02-08

.s-rule.do
  :marked
    디렉티브의 셀렉터에 대해 커스텀 접두사를 사용**하세요**(아래 예에서 **T**our **o**f **H**eroes을 `toh` 접두사로 표현한 것처럼).

.s-why
  :marked
    **왜냐구요?** 이름 충돌을 막기 위해서 입니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 디렉티브가 쉽게 식별되게 하기 위해서 입니다.

+makeExample('style-guide/ts/02-08/app/shared/validate.directive.avoid.ts', 'example', 'app/shared/validate.directive.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/02-08/app/shared/validate.directive.ts', 'example', 'app/shared/validate.directive.ts')
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### 파이프 이름
  <a id="02-09"></a>
  #### Style 02-09

.s-rule.do
  :marked
    모든 파이프에 대해 기능 뒤에 일관된 이름을 사용**하세요**.

.s-why.s-why-last
  :marked
    **왜냐구요?** 파이프를 빠르게 식별하고 참조하기 위한 일관된 방법을 제공하기 위해서 입니다.

- var top="vertical-align:top"
table(width="100%")
  col(width="50%")
  col(width="50%")
  tr
    th 심볼 이름
    th 파일 이름
  tr(style=top)
    td
      code-example.
        @Pipe({ name: 'ellipsis' })
        export class EllipsisPipe implements PipeTransform { }
    td
      :marked
        ellipsis.pipe.ts
  tr(style=top)
    td
      code-example.
        @Pipe({ name: 'initCaps' })
        export class InitCapsPipe implements PipeTransform { }
    td
      :marked
        init-caps.pipe.ts
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### 유닛 테스트 파일 이름
  <a id="02-10"></a>
  #### Style 02-10

.s-rule.do
  :marked
    테스트 스펙 파일에 테스트하고자 하는 컴포넌트와 동일한 이름을 부여**하세요**.

.s-rule.do
  :marked
    테스트 스펙 파일에 `.spec` 접미사를 붙이**세요**.

.s-why
  :marked
      **왜냐구요?** 테스트를 빠르게 식별하기 위한 일관된 방법을 제공하기 위해서 입니다.

.s-why.s-why-last
  :marked
      **왜냐구요?** [karma](http://karma-runner.github.io/) 혹은 다른 테스트 러너들을 위한 패턴 매칭을 제공하기 위해서 입니다.

:marked
- var top="vertical-align:top"
table(width="100%")
  col(width="50%")
  col(width="50%")
  tr
    th 심볼 이름
    th 파일 이름
  tr(style=top)
    td
      :marked
        컴포넌트
    td
      :marked
        heroes.component.spec.ts
      :marked
        hero-list.component.spec.ts
      :marked
        hero-detail.component.spec.ts
  tr(style=top)
    td
      :marked
        서비스
    td
      :marked
        logger.service.spec.ts
      :marked
        hero.service.spec.ts
      :marked
        filter-text.service.spec.ts
  tr(style=top)
    td
      :marked
        파이프
    td
      :marked
        ellipsis.pipe.spec.ts
      :marked
        init-caps.pipe.spec.ts
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### End to End 테스트 파일 이름
  <a id="02-11"></a>
  #### 스타일 02-11

.s-rule.do
  :marked
    테스트하려고 하는 기능 뒤에 `.e2e-spec` 접미사를 붙여 end-to-end 테스트 스펙 파일의 이름을 만드**세요**.

.s-why
  :marked
    **왜냐구요?** end-to-end 테스트를 빠르게 식별하기 위한 일관된 방법을 제공하기 위해서 입니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 테스트 러너와 빌드 자동화에 패턴 매칭을 제공하기 위해서 입니다.

:marked
:marked
- var top="vertical-align:top"
table(width="100%")
  col(width="50%")
  col(width="50%")
  tr
    th 심볼 이름
    th 파일 이름
  tr(style=top)
    td
      :marked
        End to End 테스트
    td
      :marked
        app.e2e-spec.ts
      :marked
        heroes.e2e-spec.ts
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ## 코딩 컨벤션

  일관된 집합의 코딩, 네이밍 그리고 화이트스페이스 관례을 갖도록 합니다.
  Have consistent set of coding, naming, and whitespace conventions.

.l-main-section
:marked
  ### 클래스
  <a id="03-01"></a>
  #### 스타일 03-01

.s-rule.do
  :marked
    클래스를 이름지을 때 대문자 카멜 표기법을 사용**하세요**.

.s-why
  :marked
    **왜냐구요?** 클래스 이름에 관례적 사고를 따르기 위함입니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 클래스는 초기화되어 인스턴스를 만들어 낼 수 있습니다. 인스턴스를 만들어 낼 수 있는 것들을 나타낼 때 보통 대문자 카멜 표기법을 사용하곤 합니다.

+makeExample('style-guide/ts/03-01/app/shared/exception.service.avoid.ts', 'example', 'app/shared/exception.service.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/03-01/app/shared/exception.service.ts', 'example', 'app/shared/exception.service.ts')
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### 상수
  <a id="03-02"></a>
  #### 스타일 03-02

.s-rule.do
  :marked
    상수를 이름지을 때 대문자 표기에 언더스코어를 함께 사용**하세요**.

.s-why
  :marked
    **왜냐구요?** 상수에 대해 관례적 사고를 따르기 위함입니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 상수를 쉽게 식별해낼 수 있습니다.

+makeExample('style-guide/ts/03-02/app/shared/data.service.avoid.ts', 'example', 'app/shared/data.service.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/03-02/app/shared/data.service.ts', 'example', 'app/shared/data.service.ts')
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### 인터페이스
  <a id="03-03"></a>
  #### 스타일 03-03

.s-rule.do
  :marked
    대문자 카멜 표기법을 사용하여 인터페이스의 이름을 지으**세요**.

.s-rule.do
  :marked
    `I` 접두사가 없는 인터페이스 이름을 **고려하세요**.

.s-why.s-why-last
  :marked
    **왜냐구요?** 타입을 사용할 때, 클래스를 타입으로 간단히 사용할 수 있기 때문입니다.

+makeExample('style-guide/ts/03-03/app/shared/hero-collector.service.avoid.ts', 'example', 'app/shared/hero-collector.service.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/03-03/app/shared/hero-collector.service.ts', 'example', 'app/shared/hero-collector.service.ts')
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### 프로퍼티와 메서드
  <a id="03-04"></a>
  #### 스타일 03-04

.s-rule.do
  :marked
    프로퍼티와 메서드 이름을 짓기 위해 소문자 카멜 표기법을 사용**하세요**.

.s-rule.avoid
  :marked
    private 프로퍼티와 메서드에 언더스코어를 접두사로 붙이는 것을 **피하세요**.

.s-why
  :marked
    **왜냐구요?** 프로퍼티와 메서드에 대해 관례적 사고를 따르기 위함입니다.

.s-why
  :marked
    **왜냐구요?** JavaScript는 실제로는 private 프로퍼티 혹은 메서드를 표현하지 못합니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** TypeScript의 사용이 private과 public 프로퍼티와 메서드 구분을 쉽게 해줄 겁니다.

+makeExample('style-guide/ts/03-04/app/shared/toast.service.avoid.ts', 'example', 'app/shared/toast.service.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/03-04/app/shared/toast.service.ts', 'example', 'app/shared/toast.service.ts')
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### Import Destructuring Spacing
  <a id="03-05"></a>
  #### 스타일 03-05

.s-rule.do
  :marked
    임포트 구문의 중괄호 내 앞 뒤로 각각 한 개의 화이트스페이스를 두도록 **하세요**.

.s-why.s-why-last
  :marked
    **왜냐구요?** 화이트스페이스가 임포트 구문을 읽기 쉽게 만들어 줄겁니다.

+makeExample('style-guide/ts/03-05/app/+heroes/shared/hero.service.avoid.ts', 'example', 'app/+heroes/shared/hero.service.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/03-05/app/+heroes/shared/hero.service.ts', 'example', 'app/+heroes/shared/hero.service.ts')
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### 임포트 라인 스페이싱
  <a id="03-06"></a>
  #### Style 03-06

.s-rule.do
  :marked
    서드 파티 라이브러리 임포트와 직접 만든 코드의 임포트 사이에 빈 줄 하나를 두도록 **하세요**.

.s-rule.do
  :marked
    모듈 별로 알파벳 순서에 의해 임포트 줄을 나열**하세요**.

.s-rule.do
  :marked
    임포트 애셋을 알파벳 순서대로 나열**하세요**.

.s-why
  :marked
    **왜냐구요?** 빈 줄은 임포트를 읽고 위치시키기 쉽도록 만들어 줍니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 알파벳 순서대로 나열하는 것이 임포트를 읽고 위치시키기 쉽도록 만들어 줍니다.

+makeExample('style-guide/ts/03-06/app/+heroes/shared/hero.service.avoid.ts', 'example', 'app/+heroes/shared/hero.service.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/03-06/app/+heroes/shared/hero.service.ts', 'example', 'app/+heroes/shared/hero.service.ts')
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ## 애플리케이션 구조

  짧은 기간의 구현 관점 그리고 긴 기간의 비전을 가지도록 하세요.
  작게 시작하되 앱이 지향하는 바를 마음 속에 두고 계세요.

  앱의 전체 코드는 `app`이라는 폴더 내에서 구현될 겁니다. 모든 내용은 파일 하나당 하나의 기능으로 구현될 겁니다. 각각의 컴포넌트, 서비스 그리고 파이프는 각각의 파일 내에 구현해야 합니다. 모든 서드 파티 벤더 스크립트들은 `app` 폴더가 아닌 다른 폴더에 저장되어야 합니다. 그런 서드 파티 벤더 스크립트들을 작성하지 않았으며, 그런 것들이 우리의 앱을 어지럽히는 것을 원치 않습니다. 파일들에 대해서 이 가이드 내에 있는 네이밍 컨벤션을 적용하시기 바랍니다.

a(href="#toc") Back to top

.l-main-section
:marked
  ### LIFT
  <a id="04-01"></a>
  #### 스타일 04-01

.s-rule.do
  :marked
    코드를 빠르게 위치시키고(`L`ocate), 단번에 코드를 인식하며(`I`dentify), 할 수 있는 한 가장 무난하도록(`F`lattest) 유지하고, 테스트를 시도**하세요**(`Try`).

.s-rule.do
  :marked
    중요한 순서대로 나열된, 이 네 가지 기초 가이드라인을 따르기 위한 구조로 정의**하세요**.

.s-why.s-why-last
  :marked
    **왜냐구요?** LIFT는 규모가 잘 조정되고, 모듈화되어 있으며, 코드를 빠르게 찾아주어 개발 효율성을 증가시키기 쉬운 일관된 구조를 제공합니다. 앱 구조를 확인하기 위한 또 다른 방법은 우리 자신에게 묻는 것입니다: 어떤 기능에 대한 연관된 모든 파일들을 얼마나 빨리 열어서 작업할 수 있을까?

a(href="#toc") Back to top

.l-main-section
:marked
  ### 위치
  <a id="04-02"></a>
  #### 스타일 04-02

.s-rule.do
  :marked
    코드를 이해하기 쉽고, 간단하며 빠르게 위치시키**세요**.

.s-why.s-why-last
  :marked
    **왜냐구요?** 프로젝트에 대해서 이런 것들이 매우 중요하다는 것을 깨닫게 될 겁니다. 만약 필요로 하는 파일들을 빠르게 찾지 못한다면, 가능한한 효율적으로 일하는 것이 불가능할 것이고, 구조는 변화를 요구하게 될 겁니다.
    파일 이름이 무엇인지, 관련된 파일이 어디 있는지를 모를 수도 있기에, 가장 알기 쉬운 곳 그리고 서로 가까운 곳에 두는 것이 굉장한 시간을 절약해줄 것입니다. 기술하는 폴더 구조는 이러한 것들을 도와줄 것입니다.

a(href="#toc") Back to top

.l-main-section
:marked
  ### 인식
  <a id="04-03"></a>
  #### 스타일 04-03

.s-rule.do
  :marked
    파일이 담고 있고 표현하고자 하는 것이 무엇인지를 바로 알 수 있도록 이름을 지으**세요**.

.s-rule.do
  :marked
    파일 이름에 기술하고 파일의 내용이 정확히 하나의 컴포넌트가 되도록 만드**세요**.

.s-rule.avoid
  :marked
    파일 내에 여러 컴포넌트, 여러 서비스 혹은 그것들을 섞어서 만들지 **마세요**.

.s-why.s-why-last
  :marked
    **왜냐구요?** 코드를 찾아 돌아다니는데 더 적은 시간이 들고, 좀 더 효율적으로 변하게 될 겁니다. 좀 더 긴 파일이 필요한 경우를 의미한다면, 그렇게 하세요.

.l-sub-section
  :marked
    모두 서로 관련되어 있는 아주 작은 기능 집합이 있는 경우 파일 당 한 개 규칙에는 예외가 있을 수 있습니다. 여전히 인식하기 쉽다면 말이죠.

a(href="#toc") Back to top

.l-main-section
:marked
  ### Flat
  <a id="04-04"></a>
  #### 스타일 04-04

.s-rule.do
  :marked
    가능한 길게 플랫한 폴더 구조를 유지하도록 **하세요**.

.s-rule.consider
  :marked
    7개 이상의 파일이 존재한다면 구분하기 위한 폴더 생성을 **고려하세요**.

.s-why.s-why-last
  :marked
    **왜냐구요?** 어느 누구도 파일을 찾기 위해 7단계의 폴더를 검색하는 것을 원치 않습니다.
    폴더 구조 내에 명백하고 빠른 번호 매기기 규칙이 없을테지만, 폴더 내에 7개에서 10개의 파일이 존재한다면, 그것은 어쩌면 서브 폴더를 만들어야 한다는 신호일지도 모릅니다.
    우리는 폴더 내부를 쾌적한 상태로 유지할 겁니다.
    새로운 폴더를 만들면서 (LIFT의 남은 부분들을 위한) 명백한 값이 존재할 때까지 좀 더 평평한 구조를 사용하세요.

a(href="#toc") Back to top

.l-main-section
:marked
  ### T-DRY (DRY하도록 노력하세요)
  <a id="04-05"></a>
  #### 스타일 04-05

.s-rule.do
  :marked
    DRY(Don't Repeat Yourself)하도록 **하세요**.

.s-rule.avoid
  :marked
    가독성을 해칠 만큼 너무 DRY 하는 것을 **피하세요**.

.s-why.s-why-last
  :marked
    **왜냐구요?** DRY 하는 것은 중요하지만, LIFT의 다른 것들을 희생할 만큼 결정적이지는 않습니다. 그것이 우리가 T-DRY라고 부르는 이유입니다.
    뷰를 위해 `hero-view.component.html`라고 이름 짓는 것을 원하는 아니에요. 왜냐면, 음, 그건 분명히 뷰이기 때문이죠.
    아닌 것이 분명하거나 관례에 따른 것이라면, 그렇게 이름 지어도 됩니다.

a(href="#toc") Back to top

.l-main-section
:marked
  ### 전체적인 구조를 위한 가이드라인
  <a id="04-06"></a>
  #### 스타일 04-06

.s-rule.do
  :marked
    작게 시작**하세요**. 그러나 앱이 더 커지리라는 것을 염두해두세요.

.s-rule.do
  :marked
    단기 관점의 구현과 장기간의 비전을 가지도록 **하세요**.

.s-rule.do
  :marked
    앱의 모든 코드를 `app`이라는 폴더 내에 두도록 **하세요**.

.s-rule.consider
  :marked
    `.ts`, `.html`, `.css` 그리고 `.spec` 파일을 포함하는 각각의 컴포넌트에 대해 폴더를 만드는 것을 **고려하세요**.

.s-why
  :marked
    **왜냐구요?** 앱이 커지면서 발달하기 쉬워짐에 따라, 초기 단계에서 앱 구조를 작고 쉽게 유지하는데 도움이 됩니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 컴포넌트는 종종 네 개의 파일(이를테면, `*.html`, `*.css`, `*.ts`, and `*.spec.ts`)를 갖게 되기에 폴더가 빠르게 지저분해질 수 있기 때문이죠.

.example-title Overall Folder and File Structure
.filetree
  .file src
  .children
    .file app
    .children
      .file +heroes
      .children
        .file hero
        .children
          .file hero.component.ts|html|css|spec.ts
          .file index.ts
        .file hero-list
        .children
          .file hero-list.component.ts|html|css|spec.ts
          .file index.ts
        .file shared
        .children
          .file hero.model.ts
          .file hero.service.ts|spec.ts
          .file index.ts
        .file heroes.component.ts|html|css|spec.ts
        .file index.ts
      .file shared
      .children
        .file ...
      .file app.component.ts|html|css|spec.ts
    .file main.ts
    .file index.html
    .file ...
:marked

.l-sub-section
  :marked
    컴포넌트를 전용 폴더 내에 두는 것을 더 선호하게 되면서, 작은 앱을 위한 또 다른 옵션은 컴포넌트를 평평하게 유지하는 것입니다(전용 폴더 내에서가 아니라).
    이렇게 하면 4개의 파일을 기존 폴더로 다시 올려놓게 되지만, 폴더 내재화를 줄일 수 있게 됩니다. 좀 더 밀착하게 되는 거죠.

a(href="#toc") Back to top

.l-main-section
:marked
  ### 공유 폴더
  <a id="04-07"></a>
  #### 스타일 04-07

.s-rule.do
  :marked
    `shared` 폴더 내에 컴포넌트 기능의 모든 공유 파일들을 넣어두도록 **하세요**.

.s-rule.consider
  :marked
    `.ts`, `.html`, `.css` 그리고 `.spec` 파일을 포함하는 각각 컴포넌트에 대한 폴더 생성을 **고려하세요**.

.s-why
  :marked
    **왜냐구요?** 기능 내 컴포넌트로부터 공유 파일을 분리해내고자 함입니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 컴포넌트 기능 내에서 공유 파일을 위치시키기 쉽게 만들기 위해서 입니다.

.example-title Shared Folder
.filetree
  .file src
  .children
    .file app
    .children
      .file +heroes
      .children
        .file hero
        .children
          .file ...
        .file hero-list
        .children
          .file ...
        .file shared
        .children
          .file hero-button
          .children
            .file ...
          .file hero.model.ts
          .file hero.service.ts|spec.ts
          .file index.ts
        .file heroes.component.ts|html|css|spec.ts
        .file index.ts
      .file shared
      .children
        .file exception.service.ts|spec.ts
        .file index.ts
        .file nav
        .children
          .file ...
      .file app.component.ts|html|css|spec.ts
    .file main.ts
    .file index.html
    .file ...
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### 기능에 의한 폴더 구조
  <a id="04-08"></a>
  #### 스타일 04-08

.s-rule.do
  :marked
    표현하고자 하는 기능에 대해 이름지어진 폴더를 만드**세요**.

.s-why
  :marked
    **왜냐구요?** 개발자는 각 파일이 무엇을 나타내는지 순간적으로 인식하도록 코드를 위치시키게 되며, 구조는 할 수 있을 만큼 평평해지고, 반복이나 중독되는 이름들이 없게 됩니다.

.s-why
  :marked
    **왜냐구요?** LIFT 가이드라인이 모두 커버됩니다.

.s-why
  :marked
    **왜냐구요?** 컨텐츠 구성을 통해 점점 혼란스러워지는 것을 줄여주고 LIFT 가이드라인으로 파일들의 정렬을 유지하는데 도움이 됩니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 많은 파일이 있는 경우(대략 10개 이상), 그 파일들의 위치를 잡는 것이 일관된 폴더 구조로는 더 쉬워지고 평평한 구조로는 좀 더 어려워집니다.

:marked
  아래는 컴포넌트 당 폴더를 가지고 있는 작은 앱의 예제입니다.

.example-title Folders per Component
.filetree
  .file src
  .children
    .file app
    .children
      .file +heroes
      .children
        .file hero
        .children
          .file ...
        .file hero-list
        .children
          .file ...
        .file shared
        .children
          .file ...
        .file heroes.component.ts|html|css|spec.ts
        .file index.ts
      .file +villains
      .children
        .file villain
        .children
          .file ...
        .file villain-list
        .children
          .file ...
        .file shared
        .children
          .file ...
        .file villains.component.ts|html|css|spec.ts
        .file index.ts
      .file shared
      .children
        .file nav
        .children
          .file ...
        .file ...
      .file app.component.ts|html|css|spec.ts
    .file main.ts
    .file index.html
    .file ...
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### 레이아웃 컴포넌트
  <a id="04-09"></a>
  #### 스타일 04-09

.s-rule.do
  :marked
    전체 레이아웃을 정의하는 컴포넌트를 `shared` 폴더에 두도록 **하세요**.

.s-rule.do
  :marked
    공유된 레이아웃 컴포넌트를 `shared` 폴더 아래에 각자의 폴더에 두도록 **하세요**.

.s-why
  :marked
    **왜냐구요?** 앱의 레이아웃을 호스트하기 위한 공간이 필요합니다. 전체 앱에서 필요로 하는 네비게이션 바나 푸터, 그리고 앱의 다른 측면들 말이죠.

.s-why.s-why-last
  :marked
    **왜냐구요?** 애플리케이 어디에서나 사용되는 일관된 장소에 모든 레이아웃을 구성하게 됩니다.

.example-title Folder for Layout Components
.filetree
  .file src
  .children
    .file app
    .children
      .file +heroes
      .children
        .file ...
      .file shared
      .children
        .file nav
        .children
          .file index.ts
          .file nav.component.ts|html|css|spec.ts
        .file footer
        .children
          .file index.ts
          .file footer.component.ts|html|css|spec.ts
        .file index.ts
        .file ...
      .file app.component.ts|html|css|spec.ts
    .file main.ts
    .file index.html
    .file ...
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### 베럴 생성과 임포트
  <a id="04-10"></a>
  #### 스타일 04-10

.s-rule.do
  :marked
    아이템을 임포트하고 집계하며 다시 익스포트하는 파일을 만드**세요**. 우린 이런 기술을 **베럴**이라고 부릅니다.

.s-rule.do
  :marked
    이 베럴 파일의 이름을 `index.ts`라고 지으**세요**.

.s-why
  :marked
    **왜냐구요?** 베럴은 단일 임포트 내에 많은 임포트를 모아줍니디.

.s-why
  :marked
    **왜냐구요?** 베럴은 파일이 필요로 하는 임포트의 개수를 줄여줍니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 베럴은 임포트 구문을 짧게 해줍니다.

+makeTabs(
  `style-guide/ts/04-10/app/shared/index.ts,
  style-guide/ts/04-10/app/shared/filter-text/index.ts,
  style-guide/ts/04-10/app/shared/modal/index.ts,
  style-guide/ts/04-10/app/shared/nav/index.ts,
  style-guide/ts/04-10/app/shared/spinner/index.ts,
  style-guide/ts/04-10/app/shared/toast/index.ts`,
  `example,,,,,`,
  `app/shared/index.ts,
  app/shared/filter-text/index.ts,
  app/shared/modal/index.ts,
  app/shared/nav/index.ts,
  app/shared/spinner/index.ts,
  app/shared/toast/index.ts`)
:marked

.example-title Folder Barrels
.filetree
  .file src
  .children
    .file app
    .children
      .file +dashboard
      .children
        .file ...
        .file index.ts
      .file +heroes
      .children
        .file ...
        .file index.ts
      .file shared
      .children
        .file nav
        .children
          .file ...
          .file index.ts
        .file search
        .children
          .file ...
          .file index.ts
        .file ...
        .file index.ts
      .file app.component.ts|html|css|spec.ts
    .file main.ts
    .file index.html
    .file ...
:marked

+makeExample('style-guide/ts/04-10/app/+heroes/heroes.component.avoid.ts', 'example', 'app/+heroes/heroes.component.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/04-10/app/+heroes/heroes.component.ts', 'example', 'app/+heroes/heroes.component.ts')
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### 느리게 로드되는 폴더
  <a id="04-11"></a>
  #### 스타일 04-11
  드물지만 어떤 애플리케이션 기능 혹은 워크플로우는 애플리케이션이 시작되는 시점 보다 *느리게 로드*되거나 *필요할 때 로드*될 수도 있습니다.

.s-rule.do
  :marked
    느리게 로드되는 기능의 컨텐츠들을 *느리게 로드되는 폴더*내에 두도록 **하세요**.
    전형적인 *느리게 로드되는 폴더*는 *라우팅 컴포넌트*, 그것의 하위 컴포넌트 그리고 그와 관려된 애셋과 모듈들을 포함하게 됩니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 해당 폴더가 기능의 컨텐츠를 식별하고 구분하기 쉽도록 해줍니다.

a(href="#toc") Back to top

.l-main-section
:marked
  ### 느리게 로드되는 폴더에 +를 접두사로 붙이기
  <a id="04-12"></a>
  #### 스타일 04-12

.s-rule.do
  :marked
    *느리게 로드되는 폴더*의 이름에 (+)를 접두사로 붙이**세요**. 예를 들자면, `+dashboard/`

.s-why
  :marked
    **왜냐구요?** 느리게 로드되는 코드 경로를 `+` 접두사로 쉽게 인식 가능합니다.

.s-why
  :marked
    **왜냐구요?** 느리게 로드되는 코드 경로를 느리게 로드되지 않는 경로와 쉽게 구분할 수 있습니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** `+`을 포함하는 `import` 경로를 보게 된다면, 느린 로딩을 사용하도록 빠르게 리팩토링할 수 있습니다.

.example-title Lazy Loaded Folders
.filetree
  .file src
  .children
    .file app
    .children
      .file +dashboard
      .children
        .file dashboard.component.ts|html|css|spec.ts
        .file index.ts
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### Never Directly Import Lazy Loaded Folders
  <a id="04-13"></a>
  #### Style 04-13

.s-rule.avoid
  :marked
    **Avoid** allowing modules in sibling and parent folders to directly import a module in a *lazy loaded feature*.

.s-why.s-why-last
  :marked
    **Why?** Directly importing a module loads it immediately when our intention is to load it on demand.

+makeExample('style-guide/ts/04-13/app/app.component.avoid.ts', 'example', 'app/app.component.ts')(avoid=1)
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### 느리게 로드되는 폴더를 상위 모듈에서 임포트할 수도 있습니다.
  <a id="04-14"></a>
  #### 스타일 04-14

.s-rule.do
  :marked
    상위 폴더로부터 느리게 로드된 모듈을 임포트하도록 허용**하세요**.

.s-why.s-why-last
  :marked
    **왜냐구요?** 상위 모듈은 느리게 로드된 모듈이 그것을 임포트한 시점에 이미 로드되어 있습니다.

+makeExample('style-guide/ts/04-14/app/heroes/heroes.component.ts', 'example', 'app/heroes/heroes.component.ts')
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### 느린 로드를 위해 컴포넌트 라우터를 사용하세요
  <a id="04-15"></a>
  #### 스타일 04-15

.s-rule.do
  :marked
    라우팅 가능한 기능을 느리게 로드하기 위해 컴포넌트 라우터를 사용**하세요**.

.s-why.s-why-last
  :marked
    **왜냐구요?** 이것은 요구에 따라 모듈을 로드하기 위한 가장 쉬운 방법입니다.

a(href="#toc") Back to top

.l-main-section
:marked
  ## 컴포넌트

  ### 컴포넌트 셀렉터 네이밍
  <a id="05-02"></a>
  #### 스타일 05-02

.s-rule.do
  :marked
    컴포넌트의 요소 셀렉터의 네이밍을 위해 `kebab-case` 사용**하세요**.

.s-why.s-why-last
  :marked
    **왜냐구요?** [Custom Elements](https://www.w3.org/TR/custom-elements/)에 대한 스펙으로 요소 이름을 일관되게 유지할 수 있습니다.

+makeExample('style-guide/ts/05-02/app/heroes/shared/hero-button/hero-button.component.avoid.ts', 'example', 'app/heroes/shared/hero-button/hero-button.component.ts')(avoid=1)
:marked

+makeTabs(
  `style-guide/ts/05-02/app/heroes/shared/hero-button/hero-button.component.ts,
  style-guide/ts/05-02/app/app.component.html`,
  'example,',
  `app/heroes/shared/hero-button/hero-button.component.ts,
  app/app.component.html`)
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### 요소로써의 컴포넌트
  <a id="05-03"></a>
  #### 스타일 05-03

.s-rule.do
  :marked
    셀렉터를 통해 컴포넌트를 요소로써 정의**하세요**.

.s-why
  :marked
    **왜냐구요?** 컴포넌트는 HTML과 부가적인 Angular 템플릿 문법을 포함하는 템플릿을 가지고 있습니다.
    템플릿은 페이지 상에 컨텐츠를 디스플레이하는 것과 밀접한 관련이 있으며, 그렇기에 요소들과 더 긴밀히 연계되어 있습니다.

.s-why
  :marked
    **왜냐구요?** 컴포넌트는 디렉티브로부터 파생되었는데, 그렇기에 셀렉터는 요소, 어트리뷰트 혹은 다른 셀렉터가 될 수도 있습니다. 셀렉터를 요소로 정의하는 것은 템플릿으로 컨텐츠를 표현하는 컴포넌트에 일관성을 제공합니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 템플릿의 HTML을 살펴봐서 심볼이 컴포넌트인지 디렉티브인지를 인식하는 것이 쉬워집니다.

+makeExample('style-guide/ts/05-03/app/heroes/shared/hero-button/hero-button.component.avoid.ts', 'example', 'app/heroes/hero-button/hero-button.component.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/05-03/app/app.component.avoid.html', '', 'app/app.component.html')(avoid=1)
:marked

+makeTabs(
  `style-guide/ts/05-03/app/heroes/shared/hero-button/hero-button.component.ts,
  style-guide/ts/05-03/app/app.component.html`,
  'example,',
  `app/heroes/shared/hero-button/hero-button.component.ts,
  app/app.component.html`)
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### 템플릿과 스타일의 각자의 파일에 두기
  <a id="05-04"></a>
  #### 스타일 05-04

.s-rule.do
  :marked
    3줄이 넘어간다면, 템플릿과 스타일을 분리된 파일에 두**세요**.

.s-rule.do
  :marked
    [component-name]이 컴포넌트 이름이라면, 템플릿 파일 이름을 `[component-name].component.html`으로 지으**세요**.

.s-rule.do
  :marked
    [component-name]이 컴포넌트 이름이라면, 스타일 파일 이름을 `[component-name].component.css`으로 지으**세요**.

.s-why
  :marked
    **왜냐구요?** 코드 파일(*.js와 *.ts) 내에서 인라인 템플릿을 위한 문법 힌트가 어떤 에디터에서는 제공되지 않습니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 컴포넌트 파일의 로직은 인라인 템플릿과 스타일이 석여있지 않을 때 읽기 쉽습니다.

+makeExample('style-guide/ts/05-04/app/heroes/heroes.component.avoid.ts', 'example', 'app/heroes/heroes.component.ts')(avoid=1)
:marked

+makeTabs(
  `style-guide/ts/05-04/app/heroes/heroes.component.ts,
  style-guide/ts/05-04/app/heroes/heroes.component.html,
  style-guide/ts/05-04/app/heroes/heroes.component.css`,
  'example,,',
  `app/heroes/heroes.component.ts,
  app/heroes/heroes.component.html,
  app/heroes/heroes.component.css`)
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### 입력과 출력 프로퍼티를 인라인으로 데코레이트하기
  <a id="05-12"></a>
  #### 스타일 05-12

.s-rule.do
  :marked
    [`@Directive`](https://angular.io/docs/ts/latest/api/core/Directive-decorator.html)와 [`@Component`](https://angular.io/docs/ts/latest/api/core/Component-decorator.html) 데코레이터의 `inputs`과 `outputs` 프로퍼티 대신에
    [`@Input`](https://angular.io/docs/ts/latest/api/core/Input-var.html)과 [`@Output`](https://angular.io/docs/ts/latest/api/core/Output-var.html)을 사용**하세요**:

.s-rule.do
  :marked
    데코레이트하는 프로퍼티와 같은 줄에 `@Input()`나 `@Output()`를 두도록 **하세요**.

.s-why
  :marked
    **왜냐구요?** 클래스 내 어떤 프로퍼티가 입력인지 출력인지를 식별하는게 쉬워지고 가독성도 좋아집니다.

.s-why
  :marked
    **왜냐구요?** [`@Input`](https://angular.io/docs/ts/latest/api/core/Input-var.html) 혹은 [`@Output`](https://angular.io/docs/ts/latest/api/core/Output-var.html)와 연계된
    프로퍼티 혹은 이벤트 이름을 바꿔야 할 때가 온다면, 한군데서 그것을 수정할 수 있게 됩니다.

.s-why
  :marked
    **왜냐구요?** 디렉티브에 붙어있는 메타데이터 선언이 더 짧아져서 가독성이 좀 더 좋아집니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 같은 줄에 데코레이터를 두는 것은 코드를 더 짧게 만들어주며, 프로퍼티가 입력인지 출력인지를 좀 더 쉽게 인식할 수 있도록 해줍니다.

+makeExample('style-guide/ts/05-12/app/heroes/shared/hero-button/hero-button.component.avoid.ts', 'example', 'app/heroes/shared/hero-button/hero-button.component.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/05-12/app/heroes/shared/hero-button/hero-button.component.ts', 'example', 'app/heroes/shared/hero-button/hero-button.component.ts')
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### 입력과 출력의 이름을 다시 짓지 않도록 하기
  <a id="05-13"></a>
  #### 스타일 05-13

.s-rule.avoid
  :marked
    가능하다면, 입력과 출력의 이름을 다시 짓는 것을 **피하세요**.

.s-why.s-why-last
  :marked
    **왜냐구요?** 주어진 디렉티브의 출력 혹은 입력 프로퍼티가 주어진 방법으로 이름지어졌으나 공개 API와 다르게 익스포트되는 경우 혼란을 초래할지도 모릅니다.

+makeExample('style-guide/ts/05-13/app/heroes/shared/hero-button/hero-button.component.avoid.ts', 'example', 'app/heroes/shared/hero-button/hero-button.component.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/05-13/app/app.component.avoid.html', '', 'app/app.component.html')(avoid=1)
:marked

+makeTabs(
  `style-guide/ts/05-13/app/heroes/shared/hero-button/hero-button.component.ts,
  style-guide/ts/05-13/app/app.component.html`,
  'example,',
  `app/heroes/shared/hero-button/hero-button.component.ts,
  app/app.component.html`)
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### 멤버 시퀀스
  <a id="05-14"></a>
  #### 스타일 05-14

.s-rule.do
  :marked
    프로퍼티를 위에 두고 메서드를 아래에 두도록 **하세요**.

.s-rule.do
  :marked
    알파벳 순서대로, public 멤버 다음에 private 멤버를 두도록 **하세요**.

.s-why.s-why-last
  :marked
    **왜냐구요?** 일정한 순서에 맞춰 멤버를 두는 것이 읽기 편하고 컴포넌트 내 멤버가 어떤 목적을 위해 있는 것인지 즉각적으로 인식하는데 도움을 줍니다.

+makeExample('style-guide/ts/05-14/app/shared/toast/toast.component.avoid.ts', 'example', 'app/shared/toast/toast.component.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/05-14/app/shared/toast/toast.component.ts', 'example', 'app/shared/toast/toast.component.ts')
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### 서비스 내에 로직 두기
  <a id="05-15"></a>
  #### 스타일 05-15

.s-rule.do
  :marked
    뷰에서 요구하는 것 외에 컴포넌트 내 로직을 두는 것을 제한**하세요**. 다른 모든 로직들은 서비스에게 위임해야 합니다.

.s-rule.do
  :marked
    재사용 가능한 로직들은 서비스로 옮기고 컴포넌트는 간단하고 원래의 목적에 집중하도록 유지**하세요**.

.s-why
  :marked
    **왜냐구요?** 로직은 서비스 내에 위치하고 함수를 통해 공개되어야 여러 컴포넌트에 의해 재사용될 수도 있습니다.

.s-why
  :marked
    **왜냐구요?** 서비스 내 로직은 컴포넌트 내에서 호출되는 로직이 쉽게 mock될 수 있기에 유닛 테스트와 좀 더 쉽게 분리될 수 있습니다.

.s-why
  :marked
    **왜냐구요?** 의존성이 제거되고 컴포넌트로부터 구현의 세부사항을 숨길 수 있습니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 컴포넌트를 슬림하고 쓸모없는 부분이 없으며 눈에 익숙해지도록 유지할 수 있습니다.

+makeExample('style-guide/ts/05-15/app/heroes/hero-list/hero-list.component.avoid.ts', '', 'app/heroes/hero-list/hero-list.component.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/05-15/app/heroes/hero-list/hero-list.component.ts', 'example', 'app/heroes/hero-list/hero-list.component.ts')
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### 출력 프로퍼티에 접두사를 붙이지 않기
  <a id="05-16"></a>
  #### 스타일 05-16

.s-rule.do
  :marked
    `on` 접두사를 붙이지 않고 이벤트 이름을 만드**세요**.

.s-rule.do
  :marked
    이벤트 핸들러 메서드의 이름을 이벤트 이름에 접두사 `on`을 붙여 만드**세요**.

.s-why
  :marked
    **왜냐구요?** 이것은 버튼 클릭과 같은 빌트인 이벤트와 일관성을 유지시켜줍니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** Angular는 [대체 문법](https://angular.io/docs/ts/latest/guide/template-syntax.html#!#binding-syntax)에 대해 `on-*`을 허용합니다.
    이벤트 자체가 `on`으로 접두사 처리되어 있었다면, 이로 인해 `on-onEvent` 바인딩 표현식의 결과를 낳게 될 것입니다.

+makeExample('style-guide/ts/05-16/app/heroes/hero.component.avoid.ts', 'example', 'app/heroes/hero.component.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/05-16/app/app.component.avoid.html', '', 'app/app.component.html')(avoid=1)
:marked

+makeTabs(
  `style-guide/ts/05-16/app/heroes/hero.component.ts,
  style-guide/ts/05-16/app/app.component.html`,
  'example,',
  `app/heroes/hero.component.ts,
  app/app.component.html`)
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### 컴포넌트 클래스에 프레렌테이션 로직 두기
  <a id="05-17"></a>
  #### 스타일 05-17

.s-rule.do
  :marked
    프로젠테이션 로직을 템플릿이 아닌 컴포넌트 내에 두도록 **하세요**.

.s-why
  :marked
    **왜냐구요?** 두 군데 흩어지지 않고 한 군데(컴포넌트 클래스)로 로직이 모아질 겁니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 컴포넌트의 프레젠테이션 로직을 템플릿 대신 클래스 내에 유지하는 것은 테스트 가능성, 유지보수성, 그리고 재사용성을 높여줍니다.

+makeExample('style-guide/ts/05-17/app/heroes/hero-list/hero-list.component.avoid.ts', 'example', 'app/heroes/hero-list/hero-list.component.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/05-17/app/heroes/hero-list/hero-list.component.ts', 'example', 'app/heroes/hero-list/hero-list.component.ts')
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ## 디렉티브

a(href="#toc") Back to top

.l-main-section
:marked
  ### 기존 요소를 향상시키기 위해 디렉티브 사용하기
  <a id="06-01"></a>
  #### 스타일 06-01

.s-rule.do
  :marked
    템플릿 없이 프레젠테이션 로직을 가지고 있을 경우 어트리뷰트 디렉티브를 사용**하세요**.

.s-why
  :marked
    **왜냐구요?** 어트리뷰트 디렉티브는 연계된 템플릿을 가지고 있지 않습니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 요소는 한 개 이상의 적용된 어트리뷰트 디렉티브를 가지고 있을 수도 있습니다.

+makeExample('style-guide/ts/06-01/app/shared/highlight.directive.ts', 'example', 'app/shared/highlight.directive.ts')
:marked

+makeExample('style-guide/ts/06-01/app/app.component.html', null, 'app/app.component.html')
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### HostListener와 HostBinding 클래스 데코레이터 사용하기
  <a id="06-03"></a>
  #### 스타일 06-03

.s-rule.do
  :marked
    @Directive와 @Component 데코레이터의 host 프로퍼티 대신에 @HostListener와 @HostBinding을 사용**하세요**:

.s-why
  :marked
    **왜냐구요?** @HostBinding 혹은 @HostListener 각각에 연계된 프로퍼티 혹은 메서드 이름은 오로지 한 군데(디렉티브 클래스 내)에서만 수정하면 됩니다.
    이에 반해 host를 사용한다면 컨트롤러 내부의 프로퍼티 선언과 디렉티브와 연계된 메타데이터 양쪽 모두 수정해야 합니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 디렉티브에 붙은 메타데이터 선언이 좀 더 짧아지며 그래서 가독성이 좋아집니다.

+makeExample('style-guide/ts/06-03/app/shared/validate.directive.avoid.ts', 'example', 'app/shared/validate.directive.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/06-03/app/shared/validate.directive.ts', 'example', 'app/shared/validate.directive.ts')
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ## 서비스

  ### 서비스는 동일한 주입자 내에서 싱글턴입니다
  <a id="07-01"></a>
  #### 스타일 07-01

.s-rule.do
  :marked
    동일한 주입자 내에서 서비스를 싱글턴으로 사용**하세요**. 데이터 공유와 기능성을 위해 그렇게 사용하시기 바랍니다.

.s-why
  :marked
    **왜냐구요?** 서비스는 기능 구역 혹은 앱에 걸쳐 메서드를 공유하는데 이상적입니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 서비스는 상태가 있는 인메모리 데이터 공유에 있어 이상적입니다.

+makeExample('style-guide/ts/07-01/app/heroes/shared/hero.service.ts', 'example', 'app/heroes/shared/hero.service.ts')
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### 단일 책임
  <a id="07-02"></a>
  #### 스타일 07-02

.s-rule.do
  :marked
    컨텍스트에 의해 캡슐화된 단일 책임으로 서비스를 생성**하세요**.

.s-rule.do
  :marked
    서비스가 그것의 단일 목적을 벗어나기 시작하면 새로운 서비스를 만드**세요**.

.s-why
  :marked
    **왜냐구요?** 서비스가 여러 책임을 가진다면, 테스트하기 어려우집니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 서비스가 여러 책임을 가진다면, 그것을 주입하는 모든 컴포넌트 혹은 서비스들은 그때부터 사용하지도 않는 그 모든 것을 받게 됩니다.

a(href="#toc") Back to top

.l-main-section
:marked
  ### 서비스 제공하기
  <a id="07-03"></a>
  #### 스타일 07-03

.s-rule.do
  :marked
    서비스가 공유되게 될 최상위 접점 컴포넌트에서 Angular 2 주입자에 서비스를 제공**하세요**.

.s-why
  :marked
    **왜냐구요?** Angular 2의 주입자는 계층적입니다.

.s-why
  :marked
    **왜냐구요?** 서비스가 최상위 계층의 컴포넌트에서 제공되게 되면, 해당 인스턴트는 최상위 계층 컴포넌트의 모든 하위 컴포넌트에 공유되며 사용 가능해집니다.

.s-why
  :marked
    **왜냐구요?** 서비스가 메서드 혹은 상태를 공유하고 있는 경우 이상적입니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 서로 다른 두 개의 컴포넌트가 서비스의 다른 인스턴스를 필요로 하는 경우에는 이상적이지 않습니다. 이 시나리오 상에서는 새로운 구분된 인스턴스를 필요로 하는 컴포넌트 계층에 서비스를 제공하는 것이 더 좋습니다.

+makeTabs(
  `style-guide/ts/07-03/app/app.component.ts,
  style-guide/ts/07-03/app/heroes/hero-list/hero-list.component.ts`,
  '',
  `app/app.component.ts,
  app/heroes/hero-list/hero-list.component.ts`)
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ### @Injectable() 클래스 데코레이터를 사용하세요
  <a id="07-04"></a>
  #### 스타일 07-04

.s-rule.do
  :marked
    서비스의 의존성을 위해 타입을 토큰으로 사용 중일 때 `@Inject` 파라메터 데코레이터 대신에 `@Injectable` 클래스 데코레이터를 사용**하세요**.

.s-why
  :marked
    **왜냐구요?** Angular DI 메카니즘은 서비스의 생성자로 선언된 타입들에 기반하여 서비스의 모든 의존성들을 분석합니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 서비스가 타입 토큰과 연계된 의존성만을 받아들이는 경우, `@Injectable()` 문법은 각각의 생성자 파라메터에 개별적으로 `@Inject()`을 사용하는 것과 비교하여 코드가 간단합니다.

+makeExample('style-guide/ts/07-04/app/heroes/shared/hero-arena.service.avoid.ts', 'example', 'app/heroes/shared/hero-arena.service.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/07-04/app/heroes/shared/hero-arena.service.ts', 'example', 'app/heroes/shared/hero-arena.service.ts')
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ## 데이터 서비스

  ### 데이터 호출 분리
  <a id="08-01"></a>
  #### 스타일 08-01

.s-rule.do
  :marked
    데이터 오퍼레이션을 만들고 데이터로 서비스와 상호작용하기 위한 로직을 리팩토링**하세요**.

.s-rule.do
  :marked
    데이터 서비스로 하여금 XHR 호출, 로컬 스토리지, 메모리 내 보관 혹은 기타 데이터 오퍼레이션 등에 대해 책임지도록 만드**세요**.

.s-why
  :marked
    **왜냐구요?** 컴포넌트의 책임은 뷰에 대한 정보 프레젠이션과 수집입니다. 데이터를 어떻게 가져오는지에 대해서는 신경쓸 필요가 없고 단지 누구에게 요청해야 하는지를 알면 될 뿐입니다.
    데이터 서비스 분리는 데이터를 어떻게 가져올지에 대한 로직을 데이터 서비스로 옮겨주고 컴포넌트를 좀 더 간단하고 뷰에 집중할 수 있도록 도와줍니다.

.s-why
  :marked
    **왜냐구요?** 데이터 서비스를 사용하는 컴포넌트를 테스트하는 중에 데이터 호출을 테스트(가짜든 진짜든)하기 쉽게 만들어 줍니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** 데이터 서비스 구현은 데이터 저장소를 다루기 위한 매우 특성화된 코드를 가지고 있을지도 모릅니다.
    데이터를 요청하는 방법인 헤더 혹은 `Http`와 같은 다른 서비스를 포함하고 있을 수도 있습니다.
    데이터 서비스 내로 로직을 분리하는 것은 외부의 컨슈머(아마도 컴포넌트가 되겠죠)로부터 구현을 숨기도록 하나의 장소에 해당 로직들을 캡슐화할 뿐만 아니라 구현을 변경하기 쉽도록 만들어 줍니다.

a(href="#toc") Back to top

.l-main-section
:marked
  ## 생명주기 후크

  Angular에 의해 제공되는 중요한 이벤트를 이용하기 위해 생명주기 후크를 사용하세요.

a(href="#toc") Back to top

.l-main-section
:marked
  ### 생명주기 후크 인터페이스를 구현하세요
  <a id="09-01"></a>
  #### 스타일 09-01

.s-rule.do
  :marked
    생명주기 후크 인터페이스를 구현**하세요**.

.s-why.s-why-last
  :marked
    **왜냐구요?** 메서드 시그니처에 의한 강력한 타이핑을 얻게 됩니다.
    컴파일러와 에디터는 잘못된 스펠링을 알려줄 겁니다.

+makeExample('style-guide/ts/09-01/app/heroes/shared/hero-button/hero-button.component.avoid.ts', 'example', 'app/heroes/shared/hero-button/hero-button.component.ts')(avoid=1)
:marked

+makeExample('style-guide/ts/09-01/app/heroes/shared/hero-button/hero-button.component.ts', 'example', 'app/heroes/shared/hero-button/hero-button.component.ts')
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ## 라우팅

  클라이언트 측 라우팅은 컴포넌트 트리 체계 사이의 네비게이션 플로우를 만들고 수많은 하위 컴포넌트로 구성되는 컴포넌트를 구성하는데 있어 중요합니다.

a(href="#toc") Back to top

.l-main-section
:marked
  ### 컴포넌트 라우터
  <a id="10-01"></a>
  #### 스타일 10-01

.s-rule.do
  :marked
    라우트 설정을 라우팅 컴포넌트 파일로 분리**하세요**. 이는 컴포넌트 라우터라고도 합니다.

.s-rule.do
  :marked
    컴포넌트 라우터 내에서 `<router-outlet>`을 사용**하세요**. 여기에서 라우트는 그들의 템플릿을 디스플레이하는 컴포넌트 대상을 갖게 될 겁니다.

.s-rule.do
  :marked
    컴포넌트 라우터 내 로직을 라우팅 측면과 그것의 대상 컴포넌트에 집중시키**세요**.

.s-rule.do
  :marked
    다른 로직들은 서비스와 다른 컴포넌트로 추출**하세요**.

.s-why
  :marked
    **왜냐구요?** 라우팅을 다루는 컴포넌트는 컴포넌트 라우터로 알려져 있으므로 Angular 2 라우팅 패턴을 따라야 합니다.

.s-why.s-why-last
  :marked
    **왜냐구요?** `<router-outlet>`은 템플릿이 대상 라우트에 대해 디스플레이해야 하는 곳을 가르킵니다.

+makeExample('style-guide/ts/10-01/app/app.component.ts', '', 'app/app.component.ts')
:marked

a(href="#toc") Back to top

.l-main-section
:marked
  ## 부록

  유용한 도구와 Angular 2를 위한 팁

a(href="#toc") Back to top

.l-main-section
:marked
  ### Codelyzer
  <a id="A-01"></a>
  #### 스타일 A-01

.s-rule.do
  :marked
    이 가이드를 따르려면 [codelyzer](https://www.npmjs.com/package/codelyzer)를 사용**하세요**.

.s-rule.consider
  :marked
    당신의 요구사항에 맞도록 codelyzer 내 규칙 조정을 **고려하세요**.
    
a(href="#toc") Back to top

.l-main-section
:marked
  ### 파일 템플릿과 스니펫
  <a id="A-02"></a>
  #### 스타일 A-02

.s-rule.do
  :marked
    일관된 스타일과 패턴을 따르기 위해 파일 템플릿과 스니펫을 사용**하세요**.
    다음은 웹 개발 에디터와 IDE들을 위한 템플릿과 스니펫입니다.

.s-rule.consider
  :marked
    [Visual Studio Code](https://code.visualstudio.com/)을 위한 [스니펫](https://marketplace.visualstudio.com/items?itemName=johnpapa.Angular2) 사용을 고려**하세요**.

    [![Use Extension](https://github.com/johnpapa/vscode-angular2-snippets/raw/master/images/use-extension.gif)](https://marketplace.visualstudio.com/items?itemName=johnpapa.Angular2)

    [Atom](https://atom.io/)을 위한 [스니펫](https://atom.io/packages/angular-2-typescript-snippets) 사용을 고려**하세요**.

    [Sublime Text](http://www.sublimetext.com/)을 위한 [스니펫](https://github.com/orizens/sublime-angular2-snippets) 사용을 고려**하세요**.

    [Vim](http://www.vim.org/)을 위한 [스니펫](https://github.com/mhartington/vim-angular2-snippets) 사용을 고려**하세요**.

a(href="#toc") Back to top
