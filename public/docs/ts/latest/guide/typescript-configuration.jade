include ../_util-fns

:marked
  TypeScript는 Angular 애플리케이션 개발을 위한 1순위 언어입니다.
  
  TypeScript는 타입 안전과 도구 사용을 위한 디자인 타임 지원을 가진 JavaScript의 변형입니다.
  
  브라우저는 직접적으로 TypeScript를 실행할 수 없습니다. 그것은 *tsc* 컴파일러를 이용해 JavaScript로 "transpile"해야 하며
  그러기 위해서는 몇 가지 설정이 필요합니다.
  
  이 챕터는 Angular 개발자들에게 중요한 TypeScript 설정과 TypeScript 환경의 몇 가지 방향에 대해서 다루고 있습니다. 
  
  * [tsconfig.json](#tsconfig) - TypeScript 컴파일러 설정
  * [typings](#typings) - TypesScript 정의 파일.

a(id="tsconfig")
.l-main-section
:marked
  ## *tsconfig.json*
  JavaScript 파일들을 생성하도록 컴파일러를 가이드하기 위해 일반적으로 프로젝트에 TypeScript 설정 파일 (`tsconfig.json`)을 추가할 겁니다.
.l-sub-section
  :marked
    공식적인 [TypeScript wiki](https://github.com/Microsoft/TypeScript/wiki/tsconfig.json)로부터
    `tsconfig.json`에 관한 자세한 내용을 참고하시기 바랍니다.
:marked
  우리는 [퀵스타트](../quickstart.html)에서 다음의 `tsconfig.json`를 생성했습니다:
+makeJson('quickstart/ts/tsconfig.1.json', null, 'tsconfig.json')(format=".")
:marked
  이 파일의 옵션들과 플래그들은 Angular 2 애플리케이션에서는 필수입니다.
  
  <a id="noImplicitAny"></a>
  ### *noImplicitAny*과 *suppressImplicitAnyIndexErrors*

  TypeScript 개발자들은 `noImplicitAny` 플래그는 `true` 혹은 `false`가 되어야 하는지에 대해서 동의하지 않습니다.
  거기에는 정답이 없으며 후에 플래그를 변경할 수도 있습니다.
  그러나 우리의 선택은 이제 더 큰 프로젝트에서 차이점을 만들어내기에 논의할 만합니다.

  `noImplicitAny` 플래그가 `false` (기본값)인 경우,
  변수가 사용되는 방법에 근거하여 타입을 추론할 수 없는 경우,
  컴파일러는 변수 타입을 `any`로 조용히 디폴트시킵니다.
  그것이 우리가 *암묵적인 `any`*로 나타내고자 하는 바입니다.

  우리는 퀵스타트에서 TypeScript 개발에 대해 좀 더 쉽게 배울수 있도록 `noImplicitAny` 플래그를 `false`로 초기화했습니다.
  
  `noImplicitAny` 플래그가 `true`고 TypeScript 컴파일러가 타입을 추론하지 못하는 경우에도,
  여전히 JavaScript 파일을 생성하게 됩니다. 그러나 컴파일러는 **오류도 리포트**하게 됩니다.
  
  많은 노련한 개발자들은 이런 좀 더 엄격한 설정을 선호하는데 타입 검사가 컴파일 시에 뜻하지 않은 오류를 잡아내기 때문입니다. 
  
  `noImplicitAny` 플래그가 `true`인 경우에 조차 변수 타입을 `any`로 설정할 수 있습니다.
  우리는 그것이 해당 상황에서의 최선의 선택인 것처럼 보일 경우, 해당 문제에 대해 신중하게 생각해본 뒤에, 고의적이고 명시적으로 그렇게 하도록 합니다. 

  `noImplicitAny` 플래그를 `true`로 설정한다면, *암묵적 인덱스 오류*가 발생할 수도 있습니다. 
  대부분은 개발자들은 *이런 특수한 오류*가 도움이 된다기 보다는 짜증난다고 느낍니다.
  우리는 다음의 추가적인 플래그로 그것들을 억누를 수 있습니다.
code-example(format=".").
  "suppressImplicitAnyIndexErrors":true


a(id="typings")
.l-main-section
:marked
  ## TypeScript Typings
  jQuery, Jasmine 테스팅 라이브러리 그리고 Angular 등 많은 JavaScript 라이브러리들은
  TypeScript 컴파일러가 네이티브로 인정하지 않는 기능과 문법을 지닌 JavaScript 환경을 확장합니다.
  컴파일러가 무언가를 인정하지 않는 경우, 오류를 던지게 됩니다. 
  
  우리는 컴파일러에게 우리가 로드한 라이브러리에 관해 알려주기 위해 
  [TypeScript 타입 정의 파일](http://www.typescriptlang.org/Handbook#writing-dts-files) &mdash; *d.ts files* &mdash;
  을 사용하게 됩니다.
  
  TypeScript를 사용 가능한 에디터는 이런 동일한 정의 파일들을 라이브러리 기능에 관한 타입 정보를 디스플레이의 목적으로 활용합니다.
  
  많은 라이브러리들은 TypeScript 컴파일러와 에디터 모두가 그것들을 찾을 수 있는 npm 패키지 내에 라이브러리의 정의 파일들을 포함합니다.  
  Angular도 그런 라이브러리 중 하나입니다.
  Angular의 파트들을 설명하는 몇몇 `...d.ts`을 보려면 Angular 애플리케이션의 `node_modules/@angular/core/` 폴더 안을 들여다 보시기 바랍니다.
  
  **모든 Angular 패키지들이 그렇듯이 *d.ts* 파일들을 포함하는 라이브러리 패키지에 대한 *typings* 파일을 얻기 위해서 어떤 것도 할 필요가 없습니다.**
  
  ### 설치가능한 typings 파일들
  슬프게도, 많은 라이브러리들 &mdash; 그 중에서도 jQuery, Jasmine, 그리고 Lodash &mdash; 은 그들의 npm 패키지 내에 `d.ts` 파일을 포함하고 있지 *않습니다*.
  운좋게도, 제작자와 커뮤니티 기여자들 중 누군가가 이런 라이브러리들을 위해 각각의 *d.ts* 파일을 생성하여 잘 알려진 위치에 푸시해두었습니다.  
  *typings* 도구가 우리를 위해 이런 파일을 찾아서 가져올 수 있습니다.
  
  우리는 npm으로 [typings](https://github.com/typings/typings/blob/master/README.md) 도구 
  (`package.json` 내에 *devDependencies* 내에 나열됩니다)를 설치했고 *npm* 설치가 끝난 뒤에 자동으로 해당 도구가 실행되도록
  npm 스크립트를 추가해두었습니다.
+makeJson('quickstart/ts/package.1.json', {paths: 'scripts.postinstall'}, 'package.json (postinstall)')(format=".")
:marked
  이 *typings* 도구 명령은 `typings.json` 파일 안에서 식별되는 *d.ts* 파일들을 **typings** 폴더 내로 설치합니다. 
  우리는 [퀵스타트](../quickstart.html)에서 `typings.json` 파일을 생성했었습니다:
+makeJson('quickstart/ts/typings.1.json', null, 'typings.json')(format=".")
:marked
  퀵스타트에서 세 개의 *typings* 파일, *d.ts* 파일을 가져왔습니다
  
  * ES5를 지원하는 브라우저에 ES2015/ES6 호환성을 부여하는 [core-js](https://github.com/zloirock/core-js/blob/master/README.md)
  
  * Jasmine 테스트 프레임워크를 위한 [jasmine](http://jasmine.github.io/) typings
  
  * nodejs 환경의 객체들을 참조하는 코드를 위한 [node](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/node/node.d.ts); 
  [webpack](./webpack.html) 챕터에서 예제를 참고하시기 바랍니다.
  
  퀵스타트 자체는 이런 typings를 요구하지는 않지만 문서 내 많은 샘플들은 필요로 합니다.
  우리 중 대부분은 우리가 전형적인 ES2015 기능에 맞춰 코드를 만들 수 없거나 즉시 사용 가능한 테스팅을 지원하지 않는다면 실망할 것입니다.

  우리 스스로가 *typings* 도구를 실행할 수도 있습니다.
  다음 명령은 `postIntall` 후크가 실패할 경우 때때로 필요에 의해, typings 파일들을 (재)설치합니다.
code-example(format="").
  npm run typings install
:marked
  이 명령어는 설치된 typings 파일들을 나열합니다:
code-example(format="").
  npm run typings list
:marked
  다음 명령어는 *DefinitelyTyped* 저장소로부터 Jasmine 테스트 라이버러리를 위한 typings 파일을 설치하거나 갱신하며
  `typings.config`을 갱신하여 typings을 설치하고 난 다음에 자동으로 그것을 가져오도록 해줍니다.
code-example(format="").
  npm run typings -- install dt~jasmine --save --global
.l-sub-section
  :marked
    [&ndash;&ndash; 옵션](https://docs.npmjs.com/cli/run-script)은 중요합니다;
    그것은 npm으로 하여금 *typings* 명령어에서 `--` 우측에 있는 모든 인자들을 전달하게 합니다. 
    
    typings [github](https://github.com/typings/typings/blob/master/README.md)에서 *typings* 도구의 기능에 관해 좀 더 알아보시기 바랍니다.
