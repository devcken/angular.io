include ../_util-fns

:marked
  우리 모두는 로그인, 도움 요청 서브밋, 주문 신청, 항공 예약, 회의 스케줄 잡기 등을 위한 폼을 사용해 왔으며,
  셀 수 없는 다른 데이터 엔트리 과정을 실행 했을 겁니다.
  폼은 비지니스 애플리케이션가 크게 의지하는 부분입니다.

  어떤 노련한 웹 개발자는 아주 쉽게 HTML 폼을 올바른 태그와 함께 놓을 수 있을 겁니다.
  폼 너머의 워크플로우를 따라 사용자를 효과적이고 능률적으로 가이드하는, 응집력있는 데이터 엔트리 경험을 만드는 것은 꽤나 어려운 일이 될 겁니다.

  *그것은* 솔직히 말해서 이 챕터 영역 밖에 있는 디자인 스킬에 대한 것입니다.

  그것은 Angular 폼에 대한 이 챕터에서 다루려고 하는 ... **양방향 데이터 바인딩, 변경 추적, 검증 그리고 오류 다루기**를 위한 프레임워크 지원을 필요로 하기도 합니다. 

  우리는 처음부터 한번에 하나씩 간단한 폼을 만들어볼 겁니다. 그러면 다음 내용들을 배우게 될 겁니다

  - 컴포넌트와 템플릿으로 Angular 폼을 빌드하기

  - 입력 컨트롤에서 값을 읽거나 쓰기 위해 `[(ngModel)]` 문법으로 양방향 바인딩하기

  - 변경 상태 추적과 폼 컨트롤 검증을 위해 `ngControl` 사용하기

  - `ngControl`이 폼 컨트롤에 추가하는 특별한 CSS 클래스와 강력한 시각적 피드백을 제공하기 위해 그 클래스들을 사용하기 위한 방법

  - 사용자에게 검증 오류와 폼 컨트롤 활성/비활성화 디스플레이하기

  - 템플릿 참조 변수로 컨트롤 사이에 정보 공유하기
  
  [라이브 예제](/resources/live-examples/forms/ts/plnkr.html)
.l-main-section
:marked
  ## 템플릿 주도 폼

  우리 중 많은 이들이 이 챕터에서 설명하고 있는 폼에 특성화된 디렉티비들과 기술들로 Angular의 [템플릿 문법](./template-syntax.html)으로 템플릿을 작성하여 폼을 만들 겁니다.
.l-sub-section
  :marked
    그것이 폼을 만드는 유일한 방법은 아니지만 이 챕터에서 다루게 될 방법입니다.
:marked
  우리는 Angular 템플릿으로 우리가 필요로 하는 거의 대부분의 폼을 만들 수 있습니다 &mdash; 로그인 폼, 연락처 폼 ... 어떤 비지니스 폼이든 말이죠.
  독창적인 컨트롤을 놓을 수도 있고, 데이터를 컨트롤을 바인딩하고, 검증 규칙을 지정하여 검증 오류를 디스플레이하기도 하고,
  조건에 따라 특정 컨트롤을 활성화하거나 비활성화하고, 빌트인된 시각적 피드백을 일으키기기도 하는 등 여러 가지 일들을 할 수 있습니다.  
  
  Angular는 우리가 씨름해왔던 자주 반복되고, 틀에 박힌 많은 일들을 대신 다루기 때문에 그런 일들은 매우 쉬워질 겁니다.
  
  우리는 다음의 템플릿 주도 폼을 만들기 위해 논의하고 배워볼 것입니다:

figure.image-display
  img(src="/resources/images/devguide/forms/hero-form-1.png" width="400px" alt="Clean Form")

:marked
  *영웅 고용 에이전시*에서 우리의 훈련소 내 영웅들에 관한 개인 정보를 유지관리하기 위해 이 폼을 사용할 겁니다.
  모든 영웅들은 일을 필요로 하죠. 그것은 위기 상황에 올바른 영웅을 배치하기 위한 우리 회사의 미션입니다!

  폼의 세 필드 중 두 개는 필수입니다. 필수 필드는 쉽게 알아보도록 하기 위해 왼쪽에 녹색 막대를 두었습니다.

  영웅 이름을 삭제하면, 폼은 주의를 주기 위한 스타일로 검증 오류를 디스플레이합니다:

figure.image-display
  img(src="/resources/images/devguide/forms/hero-form-2.png" width="400px" alt="Invalid, Name Required")

:marked
  서브밋 버튼이 비활성화되어 있고 입력 컨트롤 왼편의 "필수" 막대기가 녹색에서 빨간 색으로 변경된 것을 기억하시기 바랍니다.

.l-sub-section
  p 우리는 표준 CSS로 "필수" 막대기의 색상과 위치를 커스터마이징할 겁니다.

:marked
  우리는 다음의 작은 단계를 따라 이런 폼을 만들어 볼 겁니다

  1. `Hero`라는 모델 클래스를 만듭니다
  1. 폼을 조정하는 컴포넌트를 만듭니다
  1. 초기 폼 레이아웃으로 템플릿을 만듭니다
  1. 각각의 폼 입력 컨트롤을 `ngModel`이라는 양방향 데이터 바인딩 문법으로 데이터 프로퍼티들과 바인딩합니다
  1. 각각의 폼 입력 컨트롤에 **ngControl** 디렉티브를 추가합니다
  1. 시각적 피드백을 주기 위해 커스텀 CSS를 추가합니다
  1. 검증 오류 메시지를 보여주거나 숨깁니다
  1. **ngSubmit**으로 폼 서브밋을 다룹니다
  1. 폼이 유효해질 때까지 폼의 서브밋 버튼을 비활성화합니다

:marked
  ## 설치
  새로운 프로젝트 폴더(`angular2-forms`)를 만들고 [퀵스타트](../quickstart.html)를 따라 진행합니다.

include ../_quickstart_repo
:marked
  ## 영웅 모델 클래스를 만듭니다

  사용자가 폼 데이터를 입력하면 해당 변경 사항을 가로채 모델의 인스턴스를 갱신하도록 합니다.
  모델이 어떤 모습을 가지는지 알기 전까지는 폼을 배치할 수 없습니다. 

  모델은 애플리케이션의 중요 내용에 관한 사실들을 담고 있는 "프로퍼티 가방"처럼 간단합니다.
  이 얘기는 `Hero` 클래스가 세 가지의 필수 필드(`id`, `name`, `power`)와 한 개의 부가 필드(`alterEgo`)를 가지고 있다는 것을 잘 설명해줍니다. 

  `hero.ts`라는 새로운 파일을 앱 폴더 내에 만들고 다음의 클래스 정의를 작성합니다:

+makeExample('forms/ts/app/hero.ts', null, 'app/hero.ts')

:marked
  요구사항도 별로 없고 동작도 없는 아무것도 하지 않는 모델입니다. 우리의 데모를 위해서는 아주 완벽하죠.

  TypeScript 컴파일러는 각각의 `public`한 생성자 파라메터를 위한 public 필드를 생성하고 파라메터의 값을 새로운 영웅이 만들어질 때 자동으로 필드에 할당합니다.
  
  `alterEgo`는 부가적인 정보로, 생성자로 보아 그것을 생략하고 있습니다; `alterEgo?`에서 (?)를 기억하시기 바랍니다. 

  우리는 다음과 같이 새로운 영웅을 만들 수 있습니다:
code-example(format="").
  let myHero =  new Hero(42, 'SkyDog', 
                         'Fetch any object at any distance', 'Leslie Rollover');
  console.log('My hero is called ' + myHero.name); // "My hero is called SkyDog"
:marked

.l-main-section
:marked
  ## 폼 컴포넌트 생성

  Angular 폼은 두 개의 부분으로 이루어집니다: HTML 기반의 템플릿과 데이터와 사용자 상호작용을 다루기 위한 컴포넌트로 말이죠. 

  컴포넌트부터 시작할건데, 그 이유는 간단히 말해 영웅 편집기가 할 수 있는 것을 컴포넌트가 나타내기 때문이죠.

  `hero-form.component.ts`라는 새로운 파일을 만들고 다음의 정의를 작성해주세요:

+makeExample('forms/ts/app/hero-form.component.ts', 'first', 'app/hero-form.component.ts')

:marked
  이 컴포넌트에는 특별한 만한 것이 없습니다. 폼 특성화된 것도 없고, 여태 우리가 작성해봤던 다른 어떤 컴포넌트와도 구별할 만한 점은 없습니다.

  이 컴포넌트를 이해하는데에는 우리가 이전 챕터에서 배웠던 Angular 2의 컨셉만 있으면 됩니다.

  1. 늘 그래왔듯이 Angular 라이브러리에서 `Component` 데코레이터를 임포트합니다.

  1. "hero-form"이라는 `@Component` 셀렉터는 값은 우리가 `<hero-form>` 이라는 태그로 상위 템플릿 내에 이 폼을 놓을 수 있다는 걸 의미합니다.

  1. `templateUrl` 프로퍼티는 `hero-form.component.html`라고 불리는 템플릿 HTML을 위해 분리된 파일들을 가르킵니다.

  1. 데모에 걸맞게 `model`과 `powers`라고 하는 더미 데이터를 정의했습니다.
  언젠가는 실제 데이터를 가져오고 저장하기 위한 데이터 서비스를 주입하거나 상위 컴포넌트에 바인딩하기 위한 
  [입력과 출력](./template-syntax.html#inputs-outputs)으로써 이 프로퍼티들을 노출시킬 수 있을 겁니다.
  지금 당장에는 이런 것들을 할 것은 아니고 이런 미래의 변경 사항들이 폼에 영향을 줘서는 안됩니다.

  1. 마지막에 `diagnostic` 프로퍼티에서 모델의 JSON 출력을 반환하도록 했습니다.
  이것은 우리가 개발 중에 무엇을 하고 있는지 살펴보는데 도움을 줄 겁니다; 나중에 이것을 제거하기 위해 클린업 노트를 남겨두었습니다.

  왜 개발자 가이드 내 어디서든지 해왔던 데로 컴포넌트 파일 내에서 인라인 템플릿을 작성하지 않았을까요?

  모든 경우에 대해 “올바른” 대답은 없습니다.
  템플릿이 작다면 인라인 템플릿이 더 좋을 겁니다.
  대부분의 폼 템플릿은 작지 않을 겁니다.
  TypeScript와 JavaScript 파일들은 일반적으로 HTML로 된 아주 긴 내용을 작성하거나 읽기 위한 최적의 공간은 아니며 HTML과 코드가
  섞여 있는 파일을 위해 적절한 도움을 주는 에디터들도 드묾니다.
  더구나 여기에서 처럼 깔끔하고 분명한 목적을 가진 작은 파일이 더 좋습니다.

  HTML 템플릿을 두기 위한 최적의 공간을 찾아냈습니다.
  이제 그 템플릿을 작성할 시간입니다. 그 전에 뒤로 되돌아가 ` app.component.ts`를 새로운 `HeroFormComponent`를 사용하도록 수정해보겠습니다.

.l-main-section
:marked
  ## *app.component.ts* 수정

  `app.component.ts`는 애플리케이션의 최상위 컴포넌트입니다. 그것은 새로운 `HeroFormComponent`를 호스트할 겁니다.

  다음의 "퀵스타트" 버전의 내용을 교체해주세요:
+makeExample('forms/ts/app/app.component.ts', null, 'app/app.component.ts')

:marked
.l-sub-section
  :marked
    세 가지 변경 사항이 있습니다:

    1. 새로운 `HeroFormComponent`를 임포트했습니다.

    1. `template`는 컴포넌트의 `selector` 프로퍼티에 의해 인지되는 새로운 요소 태그입니다.

    1. `directives` 배열은 Angular에게 템플릿이 그 자신도 디렉티브인(모든 컴포넌트가 그러므로) `HeroFormComponent`에 의존하고 있다는 것을 알려줍니다.

.l-main-section
:marked
  ## 초기 HTML 폼 템플릿 만들기
  
  `hero-form.component.html`라고 부르는 새로운 템플릿 파일을 만들고 다음 정의를 작성하시기 바랍니다:

+makeExample('forms/ts/app/hero-form.component.html', 'start', 'app/hero-form.component.html')

:marked
  이건 그냥 평범한 HTML 5입니다. 우리는 두 개의 `Hero` 필드인, `name` 그리고 `alterEgo`를 보여주고 있고,
  입력 박스 내에서 그것들에 대한 사용자 입력을 가능하게 했습니다.

  *Name* `<input>` 컨트롤은 HTML5의 `required` 어트리뷰트를 가지고 있습니다;
  *Alter Ego* `<input>` 컨트롤은 그렇지 않은데 `alterEgo`는 부가 정보기 때문이죠.

  아래 쪽에 몇 가지 클래스를 가진 *Submit* 버튼도 볼 수 있습니다.

  **우리는 아직 Angular를 사용하고 있지 않습니다.** 바인딩도, 어떤 디렉티브도 없습니다. 그냥 레이아웃만 있죠.
  
  `container`, `form-group`, `form-control`, 그리고 `btn` 클래스들은 
  [트위터 부트스트랩](http://getbootstrap.com/css/)에서 가져온겁니다. 
  이는 순수하게 꾸미기 위한 의도입니다.
  폼을 잘 꾸미기 위해 부트스트랩을 사용하고 있는 것입니다.
  이 정도의 작은 스타일도 없다면 폼이 어떨까요!
  
.callout.is-important
  header Angular Forms Do Not Require A Style Library
  :marked
    Angular는 `container`, `form-group`, `form-control`, 그리고 `btn` 혹은 어떤 외부 라이브러리의 스타일도 사용하지 않습니다.  
    Angular 앱은 어떤 CSS 라이브러리든지 사용할 수 있지만 그렇지 않을 수도 있습니다.

:marked
  스타일시트를 추가해보죠.

ol
  li 터미널 윈도우를 열고 애플리케이션 루트 폴더에서 다음 명령어를 입력하세요:
    code-example(language="html" escape="html").
      npm install bootstrap --save
  li <code>index.html</code>을 열고 <code>&lt;head></code>에 다음 링크를 추가해주세요.
      +makeExample('forms/ts/index.html', 'bootstrap')(format=".")
:marked
.l-main-section
:marked
  ## ***ngFor**로 초능력 추가하기
  우리의 영웅은 에이전시가 승인한 능력의 고정 목록에서 한 가지 초능력을 선택하게 됩니다.
  우리는 그 목록을 내부적으로 가지고 있습니다(`HeroFormComponent`에서).

  폼에 `select`를 추가하고 option들을, 우리가 전에 [데이터 디스플레이하기](./displaying-data.html)에서 봤었던 기술인
  `ngFor`을 사용해 `powers` 목록에 바인딩할 겁니다.

  *Alter Ego* 그룹 *바로 밑에* 다음의 HTML을 추가해주세요.
+makeExample('forms/ts/app/hero-form.component.html', 'powers', 'app/hero-form.component.html (excerpt)')(format=".")

:marked
  We are repeating the `<options>` tag for each power in the list of Powers.
  The `p` template input variable is a different power in each iteration;
  we display its name using the interpolation syntax with the double-curly-braces.

<a id="ngModel"></a>
.l-main-section
:marked
  ## **ngModel**로 양방향 데이터 바인딩하기
  지금 앱을 실행하면 좀 실망할 겁니다.

figure.image-display
  img(src="/resources/images/devguide/forms/hero-form-3.png" width="400px" alt="Early form with no binding")
:marked
  영웅 데이터를 볼 수 없는데 아직 `Hero`에 바인딩하지 않았기 때문이죠.
  앞선 챕터들에서 어떻게 하는지 배웠습니다.
  [데이터 디스플레이하기](./displaying-data.html)에서는 프로퍼티 바인딩을 배웠습니다.
  [사용자 입력](./user-input.html)은 이벤트 바인딩으로 DOM 이벤트를 리스닝하는 법과
  디스플레이되고 있는 값으로 컴포넌트 프로퍼티를 갱신하는 방법을 봤습니다.

  이제 우리는 동시에 디스플레이하고 리스닝하며 값을 추출해야 합니다. 

  우리의 폼에 앞서 알아봤던 기술들을 사용할 수 있습니다.
  대신 새로운 걸 소개하고자 합니다. 폼을 모델에 매우 쉽게 바인딩해주는 `[(ngModel)]` 문법을 말이죠.

  "Name"에 대한 `<input>` 태그를 찾아 다음과 같이 수정해주세요

+makeExample('forms/ts/app/hero-form.component.html', 'ngModel-1','app/hero-form.component.html (excerpt)')(format=".")

.l-sub-section
  :marked
    input 태그 뒤에 진단할 수 있는 어구 삽입을 붙여두었기 때문에 변경되는 내용을 바로 바로 볼 수 있습니다.
    완료하고 나면 그것을 없애고자 노트를 남겨 두었습니다.

:marked
  이 바인딩 문법에 초점을 맞춰보죠: `[(ngModel)]="..."`.

  지금 바로 앱을 실행하고 *Name* 입력 박스에 문자를 추가하거나 삭제하려고 뭔가를 타이핑하기 시작했다면,
  어구 삽입 텍스트에 그 내용이 그대로 반영되는 것을 볼 수 있을 겁니다.
  이렇게 말이죠.
figure.image-display
  img(src="/resources/images/devguide/forms/ng-model-in-action.png" width="400px" alt="ngModel in action")
:marked
  그 진단 결과가 입력 박스에서 모델로 혹은 그 반대로 값이 전달된다는 증거가 됩니다.
  **그게 바로 양방향 데이터 바인딩입니다!**

  유사한 `[(ngModel)]`을 *Alter Ego*과 *Hero Power*에 바인딩해보죠.
  입력 박스 바인딩 메시지를 버리고 위 쪽에 컴포넌트의 `diagnostic` 프로퍼티에 바인딩을 추가할 겁니다.  
  그런 뒤에 양방향 데이터 바인딩이 *전체 Hero 모델*에 대해 잘 동작하는지 확인할 수 있습니다.

  수정하고 나면 우리 폼의 핵심부는 다음과 같이 세 개의 `[(ngModel)]` 바인딩을 가지고 있을 겁니다.

+makeExample('forms/ts/app/hero-form.component.html', 'ngModel-2', 'app/hero-form.component.html (excerpt)')

:marked
  앱을 지금 즉시 실행하고 Hero 모델의 모든 프로퍼티를 변경한다면, 폼은 다음과 같이 디스플레이할 겁니다:
figure.image-display
  img(src="/resources/images/devguide/forms/ng-model-in-action-2.png" width="400px" alt="ngModel in super action")
:marked
  폼의 상단 근처에 있는 diagnostic은 변경 전체가 모델에 반영된다는 것을 확인시켜줍니다.

  목적을 달성했으므로 `{{diagnostic}}` 바인딩을 **삭제해주세요**.

.l-sub-section
  :marked
    ### [(ngModel)]의 내부
    *이 섹션은 [(ngModel)]에 대해 자세히 알아보는 부가적인 섹션입니다. 관심 없다면? 무시하고 진행하세요!*
    
    바인딩 문법에서의 구두법, <span style="font-family:courier"><b>[()]</b></span>, 은 어떤 일이 벌어질지에 대한 좋은 실마리가 됩니다.

    프로퍼티 바인딩에서, 값은 모델에서 스크린 상의 대상 프로퍼티로 전달됩니다.
    이름 주변을 대괄호, <span style="font-family:courier"><b>[]</b></span>, 로 감싸고 있는 프로퍼티를 우리는 대상 프로퍼티라고 인지할 수 있습니다.
    이것은 **모델에서 뷰를 향하는** 단방향 데이터 바인딩입니다.

    이벤트 바인딩에서, 값은 스크린 상의 대상 프로퍼티로부터 모델로 전달됩니다.
    이름 주변을 소괄호, <span style="font-family:courier"><b>()</b></span>, 로 감싸고 있는 프로퍼티를 우리는 대상 프로퍼티라고 인지할 수 있습니다.
    이것은 반대 방향인 **뷰에서 모델을 향하는** 단방향 데이터 바인딩입니다.

    양방향 데이터 바인딩과 **데이터의 양방향 흐름**을 표명하기 위해 <span style="font-family:courier"><b>[()]</b></span>와 같이 구두법을 혼합한 Angular의 결정에 놀라지 마세요.

    사실, 우리는 `NgModel` 바인딩을 다음과 같이 "Name" `<input>` 바인딩을 다시 작성함으로써 두 개의 개별적인 모드로 쪼갤 수 있습니다:
  +makeExample('forms/ts/app/hero-form.component.html', 'ngModel-3','app/hero-form.component.html (excerpt)')(format=".")

  :marked
    <br>프로퍼티 바인딩은 친숙하게 느껴지지만, 이벤트 바인딩은 조금 이질적일 수도 있습니다.

    `ngModelChange`는 `<input>` 요소의 이벤트가 아닙니다.
    실제로는 `NgModel` 디렉티브의 이벤트 프로퍼티입니다.
    Angular가 폼의 <span style="font-family:courier">[(x)]</span> 내에서 바인딩 대상을 찾으면,
    `x` 입력 프로퍼티와 `xChange` 출력 프로퍼티에 가지는 `x` 디렉티브가 있다고 예상합니다.

    또 다른 괴상한 것은 `model.name = $event`라고 하는 템플릿 표현식입니다.
    DOM 이벤트로부터 전달되는 `$event` 객체를 참조해왔습니다.
    `ngModelChange` 프로퍼티는 DOM 이벤트를 만들어내지 않습니다; 그건 이벤트가 발생할 때
    입력 박스 값을 반환하는 Angular의 `EventEmitter` 프로퍼티입니다 &mdash; 엄밀히 말하자면 모델의 `name` 프로퍼티에 할당되는 것입니다.

    알게 되서 좋지만 실용적일까요? 우리는 거의 항상 `[(ngModel)]`을 선호합니다.
    키가 눌리는 debounce 혹은 throttle과 같은 이벤트 핸들링 내에서 특별한 무언가를 해야할 경우 바인딩을 분리하게 될 겁니다.

    `NgModel`과 다른 템플릿 문법을 좀 더 알아보려면 [템플릿 문법](./template-syntax.html) 챕터를 살펴보시기 바랍니다.

.l-main-section
:marked
  ## **ngControl**를 이용한 변경상태와 유효성 추적

  폼은 그저 데이터 바인딩만 있는게 아닙니다. 폼에서 컨트롤의 상태 또한 알고 싶을 겁니다.

  `ngControl`을 설정하여, 사용자가 컨트롤을 터치했는지, 값이 변경됐는지 혹은 값이 유효하지 않은지에 대해서 알려줄 수 있는 디렉티비를 만들 수 있습니다.

  이 디렉티브는 그저 상태를 추적하지는 않습니다; 위에서 나열했던 집합 내에 있는 특별한 Angular CSS 클래스들로 컨트롤을 갱신합니다.
  컨트롤의 외관을 변경하고 메시지를 보여주고 감추게 하기 위해 그 클래스 이름들을 가져올 수 있습니다.

  그런 효과들을 곧 경험하게 될 겁니다.
  지금은, *Name* 입력 박스로 시작해, **세 개의 폼 컨트롤에 `ngControl`을 추가**해야 합니다.
+makeExample('forms/ts/app/hero-form.component.html', 'ngControl-1', 'app/hero-form.component.html (excerpt)')(format=".")
:marked
  이 특별한 `ngControl`을 우리의 앱에 대해 타당한 "name"에 설정하도록 합니다. 다른 모든 독자적인 값들은 모두 그렇게 할 겁니다.

.l-sub-section
  :marked
    Angular는 내부적으로 `Controls`를 만들고 Angular가 `<form>` 태그에 붙인 `NgForm` 디렉티브를 이용해 `ngControl` 이름들 아래에 그것들을 등록합니다. 
    우리는 이 챕터에서 나중에 [`NgForm`](#ngForm)에 관해 이야기해볼 겁니다.

    템플릿 내 `ngControl` *어트리뷰트*는 실제로 [NgControlName](../api/common/NgControlName-directive.html) 디렉티브에 매핑됩니다.
    *그와 동일하지 않은* `NgControl` *추상* 디렉티브도 있습니다.
    우리는 종종 이런 기술적인 차이점을 무시한 채 *NgControl* 디렉티브처럼 좀 더 편리하게(정확하지 않을지라도) `NgControlName`을 참조하곤 합니다. 
    
    자세히 들여다보게 되면서, 이제 양방향 바인딩 문법에서 `ngModel`이 `NgControlName` 디렉티브의 프로퍼티라는 것을 잘 알게 됐으리라 생각합니다. 
    `NgModel` 디렉티브는 이제 더이상 관련되지 않습니다. DOM 요소를 관리하기 위해 오직 하나의 디렉티비만 필요하며 디렉티브가 데이터 바인딩을 다루는 방법 중에서 실질적인 차이점은 없습니다.

.l-main-section
:marked
  ## 시각적인 피드백을 위한 커스텀 CSS 추가

  *NgControl* 디렉티브는 결코 상태를 추적하지 않습니다.
  상태를 반영하는 세 가지 클래스로 컨트롤을 갱신하는게 다 입니다.
  
table
  tr
    th 상태
    th 참일 때의 클래스
    th 거짓일 때의 클래스
  tr
    td 컨트롤이 터치되었는가
    td <code>ng-touched</code>
    td <code>ng-untouched</code>
  tr
    td 컨트롤 값이 변경되었는가
    td <code>ng-dirty</code>
    td <code>ng-pristine</code>
  tr
    td 컨트롤 값이 유효한가
    td <code>ng-valid</code>
    td <code>ng-invalid</code>
:marked
  "Name"이라는 `<input>`태그에 **spy**라는 이름의 임시 [템플릿 참조 변수](./template-syntax.html#ref-vars)를 추가하고
  위 클래스를 디스플레이하기 위해 그 스파이를 사용해보겠습니다.

+makeExample('forms/ts/app/hero-form.component.html', 'ngControl-2','app/hero-form.component.html (excerpt)')(format=".")

:marked
  이제 앱을 실행하고 *Name* 입력 박스에 초점을 맞춰보죠.
  다음 네 가지 단계를 *정확히* 따라주세요

  1. 보기만 하고 만지지는 마세요
  1. 입력 박스 내부를 클릭한 뒤 다시 텍스트 입력 박스 박을 클릭하세요
  1. 이름 끝에 슬래시를 추가합니다
  1. 이름을 지우세요

  이렇게 하면 다음과 같은 결과를 볼 수 있습니다:
figure.image-display
  img(src="/resources/images/devguide/forms/control-state-transitions-anim.gif"  alt="Control State Transition")
:marked
  다음 네 가지 클래스 이름 집합과 그것의 변화 추이를 볼 수 있을 겁니다:
figure.image-display
  img(src="/resources/images/devguide/forms/ng-control-class-changes.png" width="400px" alt="Control State Transitions")

:marked
  (`ng-valid` | `ng-invalid`) 쌍이 가장 흥미로울 겁니다. 데이터가 유효하지 않거나 필수 필드인 걸 알리고 싶을 때 강력한 시각적 신호로 알리고 싶을 겁니다.

  우리는 이 두 가지를 입력 박스 왼편에 색상이 들어간 막대기로 할 수 있다는 것을 깨달았습니다:

figure.image-display
  img(src="/resources/images/devguide/forms/validity-required-indicator.png" width="400px" alt="Invalid Form")

:marked
  `index.html`과 같은 폴더에 추가할 새로운 `forms.css`에 있는 두 개의 스타일이 이런 효과를 보여줍니다.

+makeExample('forms/ts/forms.css',null,'forms.css')(format=".")
:marked
  이 스타일들은 두 개의 Angular 유효성 클래스와 HTML 5의 "required" 어트리뷰트를 셀렉트합니다.

  이 스타일시트를 포함시키기 위해 `index.html`의 `<head>`를 이와 같이 수정합니다.
+makeExample('forms/ts/index.html', 'styles', 'index.html (excerpt)')(format=".")
:marked
  ## 검증 오류 메시지 보여주기와 숨기기

  좀 더 친절한 내용들을 보여줄 수 있을 겁니다.

  "Name" 입력 박스는 필수사항입니다. 그것을 분명히 하기 위해 막대기가 빨간색으로 변할 겁니다. 즉, 그것은 *무언가*가 잘못됐다는 것을 말해주는데,
  무엇이 잘못됐는지, 그와 관련된 것이 무엇인지를 알려주지는 않습니다.
  우리는 좀 더 도움이 될만한 메시지를 보여주기 위해 `ng-invalid` 클래스를 활용할 수 있습니다.

  다음은 사용자가 이름을 삭제했을 때 보여주려는 것입니다:
figure.image-display
  img(src="/resources/images/devguide/forms/name-required-error.png" width="400px" alt="Name required")

:marked
  이런 효과를 만들어내려면 `<input>` 태그를 다음 내용들을 이용해 확장해야 합니다
  1. [템플릿 참조 변수](./template-syntax.html#ref-vars)
  1. 컨트롤이 유효하지 않은 경우에만 디스플레이할 `<div>`근처의 "*is required*" 메시지

  다음은 *name* 입력 박스에서 수정해야 할 내용입니다:
+makeExample('forms/ts/app/hero-form.component.html', 
  'name-with-error-msg', 
  'app/hero-form.component.html (excerpt)')(format=".")
:marked
  템플릿 내부에서 입력 박스의 Angular 컨트롤을 접근하려면 템플릿 참조 변수가 필요합니다.
  우리는 위에서 `name`이라고 하는 변수를 생성하고 그것의 값으로 "ngForm"을 설정했습니다.
.l-sub-section
  :marked
    왜 "ngForm"일까요? 
    디렉티브의 [exportAs](../api/core/DirectiveMetadata-class.html#!#exportAs) 프로퍼티는 디렉티브에 참조 변수를 어떻게 연결해야 할지 Angular에게 알려줍니다.
    `name`을 `ngForm`으로 설정했는데 그 이유는 `NgControlName` 디렉티브의 `exportAs` 프로퍼티가 "ngForm"으로 만들어 줄 것이기 때문입니다. 
    We set `name` to `ngForm` because the `NgControlName` directive's `exportAs` property happens to be "ngForm".
    
    이것은 Angular 폼 패밀리(`NgForm`, `NgModel`, `NgControlName` 그리고 `NgControlGroup`) 내의 *모든* 컨트롤 디렉티브들이 "ngForm"으로써 *exportAs*되고
    요소 태그에 이 디렉티브들 중 오로지 *한 개만* 적용할 수 있습니다.
    정합성 규칙이죠!

    이제 우리는 `name` 컨트롤의 프로퍼티들을 메시지 `<div>` 요소의 `hidden` 프로퍼티에 바인딩하여 "name"의 오류 메시지의 visibility를 조정할 수 있게 되었습니다.
+makeExample('forms/ts/app/hero-form.component.html', 
  'hidden-error-msg', 
  'app/hero-form.component.html (excerpt)')
:marked
  이 예제에서, 컨트롤이 유효하거나 초기상태인 경우 메시지를 숨깁니다; 초기상태가 의미하는 것은 컨트롤이 이 폼에 디스플레이된 이후로 사용자가 값을 변경하지 않았다는 것을 의미합니다. 
  
  이런 사용자 경험은 개발자의 몫입니다. 어떤 이들은 항상 메시지를 보길 원할 수도 있습니다.
  `초기` 상태를 무시한다면, 값이 유효한 경우에만 메시지를 숨길 수 있습니다.
  새로운(비어있는) 영웅 혹은 유효하지 않은 영웅으로 이 컴포넌트에 접근한다면,
  어떤 것도 하지 않는 이상, 오류 메시지를 즉시 보게 될 것입니다.
   
  어떤 이들은 이런 동작이 혼란스럽다고 생각할 수도 있습니다. 그들은 사용자가 유효하지 않은 변경을 일으킨 경우에만 메시지를 보길 원한다는거죠.
  컨트롤이 "초기" 상태일 때에는 메시지를 숨기는 것이 원하는 결과일 겁니다.
  우리가 폼에 [새로운 영웅을 추가](#new-hero)한 경우에 해당 선택의 의미를 깨닫게 될 겁니다.

  영웅의 *Alter Ego*는 부가적인 정보이므로 그것을 그냥 둘 수 있습니다.

  영웅의 *Power* 선택은 필수 정보입니다.
  우리가 원한다면 `<select>`에 동일한 종류의 오류 핸들링을 추가할 수도 있지만,
  선택 박스는 유효한 값에 해당되는 초능력을 이미 선택하고 있기에 반드시 그래야 하는 것은 아닙니다.
  
<a id="new-hero"></a>
<a id="reset"></a>  
.l-main-section
:marked
  ## 영웅 추가와 폼 리셋
  이 폼에서 새로운 영웅을 추가하고 싶다고 해보죠.
  폼 아래쪽의 "New Hero" 버튼을 두고 컴포넌트의 메서드에 클릭 이벤트를 바인드하도록 합니다.
+makeExample('forms/ts/app/hero-form.component.html', 
  'new-hero-button', 
  'app/hero-form.component.html (New Hero button)')
:marked
+makeExample('forms/ts/app/hero-form.component.ts', 
  'new-hero-v1', 
  'app/hero-form.component.ts (New Hero method - v1)')(format=".")
:marked
  애플리케이션을 다시 실행하고 *New Hero* 버튼을 클릭하면 폼이 깨끗해질 겁니다.
  입력 박스의 왼편에 있는 *required* 막대기는 빨간색이 되어 `name`과 `power` 프로퍼티들이 유효하지 않음을 알려줄 겁니다.
  필수 필스니까 이런 동작은 이해할 만한 것들입니다.
  오류 메시지들은 숨겨져 있는데 폼이 초기 상태이기 때문이죠; 우린 아직 아무것도 변경하지 않았으니까요. 
  
  이름을 입력하고 *New Hero*를 다시 클릭합니다.
  이번에는 오류 메시지를 보게 될겁니다! 왜 그렇죠? 새로운(비어있는) 영웅을 디스플레이할 경우 그런 것을 원했던 건 아닌데 말이죠.
  
  브라우저 도구 내에서 요소를 검사해보면 그 *name* 입력 박스가 더 이상 초기 상태가 아니라는 것을 볼 수 있습니다.
  영웅을 대체하는 것은 컨트롤의 *초기 상태를 복원하지 않습니다*.
.l-sub-section
  :marked
    보아하니, Angular는 전체 영웅을 대체하는 것과 `name` 프로퍼티를 프로그램으로 깨끗하게 치우는 것의 차이를 구별하지 못한다는 것을 알 수 있습니다.
    Angular는 추정할 수는 없고 현재의 어지럽혀진 상태의 컨트롤을 그대로 둔다는 것이죠.
:marked
  우리는 작은 속임수를 이용해 수동으로 폼 컨트롤을 리셋해야만 합니다.
  컴포넌트에 `true`로 초기화된 `active`라는 플래그를 추가합니다.
  새로운 영웅을 추가할 때, `active`를 거짓으로 토글한 뒤 빠른 `setTimeout`을 이용해 즉시 참으로 되돌릴 겁니다.
+makeExample('forms/ts/app/hero-form.component.ts', 
  'new-hero', 
  'app/hero-form.component.ts (New Hero method - final)')(format=".")
:marked
  그런 뒤 폼 요소의 이 `active` 플래그에 바인딩하도록 합니다.
+makeExample('forms/ts/app/hero-form.component.html', 
  'form-active', 
  'app/hero-form.component.html (Form tag)')
:marked
  `NgIf`를 `active` 플래그에 바인딩해, "New Hero" 버튼 클릭시 DOM으로부터 폼을 제거하고 눈 깜빡할 사이에 다시 만들도록 했습니다. 
  새로 만들어진 폼은 초기상태에 놓이게 되겠죠. 오류 메시지는 감춰질 겁니다.
.l-sub-section
  :marked
    이것은 좀 더 적합한 폼 리셋 기능 이전에 사용할 임시 대체 수단입니다.
:marked
  
.l-main-section
:marked
  ## **ngSubmit**으로 폼을 서브밋하기
  사용자는 폼 내부를 채워넣은 다음에 서브밋할 수 있어야 합니다.
  폼 아래 쪽의 서브밋 버튼은 그 자체로는 아무것도 하지 않지만 그것의 타입(`type="submit"`) 덕분에 폼 서브밋을 일으키게 됩니다.

  "폼 서브밋"은 지금 현재로썬 유용하지 않습니다.
  그걸 유용하게 만들려면, 또 다른 Angular 디렉티브인 `NgSubmit`으로 `<form>` 태그를 갱신해야 하며 그것을 이벤트 바인딩으로 `HeroFormComponent.submit()` 메서드에 바인딩해야 합니다.
+makeExample('forms/ts/app/hero-form.component.html', 'ngSubmit')(format=".")

:marked
  우리는 결국에는 무언가 특별한 곳을 빠져들었습니다!
  우리는 **`#heroForm`**라고 하는 템플릿 참조 변수를 정의했었고 그것을 "ngForm"이라는 값으로 초기화했습니다.

  변수 `heroForm`은 이제 전체적으로 폼을 운영하는 `NgForm` 디렉티브를 참조합니다.
<a id="ngForm"></a>
.l-sub-section
  :marked
    ### NgForm 디렉티브
    `NgForm` 디렉티브는 무엇일까요? [NgForm](../api/common/NgForm-directive.html) 디렉티브를 추가한 적이 없습니다!
    
    Angular가 했죠. Angular는 `NgForm` 디렉티브를 `<form>` 태그에 자동으로 `NgForm` 디렉티브를 만들고 붙입니다.

    `NgForm` 디렉티브는 `form` 요소의 부족한 부분들을 부가적인 기능들로 채워줍니다.
    그것은 `ngControl` 어트리뷰트로 요소에 대해 만들었던 컨트롤들을 가지고 있으며 유효성을 포함하여 그 컨트롤들의 프로퍼티들을 모니터링합니다.
    그것은 *모든 포함된 컨트롤들이* 유효한 경우에만 참이 되는 자체의 `valid` 프로퍼티도 가지고 있습니다.
    
:marked
  템플릿 뒷부분에서 버튼의 `disabled` 프로퍼티를 `heroForm` 변수를 통한 폼에 대한 전체적인 유효성에 바인딩합니다.
  다음은 그에 대한 마크업의 일부분입니다:  
+makeExample('forms/ts/app/hero-form.component.html', 'submit-button')
:marked
  애플리케이션을 다시 실행해보세요. 폼이 유효한 상태로 열리고 버튼이 활성화되어 있을 겁니다.

  이제 *이름*을 삭제해보세요. 우리는 이전에 오류 메시지 내에 적어두었던 "name required"라는 규칙을 위반했습니다.
  그리고 이제 서비밋 버튼이 비활성화될 것입니다.

  별로 놀랍지 않나요? 잠깐 생각해보세요.
  Angular의 도움없이 버튼의 활성화/비활성화 상태를 폼의 유효성과 묶으려면 어떤 방법이 있을까요? 

  우리에겐, 다음 내용만큼이나 간단했습니다
  1. (강화된) 폼 요소 상에 템플릿 참조 변수를 정의합니다 
  2. 약 50 라인을 제거하고 버튼 내의 해당 변수를 참조합니다

.l-main-section
:marked
  ## 두 개의 폼 영역을 토글하기(부가적인 내용)
  폼을 서브밋하는 것은 지금으로써는 무지막지하게 드라마틱하지 않습니다.
.l-sub-section
  :marked
    데모에는 놀랄만한 내용은 없습니다.
    정직해지자면, 이 신나는 내용들이 폼에 관해 새로운 것을 알려주지는 않습니다.
    그러니 이것은 최근에 각광받는 바인딩 기술들을 연습해볼 수 있는 기회입니다.
    관심 없다면, 챕터의 결론으로 건너띌 수 있습니다. 문제될 건 없습니다.
:marked
  무언가 좀 더 눈에 띄게 시각적으로 만들어보죠.
  데이터 엔트리 데이터를 감추고 그외의 다른 것들을 디스플레이해보도록 하죠.

  `<div>` 내로 폼을 래핑하는 것으로 시작해, `hidden` 프로퍼티를 `HeroFormComponent.submitted` 프로퍼티에 바인딩하겠습니다.

+makeExample('forms/ts/app/hero-form.component.html', 'edit-div', 'app/hero-form.component.html (excerpt)')(format=".")

:marked
  메인 폼은 시작부터 눈에 보이는데 우리가 폼을 서브밋하기 전까지는 `submitted` 프로퍼티가 거짓이기 때문이죠.
  다음 예에서 볼 수 있는 `HeroFormComponent`의 일부분이 이를 알려줍니다:

+makeExample('forms/ts/app/hero-form.component.ts', 'submitted')(format=".")

:marked
  우리가 서브밋 버튼을 클릭하게 되면 `submitted` 플래그는 참이 될 것이고 폼은 계획한데로 사라질겁니다.

  이제 우리는 폼이 서브밋된 상태일 때 무언가를 보여줘야 합니다.
  우리가 막 작성했던 `<div>` 래퍼 아래에 다음 HTML 블록을 추가해주세요:
+makeExample('forms/ts/app/hero-form.component.html', 'submitted', 'app/hero-form.component.html (excerpt)')

:marked
  우리의 영웅이 어구 삽입 바인딩을 이용한 읽기 전용의 형태로 나오게 됐습니다.
  이 약간의 HTML은 컴포넌트가 서브밋된 상태인 경우에만 나타납니다.

  우리는 `submitted` 플래그를 초기 상태로 만드는 표현식에 클릭 이벤트가 바인딩된 Edit 버튼을 추가했습니다.
  
  그 버튼을 클릭하면, 이 블록은 사라지게 되고 수정 가능한 폼이 다시 나타나게 됩니다.

  그것은 현재 우리가 할 수 있는 것 중 꽤나 극적인 것입니다.

.l-main-section
:marked
  ## 결론

  이 챕터에서 다룬 Angular 2 폼은 데이터 수정, 요효성 검증 그리고 그이상의 것들에 대한 지원을 제공하기 위한 다음의 프레임워크 기능들의 장점을 가져다줍니다:

  - Angular HTML 폼 템플릿.
  - `Component` 데코레이터를 이용한 폼 컴포넌트 클래스.
  - 폼 서브밋을 다루기 위한 `ngSubmit` 디렉티브
  - `#heroForm`, `#name`, `#alter-ego` 그리고 `#power`와 같은 템플릿 참조 변수
  - 양방향 데이터 바인딩을 위한 `[(ngModel)]` 문법
  - 유효성 검증과 폼 요소 변경 추적을 위한 `ngControlName` 디렉티브
  - 컨트롤이 유효한지 검사하고 오류 메시지를 보여주거나 숨기기 위한 입력 컨트롤 상의 참조 변수의 `valid` 프로퍼티.
  - `NgForm` 유효성에 바인딩하여 서브밋 버튼의 활성 상태 컨트롤하기.
  - 유효하지 않은 컨트롤에 관해 사용자에게 시각적 피드백을 제공하는 커스텀 CSS 클래스들.

  최종적인 프로젝트 폴더 구조는 다음과 같습니다:
.filetree
  .file angular2-forms
  .children
    .file app
    .children
      .file app.component.ts
      .file hero.ts
      .file hero-form.component.html
      .file hero-form.component.ts
      .file main.ts
    .file node_modules ...
    .file typings ...      
    .file index.html
    .file package.json
    .file tsconfig.json
    .file typings.json
:marked
  Here’s the final version of the source:

+makeTabs(
  `forms/ts/app/hero-form.component.ts,
   forms/ts/app/hero-form.component.html,
   forms/ts/app/hero.ts,
   forms/ts/app/app.component.ts,
   forms/ts/app/main.ts,   
   forms/ts/index.html,
   forms/ts/forms.css`,
  'final, final,,,,,',
  `hero-form.component.ts,
   hero-form.component.html,   
   hero.ts,
   app.component.ts,
   main.ts,
   index.html,
   forms.css`)
:marked
