include ../_util-fns

// #docregion intro
:marked
  **의존성 주입**은 중요한 애플리케이션 디자인 패턴입니다.
  Angular는 자신만의 의존성 주입 프레임워크를 가지고 있으며, 실제로 해당 프레임워크 없이는 Angular 애플리케이션을 빌드하는 것이 불가능합니다.
  의존성 프레임워크는 거의 모든이들이 그냥 _DI_라고 부를 정도로 꽤 널리 사용되고 있습니다.

  이 챕터에서 우리는 DI가 무엇인지 그리고 우리가 그걸 왜 사용해야 하는지에 대해서 배워볼 겁니다.
  그런 뒤에 Angular 앱에서 [의존성 주입을 어떻게 사용해야 하는지](#angular-di)에 대해서 배워보도록 하겠습니다.
// #enddocregion intro
:marked
  [라이브 예제](/resources/live-examples/dependency-injection/ts/plnkr.html)를 실행해보세요.
// #docregion why-1
<a id="why-di"></a>
.l-main-section
:marked
  ## 왜 의존성 주입일까요?

  다음 코드로부터 시작해보죠.
// #enddocregion why-1
+makeExample('dependency-injection/ts/app/car/car-no-di.ts', 'car', 'app/car/car.ts (without DI)')
// #docregion why-2
- var lang = current.path[1]
- var prefix = lang == 'dart' ? '' : 'this.'
:marked
  `Car`는 생성자 내에서 필요로 하는 모든 것을 생성합니다.
  문제가 뭐죠?

  `Car` 클래스가 불안정하고, 유연하지 못하며 테스트하기 어렵다는게 문제입니다.

  `Car`는 엔진과 타이어를 필요로 합니다. `Car` 생성자는, 그것들을 요구하는 대신에, 매우 특화된 클래스인 `Engine` 그리고 `Tires`로부터
  "new 생성"으로 그것들의 인스턴스를 만들어 냅니다.

  `Engine` 클래스가 자신의 생성자에서 파라메터를 필요로 한다면 어떨까요?
  `Car`는 `#{prefix}engine = new Engine(theNewParameter)`와 같이 수정하기 전까지는 오류를 발생시키는 상태로 남아있을 겁니다.
  처음에 `Car`를 작성했을 때는 `Engine` 생성자의 파라메터에 관해서는 전혀 신경쓰지 않았습니다. 
  지금은 그런 것들을 걱정하고 있지는 않습니다.
  그러나 신경써야 할 겁니다. 왜냐하면 `Engine`의 정의가 변경되면 `Car` 클래스가 변해야 하기 때문이죠.
  그런 점들에서 `Car`는 부서지기 쉬운 구조입니다.

  `Car`에 다른 종류의 브랜드의 타이어를 끼고 싶다면 어떨까요? 쉽지 않을 거 같네요. 
  `Tires` 클래스가 어떤 브랜드의 것인지 정할 수 없습니다. 이런 점이 `Car`를 유연하지 못하게 만듭니다.

  각각의 새로운 차는 자신의 엔진을 갖습니다. 다른 차들과는 엔진을 공유할 수 없습니다.
  Right now each new car gets its own engine. It can't share an engine with other cars.
  그것이 자동차 엔진에 있어서는 타당한 이야기지만,
  제조사의 서비스 센터로 연결하기 위한 온보드 무선 연결과 같은, 공유되어야 하는 다른 의존성에 대해 생각해볼 수 있습니다.
  `Car`은 다른 소비자들을 위해 이전에 만들어졌던 서비스를 공유하기 위한 유연성이 결여되어 있습니다.

  우리가 `Car`에 대해 테스트를 작성할 때 숨겨진 의존성에 휘둘리게 됩니다.
  테스트 환경에서 새로운 `Engine`을 생성하는 것이 가능키나 한가요?
  `Engine` 그 자체는 무엇에 의존적일까요? 그 의존성은 또 무엇에 의존하고 있을까요?
  `Engine`의 새로운 인스턴스는 서버에 비동기 호출을 하고 있을지도 모릅니다.
  확실한건 우리가 테스트를 진행하는 동안은 그런 것들이 이루어지지 않길 바란다는 것입니다.

  타이어 압력이 낮을 때 `Car`가 경고 신호등를 깜빡인다면 어떨까요? 
  테스트를 진행하는 동안 타이어를 저기압 상태로 바꾸지 않고, 실제로 경고를 깜빡이는지 어떻게 확인할 수 있을까요?

  우리는 차의 숨겨진 의존성들에 대해서는 제어권이 없습니다.
  의존성을 제어할 수 없을 경우 클래스는 테스트하기 어려워집니다.

  어떻게 하면 `Car`를 좀 더 탄탄하고 유연하면서 테스트 가능하도록 만들 수 있을까요?

  그건 정말로 쉽습니다. `Car` 생성자를 DI를 이용한 버전으로 바꾸면 됩니다:

  <a id="ctor-injection"></a>
// #enddocregion why-2
+makeTabs(
  'dependency-injection/ts/app/car/car.ts, dependency-injection/ts/app/car/car-no-di.ts',
  'car-ctor, car-ctor',
  'app/car/car.ts (excerpt with DI), app/car/car.ts (excerpt without DI)')(format=".")
// #docregion why-3-1
:marked
  어떤 변화가 있죠? 의존성 정의를 생성자로 이동시켰습니다. 
  더 이상 `Car` 클래스는 엔진이나 타이어를 생성하지 않습니다.
  그들을 소비할 뿐이죠.
// #enddocregion why-3-1
// TypeScript only
.l-sub-section
  :marked
    우리는 파라메터와 프로퍼티를 동시에 선언하기 위해 TypeScript의 생성자 문법도 이용합니다.
// #docregion why-3-2
:marked
  이제 생성자로 엔진과 타이어를 전달하여 차를 생성하게 됐습니다.
// #enddocregion why-3-2
- var stylePattern = { otl: /(new Car.*$)/gm };
+makeExample('dependency-injection/ts/app/car/car-creations.ts', 'car-ctor-instantiation', '', stylePattern)(format=".")
// #docregion why-4
:marked
  얼마나 좋은가요?
  엔진과 타이어 의존성의 정의는 `Car` 클래스 자체와 분리되었습니다.
  엔진 혹은 타이어에 대한 일반적인 API 요구사항을 따른다면 얼마든지 원하는데로 어떤 종류의 엔진 혹은 타이어든지 전달할 수 있습니다.

  누군가 `Engine` 클래스를 확장한다면, 그건 `Car`의 문제가 아닙니다.
// #enddocregion why-4
// Must copy the following, due to indented +make.
.l-sub-section
  :marked
    `Car`의 _소비자_는 문제를 가지고 있습니다. 차 생성 코드를 다음과 같이 갱신해야 하기 때문이죠:

  - var stylePattern = { otl: /(new Car.*$)/gm };
  +makeExample('dependency-injection/ts/app/car/car-creations.ts', 'car-ctor-instantiation-with-param', '', stylePattern)(format=".")

  :marked
    중요한 점은 이겁니다: `Car` 자체는 변할 것이 없습니다. 우린 곧 소비자 문제를 다루게 될 겁니다.
// #docregion why-6
:marked
  `Car` 클래스는 테스트하기 더 쉬워졌는데, 우리가 의존성 제어를 완벽히 가지고 있기 때문입니다.
  각각의 테스트 진행하는 동안 어떻게 하면 좋을지를 정확히 하도록 생성자에 가짜 객체(mock)을 전달할 수 있습니다:
// #enddocregion why-6
- var stylePattern = { otl: /(new Car.*$)/gm };
+makeExample('dependency-injection/ts/app/car/car-creations.ts', 'car-ctor-instantiation-with-mocks', '', stylePattern)(format=".")
// #docregion why-7
:marked
  **우리는 방금 의존성 주입이 무엇인지를 배웠습니다**.

  그것은 클래스가 자체적으로 의존성의 인스턴스를 생성하지 않고 외부 소수로부터 전달받도록 하는 코딩 패턴입니다.

  좋아요! 하지만 그 불쌍한 소비자들은 어쩌죠?
  `Car`를 요구하는 소비자들은 이제 누구든지 모두 세 가지 파트를 만들어야 합니다: `Car`, `Engine` 그리고 `Tires`.
  `Car` 클래스는 자신의 문제를 소비자의 역할로 넘겼습니다.
  우리는 이 파트들을 
  We need something that takes care of assembling these parts for us.

  우리는 그렇게 하는 자이언트 클래스를 만들수 있습니다:
// #enddocregion why-7
+makeExample('dependency-injection/ts/app/car/car-factory.ts', null, 'app/car/car-factory.ts')
// #docregion why-8
:marked
  세개의 생성 메서드만 있다면 그리 나쁜 것만은 아닐 겁니다.
  그러나 그것을 유지하는 것은 애플리케이션이 커지면서 점점 더 무거워질겁니다.
  이 팩토리는 서로 의존하는 팩토리 메서드들의 거대한 거미줄처럼 되어갈 것입니다.

  무언가로 주입될 의존성이 어떤 것인지 결정해야 하는 상황없이 우리가 빌드하고 싶은 것들을 간단히 나열할 수만 있다면 좋아지지 않을까요? 

  이것은 의존성 주입 프레임워크가 동작하게 되는 곳입니다.
  프레임워크가 _주입자_라고 불리는 무언가를 가지고 있다고 상상해보세요.
  우리는 그 주입자로 몇 가지 클래스를 등록시키고 해당 주입자는 그것들을 어떻게 생성해야 하는지 알아낼 것입니다.

  `Car`가 필요하다면, 그것을 주입자에게 요구할테고 계속 진행하는데 문제가 없을 겁니다.
// #enddocregion why-8
+makeExample('dependency-injection/ts/app/car/car-injector.ts','injector-call')(format=".")
// #docregion why-9
:marked
  모두에게 좋은 상황입니다. `Car`는 `Engine` 혹은 `Tires`를 생성하는 것에 대해 전혀 알지 못합니다.
  소비자는 `Car`를 생성하는 것에 대해서 전혀 알지 못합니다.
  유지보수를 위한 엄청 거대한 팩토리 클래스를 가지고 있지도 않습니다.
  `Car` 그리고 소비자 모두 그들이 필요로 하는 것과 주입자가 전달해야하는 것들을 요청할 뿐입니다.

  이것이 **의존성 주입 프레임워크**에 대한 모든 것입니다.

  이제 우리는 의존성 주입이 무엇인지 그리고 그것의 이점이 무엇인지를 알게되었습니다.
  Angular에서 그것을 어떻게 구현하는지에 대해서 알아보도록 하죠.
// #enddocregion why-9
// #docregion di-1
<a id="angular-di"></a>
.l-main-section
:marked
  ## Angular 의존성 주입

  Angular는 자체적인 의존성 주입 프레임워크와 함께 제공됩니다. 이 프레임워크는 다른 애플리케이션과 프레임워크의 표준 모듈로써 사용되기도 합니다.

  듣기 좋군요. Angular에서 컴포넌트를 빌드를 할 때 그것의 역할은 무엇일가요?
  한번에 하나씩 알아보도록 하죠

  [영웅들의 여행](../tutorial/)에서 만들었던 `HeroesComponent`의 간소화된 버전으로 시작해보겠습니다.
// #enddocregion di-1
+makeTabs(
  `dependency-injection/ts/app/heroes/heroes.component.1.ts,
  dependency-injection/ts/app/heroes/hero-list.component.1.ts,
  dependency-injection/ts/app/heroes/hero.ts,
  dependency-injection/ts/app/heroes/mock-heroes.ts`,
  'v1,,,',
  `app/heroes/heroes.component.ts,
  app/heroes/hero-list.component.ts,
  app/heroes/hero.ts,
  app/heroes/mock-heroes.ts`)
// #docregion di-2
:marked
  `HeroesComponent`는 *Heroes* 기능 영역의 최상위 컴포넌트입니다.
  그것은 해당 영역의 모든 하위 컴포넌트를 관리합니다.
  가장 필요한 부분만 남긴다면 영웅들의 목록을 디스플레이하는 `HeroListComponent`라는 하나의 하위 컴포넌트만 남을 겁니다.
// #enddocregion di-2
// #docregion di-3
:marked
  지금 당장은, `HeroListComponent`는 다른 파일에 정의되어 있는 인메모리 컬렉션인 `HEROES`로부터 영웅들을 가져옵니다.
  그것은 개발 초기 스테이지에서는 충분하지만 그리 이상적인 것은 아닙니다.
  이 컴포넌트를 테스트하거나 원격 서버로부터 영웅들의 데이터를 가져오려고 한다면 되도록 빨리,
  `heroes`의 구현을 변경하고 `HEROES` 목(mock) 데이터의 다른 모든 사용처를 수정해야만 할 겁니다.

  우리가 영웅 데이터를 가져오는 방법을 숨겨주는 서비스를 만들어보죠.
// #enddocregion di-3

// Unnecessary for Dart
.l-sub-section
  :marked
    서비스 파일 안에 다음의 서비스를 작성해보죠. 이유가 궁금하다면 [이 노트](#forward-ref)를 참고하세요.
+makeExample('dependency-injection/ts/app/heroes/hero.service.1.ts',null, 'app/heroes/hero.service.ts' )
// #docregion di-4
:marked
  `HeroService`는 전처럼 동일한 목(mock) 데이터를 반환하는 `getHeroes` 메서드를 가지고 있는데,
  그것의 사용처에서는 그 내용을 알 필요가 없습니다.
// #enddocregion di-4
// #docregion di-5
.l-sub-section
  :marked
    우리는 이것이 진짜 서비스라고 한적 조차도 없습니다.
    우리가 정말로 원격 서버에서 데이터를 가져오려고 했다면,
    API는 아마도 [ES2015 promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)를
    반환하도록 비동기 처리되어야 할 겁니다.
    또 컴포넌트가 서비스를 사용하는 방법도 다시 구현해야 할 겁니다.
    이것은 일반적으로는 중요하지만 현재의 내용에서는 그렇지 않습니다.
// #enddocregion di-5
// #docregion di-6
:marked
  서비스는 Angular2에서 클래스일뿐 아무것도 아닙니다.
  Angular 주입자로 그것을 등록하기 이전까지는 클래스일뿐입니다.
// #enddocregion di-6
// #docregion di-configure-injector-1
:marked
  ### 주입자 설정하기

  <a id="bootstrap"></a>
  Angular 주입자를 꼭 생성해야 하는 건 아닙니다.
  Angular는 부트스트랩 과정 중에 애플리케이션 전반에서 사용 가능한 주입자를 생성합니다.
// #enddocregion di-configure-injector-1
+makeExample('dependency-injection/ts/app/main.ts', 'bootstrap', 'app/main.ts (excerpt)')(format='.')
// #docregion di-configure-injector-2
:marked
  애플리케이션이 필요로 하는 서비스를 생성하는 **providers**를 등록하여 주입자를 설정해야 합니다.
  이 챕터에서 이후에 [프로바이더](#providers)가 무엇인지에 대해 설명할 겁니다.
  그러기 전에, 부트스트랩 중 provider를 등록하는 예제를 살펴보도록 하죠:
// #enddocregion di-configure-injector-2
+makeExample('dependency-injection/ts/app/main.1.ts', 'bootstrap')(format='.')
// #docregion di-configure-injector-3
:marked
  주입자는 이제 `HeroService`에 관해 알게 됐습니다.
  `HeroService`의 인스턴스는 전체 애플리케이션에 걸쳐 주입에 이용될 수 있습니다.

  물론 
  Of course we can't help wondering about that comment telling us not to do it this way.
  그건 동작*할 겁니다*. 그것은 단지 최상의 방식이 아닐 뿐이죠.
  부트스트랩 프로바이더 옵션은 라우팅 지원과 같은, Angular 자체의 기등록 서비스를 설정하고 재정의를 염두해둔 것입니다.

  더 나은 해결책은 애플리케이션 컴포넌트 내에서 애플리케이션 프로바이더를 등록하는 것입니다.
  `HeroService`가 *Heroes* 기능 영역 &mdash; 그외에는 사용될 곳이 없으므로 &mdash; 내에서 사용되기 때문에,
  그것을 등록시킬 이상적인 장소는 최상위 레벨인 `HeroesComponent`이 됩니다.
// #enddocregion di-configure-injector-3
// #docregion di-register-providers-1
:marked
  ### 컴포넌트 내에 프로바이더 등록하기
  다음은 `HeroService`를 등록하는 수정된 `HeroesComponent`입니다.
// #enddocregion di-register-providers-1
+makeExample('dependency-injection/ts/app/heroes/heroes.component.1.ts',null,'app/heroes/heroes.component.ts')
// #docregion di-register-providers-2
:marked
  `@Component` 메타데이터의 `providers` 파트를 자세히 보시죠:
// #enddocregion di-register-providers-2
+makeExample('dependency-injection/ts/app/heroes/heroes.component.1.ts','providers')(format='.')
// #docregion di-register-providers-3
:marked
  `HeroService`의 인스턴스는 이제 `HeroesComponent`와 그것의 모든 하위 컴포넌트에서 주입을 통해 이용 가능합니다.

  `HeroesComponent` 그 자체는 `HeroService`를 필요로 할 일이 없습니다.
  하지만 그것의 하위 컴포넌트인 `HeroListComponent`는 필요로 합니다.
// #enddocregion di-register-providers-3
// #docregion di-prepare-for-injection-1
:marked
  ### HeroListComponent에서 주입하기

  `HeroListComponent`는 주입된 `HeroService`로부터 영웅들을 가져와야 합니닫.
  의존 주입 패턴마다, [초반에 설명한대로](#ctor-injection), 컴포넌트는 생성자 내에서 해당 서비스를 요구해야 합니다.
  그것이 작은 변화죠:
// #enddocregion di-prepare-for-injection-1
+makeTabs(
  `dependency-injection/ts/app/heroes/hero-list.component.2.ts,
  dependency-injection/ts/app/heroes/hero-list.component.1.ts`,
  null,
  `app/heroes/hero-list.component (with DI),
   app/heroes/hero-list.component (without DI)`)
// Must copy the following, due to indented +make.
.l-sub-section
  :marked
    ### 생성자에 주목하세요

    생성자에 파라메터를 추가하는 것은 전부가 아닙니다.

  +makeExample('dependency-injection/ts/app/heroes/hero-list.component.2.ts', 'ctor')(format=".")

  // TypeScript only
  :marked
    우린 TypeScript로 구현하고 있어서 타입 어노테이션을 이용한 파라메터 이름 `:HeroService`를 가지게 됩니다. 
    클래스 또한 `@Component` 데코레이터를 이용해 수식되고 있죠(사실인지 확인하기 위해 스크롤해서 올라가보세요).
    TypeScript 컴파일러가 이 클래스를 평가할 때, `@Component` 데코레이터를 만나게 되면, 클래스 메타데이터를 생성된 자바스크립트 코드 내로 추가합니다.
    그 메타데이터 사이에는 `HeroService` 클래스를 이용해 `heroService` 파라메터를 연계시키는 정보가 숨겨져 있습니다.

    그것이 새로운 `HeroListComponent`를 만들 때 Angular 주입자가 `HeroService`의 인스턴스를 주입하기 위한 방법입니다.
// #docregion di-create-injector-implicitly-1
:marked
  <a id="di-metadata"></a>
  ### 주입자 생성하기(암묵적으로)
  위에서 주입자에 대한 아이디어를 소개했을 때, 주입자를 생성하고 새로운 `Car`를 만들기 위해 그것을 사용하는 방법에 대해서 보았습니다.
// #enddocregion di-create-injector-implicitly-1
+makeExample('dependency-injection/ts/app/car/car-injector.ts','injector-create-and-call')(format=".")
// #docregion di-create-injector-implicitly-2
:marked
  우리는 영웅들의 여행 혹은 다른 샘플 들에서 이와 같은 코드를 볼 수 없었습니다.
  그래야 *했다면* [명시적인 주입자를 이용한 코드](#explicit-injector)를 작성했겠지만, 그런 일은 거의 드뭅니다. 
  Angular는 컴포넌트를 생성할 때 주입자를 만들고 호출해야 할 책임이 있습니다. `<hero-list></hero-list>`와 같은 HTML 마크업이든
  [라우터](./router.html)를 이용해 컴포넌트로 이동한 이후든지 말이죠.
  Angular로 이러한 일을 하게 되면, 자동화된 의존성 주입의 혜택을 누리기 될 겁니다.
// #enddocregion di-create-injector-implicitly-2
// #docregion di-singleton-services
:marked
  ### 싱글턴 서비스
  의존성은 주입자 스코프 내에 있는 싱글턴입니다.
  예제 중에, 단일 `HeroService` 인스턴스는 `HeroesComponent`과 `HeroListComponent`라는 하위 컴포넌트 가운데 공유됩니다.
  하지만, Angular DI는 계층적 주입 시스템으로 내재된 주입자들이 자신의 서비스 인스턴스를 생성할 수 있다는 것을 의미합니다.
  [계층적 주입자](./hierarchical-dependency-injection.html) 챕터에서 그에 대해 좀 더 자세히 알아보시기 바랍니다.
// #enddocregion di-singleton-services

// Skip this for Dart, for now
// #docregion di-testing-component-1
:marked
  ### 컴포넌트 테스트하기
  의존성 주입을 위한 클래스 설계가 클래스를 테스트하기 더 쉽게 만든다고 초기에 강조했었습니다.
  생성자 파라메터로써 의존성을 나열하는 것은 우리 모두가 애플리케이션의 부분 부분들을 효과적으로 테스트하는데 필요로 하는 것이 될 겁니다. 

  예를 들어, 아래 테스트를 잘 처리할 수 있는 목(mock) 서비스를 이용해 새로운 `HeroListComponent`를 만들 수 있습니다:
// #enddocregion di-testing-component-1
+makeExample('dependency-injection/ts/app/test.component.ts', 'spec')(format='.')
// #docregion di-testing-component-2
.l-sub-section
  :marked
    [테스트하기](../testing/index.html)에서 좀 더 자세히 알아보세요.
// #enddocregion di-testing-component-2
// #docregion di-service-service-1
:marked
  ### 서비스가 서비스를 필요로 하는 경우
  `HeroService`는 매우 간단합니다. 어떤 의존성도 갖지 않지요.

  의존성을 갖는다면 어떨까요? 로깅 서비스를 통해 동작을 보고한다면 어떨까요?
  `Logger` 파라메터를 받는 생성자를 추가하는, 동일한 *생성자 주입* 패턴을 적용할 겁니다. 

  다음은 원래의 코드와 수정된 코드의 비교입니다.
  Here is the revision compared to the original.
// #enddocregion di-service-service-1
+makeTabs(
  `dependency-injection/ts/app/heroes/hero.service.2.ts,
  dependency-injection/ts/app/heroes/hero.service.1.ts`,
  null,
  `app/heroes/hero.service (v.2),
  app/heroes/hero.service (v.1)`)
// #docregion di-service-service-2
:marked
  생성자는 이제 `Logger`의 인스턴스 주입을 요구하며 그것을 `logger`라는 private 프로퍼티에 보관합니다.
  누군가가 영웅 목록을 요청하는 경우 `getHeroes` 메서드 내에서 해당 프로퍼티가 호출될 겁니다.
// #enddocregion di-service-service-2
// #docregion di-injectable-1
- var lang = current.path[1]
- var decoration = lang == 'dart' ? 'annotation' : 'decoration'
- var tsmetadata = lang == 'ts' ? 'As <a href="#di-metadata">we mentioned earlier</a>, <b>TypeScript only generates metadata for classes that have a decorator.</b>' : ''
:marked
  <a id="injectable"></a>
  ### @Injectable 일까요?
  서비스 클래스 위에 있는 `@Injectable()` #{decoration}을 보세요.
  우린 여태까지 `@Injectable()`을 본적이 없습니다.
  마침, `HeroService`의 첫번째 버전에 그것을 추가했습니다.
  우린 그것에 대해 고민할 필요가 없었는데 전에는 그것을 필요로 하지 않았기 때문이죠.

  우리는 이제 그게 필요합니다... 우리 서비스가 주입된 의존성을 갖기 때문이죠.
  Angular가 `Logger`를 주입하기 위해 생성자 파라메터 메타데이터를 요구하기 때문에 필요합니다.
// #enddocregion di-injectable-1

// #docregion di-injectable-2
- var lang = current.path[1]
- var a_decorator = lang == 'dart' ? 'an annotation' : 'a decorator'
- var decorated = lang == 'dart' ? 'annotated' : 'decorated'
- var any_decorator = lang == 'dart' ? '' : 'TypeScript는 데코레이터로 클래스에 대한 메타데이터를 생성하며, 모든 데코레이터들이 그렇게 합니다.'
.callout.is-helpful
  header 제안: 모든 서비스 클래스에 @Injectable()를 추가하세요
  :marked
    모든 서비스 클래스에 `@Injectable()`를 추가히길 권장해드립니다. 의존성을 갖지 않고 그러므로 그것을 필요로 하지 않는 서비스라도 말이죠.
    그 이유는 다음과 같습니다:
  ul(style="font-size:inherit")
    li <b>미래 대비:</b> 후에 의존성을 추가하더라도 <code>@Injectable()</code>를 기억할 필요가 없습니다.
    li <b>일관성:</b> 모든 서비스들이 동일한 규칙을 따르게 되고 #{a_decorator}가 왜 빠져있는지를 고민하지 않아도 됩니다.

  :marked
    모든 서비스 클래스에 `@Injectable` 적용을 권고한다고 해도, 그것에 얽매일 필요는 없습니다.
    어떤 개발자들은 필요로 하는 곳에만 그것을 추가하는 걸 더 선호하며, 그것 역시 충분히 타당한 정책입니다.

.l-sub-section
  :marked
    `HeroesComponent` 역시 주입된 의존성을 가지고 있습니다. `HeroesComponent`에는 왜 `@Injectable()`을 추가하지 않는걸까요?

    정말 필요하다면 그것을 추가*할 수* 있습니다.
    그것이 필요하지 않은 이유는 `HeroesCompnoent`는 이미 `@Component`로 #{decorated}됐기 때문입니다. 
    #{any_decorator}
// #enddocregion di-injectable-2
.callout.is-critical
  header Always include the parentheses
  :marked
    항상 `@Injectable`가 아닌 `@Injectable()` 사용하시기 바랍니다.
    괄호를 빼먹는다면 애플리케이션이 이상하게 실패할 겁니다.

// #docregion logger-service-1
.l-main-section
:marked
  ## 로거 서비스를 만들고 등록하기
  다음 두 단계에 걸쳐 `HeroService` 내에 로거를 주입할 겁니다:
  1. 로거 서비스를 생성하세요.
  1. 애플리케이션에 등록하세요.

  로거 서비스 구현은 대단한게 아닙니다.
// #enddocregion logger-service-1
+makeExample(
  'dependency-injection/ts/app/logger.service.ts',null, 'app/logger.service')

// Copied into Dart, due to different directory structure
:marked
  애플리케이션 내 모든 곳에서 동일한 로거 서비스를 필요로 할 거 같아서, `app/` 폴더 내에서 애플리케이션의 최상위 층에 그것을 두었고
  애플리케이션 루트 컴포넌트인 `AppComponent`에 때한 메타데이터 중 `providers`에 등록했습니다.
+makeExample('dependency-injection/ts/app/providers.component.ts','providers-logger', 'app/app.component.ts (excerpt)')
// #docregion logger-service-3
:marked
  로거 등록을 잊는다면, Angular는 로거가 처음 보이는 시점에 예외를 던지게 됩니다:
code-example(format, language="html").
  EXCEPTION: No provider for Logger! (HeroListComponent -> HeroService -> Logger)
// #enddocregion logger-service-3
// #docregion logger-service-4
:marked
  의존성 주입자가 로거에 대한 *provider*를 찾지 못했다고 Angular가 알려주는 것입니다.
  Angular는 새로운 `HeroService` 내로 주입하려는 `Logger`를 생성해 줄 provider를 필요로 합니다.
  이 서비스는 새로운 `HeroListComponent`내로 생성되어 주입될 필요가 있습니다.

  이런 연쇄적인 생성은 `Logger` provider를 통해 시작됩니다. *provider*는 다음 섹션의 주제입니다. 

  잠시만요! 로거가 부가적이라면 어떻게 하죠?
  <a id="optional"></a>
  ### 부가적인 의존성

  `HeroService`는 현재 `Logger`를 요구합니다. 로거가 없는 경우는 어떻게 하죠?
  우리가 로거를 얻을 수 있다면 그걸 사용하고, 그렇지 않다면 그냥 무시하는거죠. 그렇게 할 수 있습니다.
// #enddocregion logger-service-4

// TypeScript only?
:marked
  먼저 `@Optional()` 데코레이터를 임포트해주세요.
+makeExample('dependency-injection/ts/app/providers.component.ts','import-optional')(format='.')

// #docregion logger-service-5
- var lang = current.path[1]
- var rewrite = lang == 'dart' ? 'Just rewrite' : 'Then rewrite'
- var decorator = lang == 'dart' ? 'annotation' : 'decorator'
:marked
  private `logger` 파라메터 앞에 `@Optional()` 데코레이터로 두도록 생성자를 다시 작성해주세요.
  그렇게 하면 주입자는 `logger`가 부가적이라는 것을 알게 됩니다.
// #enddocregion logger-service-5
+makeExample('dependency-injection/ts/app/providers.component.ts','provider-10-ctor')(format='.')
// #docregion logger-service-6
:marked
  null 로거에 대해 대비하세요. 상부 어디에서도 로거를 등록하지 않았다면,
  주입자는 `null`을 주입할 겁니다. 우리는 로그하는 메서드를 가지고 있습니다.
  null 참조 예외를 피하려면 무엇을 해야 할까요?

  *아무것도 하지 않는* 로거 스텁을 교체해서 메서드 호출을 계속할 수 있을 겁니다:
// #enddocregion logger-service-6
+makeExample('dependency-injection/ts/app/providers.component.ts','provider-10-logger')(format='.')
// #docregion logger-service-7
:marked
  명백하게도, 로거가 여러 위치에서 부가적인 경우, 좀 더 세련된 해결책을 얻었습니다.

  그러나 부가적인 로거는 이걸로 충분합니다. 우리의 샘플 애플리케이션에서, `Logger`는 필수입니다.  
  우리는 다음 섹션에서 배우게 될 내용인 *providers*를 사용해 애플리케이션 주입자로 `Logger`를 등록해야 합니다.
// #enddocregion logger-service-7

// #docregion providers-1
:marked
<a id="providers"></a>
.l-main-section
:marked
  ## 주입자 프로바이더

  프로바이더는 견고하고 실시간 버전의 의존성 값을 *제공합니다*. 
  주입자가 컴포넌트와 다른 서비스 내로 주입하는 서비스의 인스턴스를 생성하기 위해 주입자는 **providers**에 의존합니다.

  우리는 반드시 주입자로 서비스 *프로바이더*를 등록해야 합니다. 그렇지 않으면 서비스를 어떻게 생성해야 하는지 알 수가 없습니다.

  초반에 다음과 같이 `AppComponent`의 메티데이터 중 `providers` 배열에 `Logger` 서비스를 생성했었습니다:
// #enddocregion providers-1
+makeExample('dependency-injection/ts/app/providers.component.ts','providers-logger')
// #docregion providers-2
- var lang = current.path[1]
- var implements = lang == 'dart' ? 'implements' : 'looks and behaves like a '
- var objectlike = lang == 'dart' ? '' : 'an object that behaves like '
- var loggerlike = lang == 'dart' ? '' : 'We could provide a logger-like object. '
:marked
  `providers` 배열은 서비스 클래스를 설정하도록 되어 있습니다.
  실제로는 서비스를 생성할 수 있는 [프로바이더](../api/core/Provider-class.html) 클래스의 인스턴스를 설정하도록 되어 있습니다.

  `Logger`처럼 보이고 행동하는 무언가를 *제공하기 위한* 여러 가지 방법이 존재합니다.
  `Logger` 클래스 자체는 분명히 그리고 그대로의 프로바이더입니다 &mdash; 올바른 모습을 하고 있고 생성할 수 있도록 고안됐습니다.
  그러나 그것만이 유일한 방법은 아닙니다.

  우리는 `Logger`처럼 해동하는 객체를 전달할 수 있는 대체 프로바이더로 주입자를 설정할 수 있습니다.
  우리는 대체 클래스를 제공할 수 있다는 것이죠.
  그 대체 클래스를 로거 팩토리 함수를 호출하는 프로바이더에게 전달할 수 있습니다.
  이런 해결책 중 어느 것이든 올바른 환경 내에서 좋은 선택이 될 수 있을 겁니다.

  `Logger`가 필요할 경우 주입자가 가져야 할 프로바이더를 가지는 것이 문제될 건 없습니다.
// #enddocregion providers-2
// #docregion providers-provide-1
:marked
  <a id="provide"></a>
// #enddocregion providers-provide-1

// Don't mention provide function in Dart
:marked
  ### *프로바이더* 클래스와 *provide* 함수
// #docregion providers-provide-1-1
:marked
  다음과 같이 `providers` 배열을 작성했었습니다:
// #enddocregion providers-provide-1-1
+makeExample('dependency-injection/ts/app/providers.component.ts','providers-1')
// #docregion providers-provide-2
:marked
  이것은 실제로 [Provider](../api/core/Provider-class.html) 클래스의 새로운 인스턴스를 생성하는 프로바이더 등록을 위한 축약형 표현식입니다.
// #enddocregion providers-provide-2
+makeExample('dependency-injection/ts/app/providers.component.ts','providers-2')
// #docregion providers-provide-3
// Skip for Dart, where the provide() function won't pass type checking.
:marked
  [provide](../api/core/provide-function.html) 함수는 `Provider`를 생성하기 위한 전형적인 방법입니다:
// #enddocregion providers-provide-3
+makeExample('dependency-injection/ts/app/providers.component.ts','providers-3')
// #docregion providers-provide-4-1
// Modified for Dart.

:marked
 또는  _객체 리터럴_ 내에 프로바이더를 선언하고 `provide` 함수를 생략할 수도 있습니다.
+makeExample('dependency-injection/ts/app/providers.component.ts','providers-3a')  

:marked
  선호하는 문법을 고르세요. 모두 동일하게 동작할 겁니다.
  
  각각의 문법에서, 두 가지 유형의 값들을 제공하게 됩니다.
// #enddocregion providers-provide-4-1
// #docregion providers-provide-4-2
:marked
  첫번째는 의존성 값에 대한 위치를 결정하고 프로바이더를 등록하기 위한 키로써 제공되는 [토큰](#token)입니다.
// #enddocregion providers-provide-4-2

// Dart is different here (uses an optional parameter)
:marked
  두번째는 프로바이더 정의 객체로, 의존성 값을 생성하기 위한 *레시피*로 생각하면 됩니다.
  의존성 값을 생성하는 방법은 여러 가지고 있고... 레시피를 작성하는 방법에도 여러 가지가 있습니다.
  
// #docregion providers-alternative-1
:marked
  <a id="class-provider"></a>
  ### 대체 클래스 프로바이더

  때때로 서비스를 제공하기 위해 다른 클래스를 요구하게 될 겁니다.
  다음 코드는 주입자에게 무언가가 `Logger`를 요청할 경우 `BetterLogger`를 반환하도록 구현된 코드입니다.
// #enddocregion providers-alternative-1
+makeExample('dependency-injection/ts/app/providers.component.ts','providers-4')
// #docregion providers-alternative-2
:marked
  ### 의존성을 이용한 클래스 프로바이더
  아마도 `EvenBetterLogger`는 로그 메시지 내에 사용자 이름을 디스플레이할 수 있을 겁니다.
  이 로거는 애플리케이션 레벨에서 주입되기도 한 이 주입된 `UserService`로부터 사용자를 가져옵니다.
// #enddocregion providers-alternative-2
+makeExample('dependency-injection/ts/app/providers.component.ts','EvenBetterLogger')(format='.')
// #docregion providers-alternative-3
:marked
  `BetterLogger`를 등록했던 것처럼 `UserService`도 설정합니다.
// #enddocregion providers-alternative-3
+makeExample('dependency-injection/ts/app/providers.component.ts','providers-5')(format=".")
// #docregion providers-aliased-1
:marked
  ### 별칭을 붙인 클래스 프로바이더

  `OldLogger` 클래스에 의존하는 오래된 컴포넌트를 가정해보죠. 
  `OldLogger`는 `NewLogger`와 동일한 인터페이스를 가지고 있지만 어떤 이유로 새로운 로거를 사용하기 위해 오래된 컴포넌트를 재작성할 수가 없습니다.

  *오래된* 컴포넌트가 `OldLogger`로 메시지를 기록할 경우,
  대신 그것을 처리하기 위해 `NewLogger의 싱글턴 인스턴스이 필요합니다.

  의존성 주입자는 컴포넌트가 새로운 혹은 예전의 로거 중 하나를 요구할 경우 해당 싱글턴 인스턴스를 주입해야 할 겁니다.

  앱에서 분명 서로 다른 두 개의 `NewLogger` 인스턴스를 원하지는 않을 겁니다. 
  운 나쁘게도, 그것이 `useClass`로 `OldLogger`를 `NewLogger`로 별칭지으려고 할 경우가 얻게 되는 결과입니다.
// #enddocregion providers-aliased-1
+makeExample('dependency-injection/ts/app/providers.component.ts','providers-6a')(format=".")
// #docregion providers-aliased-2
:marked
  해결책: `useExisting` 옵션으로 별칭짓기
// #enddocregion providers-aliased-2
+makeExample('dependency-injection/ts/app/providers.component.ts','providers-6b')(format=".")
// #docregion providers-value-1
<a id="value-provider"></a>
:marked
  ### 값 프로바이더
// #enddocregion providers-value-1

// Typescript only
:marked
  때로는 클래스로부터 만들도록 주입자에게 요청하는 것보다 미리 만들어져 있는 객체를 제공하는 것이 더 쉬울 수도 있습니다.
+makeExample('dependency-injection/ts/app/providers.component.ts','silent-logger')(format=".")
:marked
  그런 뒤에 해당 객체가 로거 역할을 하도록 만드는 `useValue` 옵션으로 프로바이더를 등록하면 됩니다.
+makeExample('dependency-injection/ts/app/providers.component.ts','providers-7')(format=".")

// #docregion providers-factory-1
<a id="factory-provider"></a>
:marked
  ### 팩토리 프로바이더

  때로는 마지막 가능한 순간까지 갖지 못할지도 모르는 정보에 기초해, 다이나믹하게 의존 값을 만들어야 할 필요가 있습니다.
  아마도 그 정보들은 브라우저 세션의 진행 과정 내에서 반복적으로 변화할 겁니다.

  주입 가능한 서비스가 이 정보의 소스에 대해 독립적인 접근하지 않는다고 다시 가정해보죠.

  이런 상황에 **팩토리 프로바이더**가 필요합니다.

  새로운 비지니스 요구사항을 추가하는 것을 예로 들어보죠:
  HeroService는 일반적인 사용자들로부터 *비밀* 영웅들을 숨겨야만 합니다.
  오로지 승인된 사용자들만이 비밀 영웅들을 볼 수 있다는 것이죠.

  `EvenBetterLogger`처럼, `HeroService`은 사용자에 관한 정보를 필요로 합니다.
  사용자가 비밀 영웅들을 볼 수 있도록 허가되었는지 알 수 있어야 하죠.
  그러한 인가는 다른 사용자로 로그인한 경우에 단일 애플리케이션 세션의 과정 중에서 변경될 수 있습니다.

  `EvenBetterLogger`와는 다르게, `HeroService` 내로 `UserService`를 주입할 수 없습니다.
  `HeroService`는 인가된게 누구이고 그렇지 않은 것이 누구인지를 결정하기 위한 사용자 정보에 직접 접근할 수가 없습니다.
.l-sub-section
  :marked
    왜 그럴까요? 우리도 모릅니다. 그냥 이와 같이 하세요.
:marked
  대신 `HeroService` 생성자는 비밀 영웅들의 디스플레이를 제어하기 위해 boolean 플래그를 받습니다.
// #enddocregion providers-factory-1
+makeExample('dependency-injection/ts/app/heroes/hero.service.ts','internals', 'app/heroes/hero.service.ts (excerpt)')(format='.')
// #docregion providers-factory-2
:marked
  `Logger`를 주입할 수 있지만 boolean 타입인 `isAuthorized`은 주입할 수가 없습니다.
  그렇기에 `HeroService`의 새로운 인스턴스 생성을 팩토리 프로바이더를 이용하도록 대체해야만 합니다.

  팩토리 프로바이더는 팩토리 함수를 필요로 합니다:
// #enddocregion providers-factory-2
+makeExample('dependency-injection/ts/app/heroes/hero.service.provider.ts','factory', 'app/heroes/hero.service.provider.ts (excerpt)')(format='.')
// #docregion providers-factory-3
:marked
  `HeroService`가 `UserService`에 접근할 수 없더라도, 팩토리 함수는 할 수 있죠.

  팩토리 프로바이더 내로 `Logger`와 `UserService`를 모두 주입하고 주입자가 그것들을 팩토리 함수에 전달하도록 했습니다:
// #enddocregion providers-factory-3
+makeExample('dependency-injection/ts/app/heroes/hero.service.provider.ts','provider', 'app/heroes/hero.service.provider.ts (excerpt)')(format='.')
// #docregion providers-factory-4
.l-sub-section
  :marked
    `useFactory` 필드는 프로바이더가 그 구현이 `heroServiceFactory`인 팩토리 함수라는 것을 Angular에게 알려줍니다.

    `deps` 프로퍼티는 [프로바이더 토큰](#token)의 배열입니다.
    `Logger`와 `UserService` 클래스는 그들 자신의 클래스 프로바이더에 대한 토큰으로써 역할을 합니다.
    주입자는 이 토큰들을 분석하고 일치하는 팩토리 함수 파라메터 내로 대응하는 서비스들을 주입합니다.
// #enddocregion providers-factory-4
// #docregion providers-factory-5
- var lang = current.path[1]
- var anexportedvar = lang == 'dart' ? 'a constant' : 'an exported variable'
- var variable = lang == 'dart' ? 'constant' : 'variable'
:marked
  익스포트된 변수인 `heroServiceProvider` 내에서 팩토리 프로바이더를 가져왔다는 것을 기억하시기 바랍니다.
  이 여분의 과정은 팩토리 프로바이더를 재사용 가능하다록 해줍니다.
  `HeroService`를 필요로 하는 곳이라면 어디든지 해당 변수를 이용해 등록할 수 있습니다.

  샘플에서, `HeroesComponent`에서만 그것을 필요로 하는데, 메타데이터인 `providers` 배열 내에서 예전의 `HeroService` 등록을 대체하도록 했습니다.
  다음은 각각 새로운 구현과 예전의 구현입니다:
// #enddocregion providers-factory-5
+makeTabs(
  `dependency-injection/ts/app/heroes/heroes.component.ts,
  dependency-injection/ts/app/heroes/heroes.component.1.ts`,
  null,
  `app/heroes/heroes.component (v.3),
  app/heroes/heroes.component (v.2)`)

// #docregion tokens-1
<a id="token"></a>
.l-main-section
:marked
  ## 의존성 주입 토큰

  주입자를 이용해 프로바이더를 등록하는 경우, 해당 프로바이더를 의존성 주입 토큰과 연계했습니다.
  주입자는 의존성을 요구하는 경우 참조 표시를 하는 내부의 *토큰-프로바이더* 맵을 관리합니다.

  이전의 모든 예제에서, 의존성 값은 클래스의 *인스턴스*가 되었으며, 클래스 *타입*은 자신의 색인 키 역할을 합니다. 
  다음 에제에서는, 토큰으로 `HeroService` 타입을 제공하여 주입자로부터 직접 `HeroService`을 가져오도록 합니다:
// #enddocregion tokens-1
+makeExample('dependency-injection/ts/app/injector.component.ts','get-hero-service')(format='.')
// #docregion tokens-2
:marked
  우리는 주입된 클래스 기반의 의존성을 요구하는 생성자를 작성하는 경우 유사한 행운을 얻게 됩니다.
  `HeroService` 클래스 타입으로 생성자 파라메터를 정의하게 되어 Angular는 해당 `HeroService` 클래스 토큰으로 연계된 서비스를 주입해야 한다는 것을 알게 됩니다:
// #enddocregion tokens-2
+makeExample('dependency-injection/ts/app/providers.component.ts','provider-8-ctor')(format=".")
// #docregion tokens-3
:marked
  대부분의 의존성 값이 클래스에 의해 제공된다고 간주할 경우 특히 편리합니다.
// #enddocregion tokens-3

// #docregion tokens-non-class-deps-1
- var lang = current.path[1]
- var objectexamples = lang == 'dart' ? 'a string or list literal, or maybe a function' : 'a string, a function, or an object'
// Is function injection useful? Should we show it?
:marked
  ### 클래스가 아닌 의존성

  의존성 값이 클래스가 아니라면 어떨까요?
  때로는 우리가 주입하고자 하는 것이 객체일 때도 있습니다.
// #enddocregion tokens-non-class-deps-1

// TS/JS only
:marked
  애플리케이션은 종종 애플리케이션의 타이틀이나 웹 API 엔드포인트 주소와 같이 수많은 작은 요소들을 가진 설정 객체를 정의하고 합니다.
  이 설정 객체들이 항상 클래스의 인스턴스는 아닙니다. 그것들은 다음과 같이 객체 해시인 경우가 많습니다:
+makeExample('dependency-injection/ts/app/app.config.ts','config','app/app-config.ts (excerpt)')(format='.')

// TypeScript only?
:marked
  이런 `config` 객체를 주입 가능하도록 만들고 싶을 겁니다.
  [값 프로바이더](#value-provider)를 이용해 객체를 등록할 수 있다는 것을 알고 있습니다.
  그러나 토큰을 사용하는 경우에는 어떻게 해야 할까요?
  우리에겐 토큰 역할을 하는 클래스가 없습니다. `Config` 클래스가 없죠.

// Typescript only
<a id="interface"></a>
.l-sub-section
  :marked
    ### TypeScript 인터페이스는 유효한 토큰이 아닙니다

    `CONFIG` 상수는 `Config`라는 인터페이스를 가지고 있습니다. 운이 나쁘게도 TypeScript 인터페이스를 토큰으로 사용할 수는 없습니다:
  +makeExample('dependency-injection/ts/app/providers.component.ts','providers-9a-interface')(format=".")
  +makeExample('dependency-injection/ts/app/providers.component.ts','provider-9a-ctor-interface')(format=".")
  :marked
    인터페이스가 우선되는 의존성 색인 키인 강력한 형식 언어 내에서 의존성 주입을 사용해왔다면 그것이 이상하게 느껼질 겁니다.

    그것은 Angular의 문제가 아닙니다. 인터페이스는 TypeScript 설계에 따른 결과물입니다. JavaScript는 인터페이스를 가지고 있지 않죠.
    TypeScript 인터페이스는 생성된 자바스크립트에서는 존재하지 않습니다.
    실행 시에는 Angular에 대해 남아 있는 인터페이스 타입 정보가 존재하지 않습니다.
// end Typescript only

// #docregion tokens-opaque-1
<a id="opaque-token"></a>
- var lang = current.path[1]
- var opaquetoken = lang == 'dart' ? '<code>OpaqueToken</code>' : '<a href="../api/core/OpaqueToken-class.html"><code>OpaqueToken</code></a>'
h3 OpaqueToken
p.
  이 해결책은 !{opaquetoken}을 정의하고 사용하는 것입니다.
  정의는 다음과 같을 겁니다:
// #enddocregion tokens-opaque-1
+makeExample('dependency-injection/ts/app/app.config.ts','token')(format='.')
:marked
  `OpaqueToken` 객체를 사용해 의존성 프로바이더를 등록해보았습니다:
+makeExample('dependency-injection/ts/app/providers.component.ts','providers-9b')(format=".")
// #docregion tokens-opaque-2
- var lang = current.path[1]
- var decorated = lang == 'dart' ? 'annotated' : 'decorated'
- var configuration = lang == 'dart' ? '' : 'configuration'
:marked
  이제 우리가 설정 객체를 필요로 하는 어떤 생성자에든, 설정 의존성 값을 찾을 수 있는 방법을 Angular에게 알려주는 `@Inject` 데코레이터의 도움으로,
  설정 객체를 주입할 수 있습니다.
// #enddocregion tokens-opaque-2
+makeExample('dependency-injection/ts/app/providers.component.ts','provider-9b-ctor')(format=".")

// begin Typescript only
.l-sub-section
  :marked
    그것이 의존성 주입에 있어 아무런 역할도 하지 않더라도, `Config` 인터페이스는 클래스 사이에서 설정 객체에 대한 강력한 타입을 제공합니다.
:marked
// end typescript only

// Skip for Dart (we have another example)
:marked
  혹은 최상위 계층인 `AppComponent` 내에 설정 객체를 제공하고 주입할 수 도 있습니다.
+makeExample('dependency-injection/ts/app/app.component.ts','providers', 'app/app.component.ts (providers)')(format=".")
+makeExample('dependency-injection/ts/app/app.component.ts','ctor', 'app/app.component.ts (constructor)')(format=".")

// #docregion summary
.l-main-section
:marked
  ## 요약
  우리는 이 챕터에서 Angular 의존성 주입의 기초를 알아보았습니다.
  우리는 다양한 종류의 프로바이더를 등록할 수 있으며, 생성자에 파라메터를 추가하여 주입 객체(서비스와 같은)를 요청하는 방법에 대해 알게 되었습니다.

  Angular 의존성 주입은 우리가 설명한 것보다 더 유용합니다.
  내제된 주입자의 지원으로 시작되는, 진보된 기능들에 관해서도 [계층적 의존성 주입](hierarchical-dependency-injection.html) 챕터에서 알아볼 수 있습니다.
// #enddocregion summary

// #docregion appendix-explicit-injector-1
.l-main-section
<a id="explicit-injector"></a>
:marked
  ### 부록: 주입자를 직접적으로 이용하기
  우리는 거의 주입자를 직접적으로 이용하지 않았습니다.
  다음의 `InjectorComponent`는 주입자를 직접 이용하도록 만들어졌습니다.
// #enddocregion appendix-explicit-injector-1
+makeExample('dependency-injection/ts/app/injector.component.ts', 'injector', 'app/injector.component.ts')
// #docregion appendix-explicit-injector-2
:marked
  `Injector`는 그 자체로 주입가능한 서비스입니다.

  이 예제에서, Angular는 컴포넌트 생성자 안으로 컴포넌트 자체의 `Injector`를 주입하고 있습니다.
  그런 뒤 컴포넌트는 그것이 원하는 서비스에 대해 주입된 주입자를 요청합니다.

  서비스 자체가 컴포넌트 내로 주입되지 않는다는 것을 알아두시기 바립니다.
  `injector.get` 호출을 통해 그것들은 가져오고 있습니다.

  요청된 서비스를 해석하지 못한다면 `get` 메서드는 에러를 던질 겁니다.
  대신 두번째 파라메터(서비스를 찾지 못한 경우 반환될 값)와 함께 `get`을 호출할 수 있는데,
  예에서 해당 주입자 혹은 어떤 상위 주입자에도 등록되어 있지 않은 서비스(`ROUS`)를 가져오는 경우에 해당됩니다.

.l-sub-section
  :marked
    방금 설명한 기술은 
    [서비스 로케이터 패턴](https://en.wikipedia.org/wiki/Service_locator_pattern)의 예입니다.

    우린 정말로 필요한 경우가 아니라면 이 기술을 **피해야 합니다**.
    이 기술은 여기서 본 것처럼 주의깊지 못한 grab-bag 접근법을 부추깁니다.
    설명하기도 이해하기도 테스트하기도 어렵습니다.
    생성자를 봐서는 이 클래스가 요구하는 것이나 해야 할 것을 알아낼 수가 없습니다.
    그 자신뿐만 아니라, 어떤 상위 컴포넌트에서든지 서비스를 가져올 수 있습니다.
    그것이 무엇을 하는지 알아내기 위해 구현 내부를 들여다 볼 수 밖에 없습니다.

    프레임워크 개발자들은 그들이 일반적으로 그리고 다이나믹하게 서비스를 가져와야 하는 경우에만 이 접근법을 취할 겁니다.
// #enddocregion appendix-explicit-injector-2

// TypeScript only? Unnecessary for Dart
.l-main-section
<a id="forward-ref"></a>
:marked
  ### 부록: 파일 하나 당 한 개의 클래스를 권하는 이유

  동일 파일 내에 다중 클래스를 두는 것은 혼란스러우며 최선이 아닙니다.
  개발자들은 파일 하나 당 한 개의 클래스를 예상할 겁니다. 그들이 예상한 대로 되게 해주세요.
  
  이러한 충고를 비웃고 하나의 파일 내에 `HeroService`를 `HeroesComponent`와 함께 두려고 한다면,
  **컴포넌트를 뒤에 정의하세요!**
  
  서비스 이전에 컴포넌트를 정의하는 경우, 런타임 null 참조 오류를 보게 될 겁니다.

.l-sub-section
  :marked
    [블로그 포스트](http://blog.thoughtram.io/angular/2015/09/03/forward-references-in-angular-2.html)에서 설명한 대로
    `forwardRef()` 메서드를 통해 컴포넌트를 먼저 정의할 수도 있습니다. 왜 그런 위험을 감수하는 겁니까? 컴포넌트와 서비스를 분리된 파일에 두어서
    그런 문제를 피하도록 하는게 좋습니다.
