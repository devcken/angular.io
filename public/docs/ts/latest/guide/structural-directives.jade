block includes
  include ../_util-fns

:marked
  단일 페이지 애플리케이션(single page application)의 정의 기능 중 하나가 DOM 트리 취급입니다.
  사용자가 네비게이트할 때마다 전체 페이지를 새로 서브하는 대신에,
  DOM의 전체 섹션은 애플리케이션의 상태에 따라 나타나기도 하고 사라지기도 합니다.
  이 챕터에서 우리는 Angular가 DOM을 다루는 방법과 우리가 직접 디렉티브를 통해 DOM을 다루는 방법에 대해서 알아보고자 합니다.

  이 챕터에서 우리는
  - [구조적 디렉티브가 무엇인지를 배우고](#definition)
  - [*ngIf*을 공부해보고](#ngIf)
  - [discover the &lt;template> 요소를 발견하고](#template)
  - [**ngFor*의 아스테리스크(\*)를 이해하고](#asterisk)
  - [직집 구조적 디렉티브를 작성해보겠습니다](#unless)

p Try the #[+liveExampleLink2()].

<a id="definition"></a>
.l-main-section
:marked
  ## 구조적 디렉티브는 무엇일까요?

  Angular 디렉티브에는 세 가지 종류가 있습니다:
  1. 컴포넌트
  1. 어트리뷰트 디렉티브
  1. 구조적 디렉티브

  *컴포넌트*는 실제로 템플릿을 가진 디렉티브입니다.
  그것은 세가지 디렉티브의 공통적인 내용이며 애플리케이션을 빌드하면서 꽤 많은 디렉티브들을 작성하게 됩니다.

  [*어트리뷰트* 디렉티브](attribute-directives.html)는 요소의 모양새 혹은 동작을 변경합니다.
  예를 들어, 빌트인 [NgStyle](template-syntax.html#ngStyle) 디렉티브는 동시에 몇 가지 요소 스타일을 변경할 수 있습니다.
  어떤 불쾌한 결과를 요청하는 컴포넌트 프로퍼티에 바인딩하여 텍스트를 볼드, 이탤릭, 그리고 라임 그린으로 렌더링하는데 그것을 사용할 수 있습니다.

  *구조적* 디렉티브는 DOM 요소를 추가하거나 제거하여 DOM 레이아웃를 변경합니다.
  우리는 다른 챕터에서 세 가지 빌트인 구조적 디렉티브([ngIf](template-syntax.html#ngIf), [ngSwitch](template-syntax.html#ngSwitch) 그리고 [ngFor](template-syntax.html#ngFor))를 본 적이 있습니다.

+makeExample('structural-directives/ts/app/structural-directives.component.html', 'structural-directives')(format=".")


<a id="ngIf"></a>
.l-main-section
:marked
  ## NgIf 사례 연구

  `ngIf`를 살펴보죠. 그것은 구조적 디렉티브의 훌륭한 예제입니다: boolean을 받고 DOM을 보여주거나 사라지게 하기 위한 전체 청크를 만들죠.

+makeExample('structural-directives/ts/app/structural-directives.component.html', 'ngIf')(format=".")

:marked
  `ngIf` 디렉티브는 요소를 감추지 않습니다.
  브라우저 개발자 도구를 사용하여 조건이 참이 되면 상위 단락이 DOM 내에 나타나고 아래에 사용되지 않는 단락은 DOM에서 완전히 사라지게 됩니다!
  그것들은 비어있는 `<script>` 태그에 위치합니다.

figure.image-display
  img(src='/resources/images/devguide/structural-directives/element-not-in-dom.png' alt="element not in dom")

:marked
  ### 왜 *감추지* 않고 *제거*하는 걸까요?
  CSS의 `display` 스타일을 `none`으로 설정하여 원치않는 단락을 숨길 수 있었습니다.
  요소는 보이지 않지만 DOM 내에 남아있게 되죠. `ngIf`로 그걸 제거하는 대신에 말이죠.

  차이점이 있죠. 요소를 감추게 되면, 컴포넌트의 행동은 지속됩니다.
  여전히 해당 요소는 DOM 요소에 붙어있게 됩니다. 이벤트도 계속해서 구독하게 됩니다. 
  Angular는 데이터 바인딩에 영향을 줄 수 있는 변경 사항을 계속해서 검사하게 됩니다.
  컴포넌트가 유지하려고 하는 것을 계속 하든지 말든지 말이죠.

  보이지 않음에도, 컴포넌트 &mdash; 그리고 모든 하위 컴포넌트 &mdash;는 다른 곳에서 더 유용하게 쓰일지도 모를 자원들을 붙들고 있게 됩니다.
  성능과 메모리 부하는 상당해지고 사용자는 전혀 이득을 얻지 못합니다.

  긍정적인 면을 보자면, 다시 요소를 보여줄 때 매우 빠릅니다.
  컴포넌트의 이전 상태는 보존되어 있을 것이고 디스플레이할 준비가 되어 있을 겁니다.
  컴포넌트는 비용이 많이 들 수 있는 기능을 다시 초기화하지는 않습니다. 

  `ngIf`는 다릅니다.
  `ngIf`를 거짓으로 설정하게 되면 컴포넌트의 자원 소비에 영향을 **주지 않습니다**.
  Angular는 DOM에서 요소를 제거하고 연관된 컴포넌트에 대한 변경 감지를 멈추고, DOM 이벤트(요소가 만든)에서 분리시킨 뒤, 컴포넌트를 소거시킵니다.
  컴포넌트는 가비지 콜렉팅(우리가 원하는 데로)되고 메모리는 반환될 수 있습니다. 

  컴포넌트는 하위 컴포넌트를 갖는 자신의 하위 컴포넌트를 포함할 수 있습니다. 
  `ngIf`가 공통의 상위 컴포넌트를 소거하게 되면 그 모든 것들도 함께 소거됩니다.
  이런 클린업의 노력은 대개의 경우 좋은 일입니다.

  물론 *항상* 좋은 것은 아닙니다.
  그 특유의 컴포넌트가 곧 다시 필요하게 되면, 좋지 않은 결과가 됩니다.

  컴퍼넌트의 상태는 다시 만들기에는 고비용이 될 수 있습니다.
  `ngIf`가 다시 `true`가 되면, Angular는 컴포넌트와 그것의 하위 트리를 다시 만들게 됩니다.
  Angular는 모든 컴포넌트의 초기화 로직를 다시 실행합니다.
  그건 매우 비싸질 수 있습니다 ... 컴포넌트가 불과 얼마전에 메모리에 가지고 있던 데이터를 다시 가져와야 하니 말이죠.
.l-sub-section
  :marked
    *설계 상의 생각*: 초기화에 드는 노력을 최소화하고 짝을 이루는 서비스 내에서의 상태 캐시를 생각해보자.
:marked
  각각의 접근 방법에 장단점이 있다해도, 일반적으로 감추는 것보다는 원치않는 컴포넌트를 제거하기 위해 `ngIf`를 사용하는 것이 더 나은 방법이고 그것이 최선의 방법입니다.  

  **이런 동일한 가정은 빌트인이든 커스텀이든 모든 구조적 디렉티브에 적용됩니다.**
  우리는 요소를 추가하거나 제거하는 것과 컴포넌트를 생성하거나 소거시키는 것의 중대함에 관해 주의 깊게 생각하도록 우리 자신 &mdash; 그리고 디렉티브의 사용자 &mdash;에게 요구해야 합니다. 

  예제를 통해 이런 힘들을 느껴보도록 하죠. 재미를 위해, 우리의 권고 사항에 반대되는 속임수를 쓸 것이고
  초기화 시에 무수히 많은 데이터를 로드하는 **척하는**, `heavy-loader`라고 부르는 컴포넌트로 간주하도록 하겠습니다.

  우리는 컴포넌트 인스턴스 두 개를 디스플레이할 겁니다.
  CSS로 첫번째 인스턴스의 visibility를 토글할 것이고 두번째 인스턴스는 `ngIf`로 DOM 내외로 토글할 것입니다.

+makeTabs(
    `structural-directives/ts/app/structural-directives.component.html,
    structural-directives/ts/app/heavy-loader.component.ts`,
    'message-log,',
    'template (excerpt), heavy-loader.component.ts')

:marked
  빌트인 `ngOnInit` 그리고 `ngOnDestroy` [lifecycle hooks](lifecycle-hooks.html)을 사용하여
  컴포넌트가 생성되거나 소거될 때 그 내용도 기록합니다.
  다음은 그 예제입니다:

figure.image-display
  img(src='/resources/images/devguide/structural-directives/heavy-loader-toggle.gif' alt="heavy loader toggle")

:marked
  두 컴포넌트 모두 시작 시에 DOM 내에 위치합니다.
  먼저 컴포넌트의 visibility를 반복적으로 토글해보죠. 이런 경우 컴포넌트는 결코 DOM에서 사라지지 않습니다.
  컴포넌트가 보이게 되면 그것은 항상 동일한 인스턴스이며 아무것도 기록되지 않습니다.
  
  그리고 `ngIf`를 이용한 두번째 컴포넌트를 토글해보겠습니다.
  이 경우 매번 새로운 인스턴스를 생성하게 되고 컴포넌트의 인스턴스를 만들고 소거하는데 꽤나 많은 비용이 든다는 것을 로그로 알 수 있습니다. 

  이와 같은 컴포넌트를 실제로 "깜박거리고" 싶었다면, visibility 토글이 더 나은 선택일 것입니다.
  대부분의 UI에서 오랜 시간 동안 혹은 영원히 다시 보지 않을 컴포넌트를 "닫는"다는 경우라면, `ngIf`가 더 나은 선택일 것입니다

<a id="template"></a>
.l-main-section
:marked
  ## *&lt;template>* 태그

  `ngIf`와 같은 구조적 디렉티브는 [HTML 5 템플릿 태그](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template)를
  사용해 마법을 부립니다.

  Angular 앱 외부에서, `<template>` 태그의 `dislay` CSS 프로퍼티의 기본값은 `none`입니다.
  그 내용은 숨겨진 [문서 프래그먼트](https://developer.mozilla.org/en/docs/Web/API/DocumentFragment) 내에서 ***보이지 않습니다***.

  앱 내에서, Angular는 `<template>` 태그와 그것의 하위 요소들을 ***제거합니다***.
  내용은 날라가 버리지만, 잃어버리는 것은 아니므로 언젠가 다시 볼 수 있습니다. 

  우리는 이런 효과를 `<template>` 태그 내에서 "Hip! Hip! Hooray!"라는 구문의 가운데 "hip"을 래핑하여 확인할 수 있습니다.
+makeExample('structural-directives/ts/app/structural-directives.component.html', 'template-tag')(format=".")
:marked
  짧게 열광하는 소리인 'Hip! Hooray!'이 디스플레이됩니다. DOM의 영향은 Angular가 제어할 때와는 좀 다릅니다.
figure.image-display
  img(src='/resources/images/devguide/structural-directives/template-in-out-of-a2.png' alt="template outside angular")

:marked
  분명히 Angular는 `<template>` 태그와 그것의 내용을 비어있는 `<script>` 태그에 넣습니다.
  그것이 바로 Angular의 기본 동작입니다.
  `<template>` 태그에 `ngSwitch` 디렉티브의 변형을 적용했을 때 봤던 것처럼 조금 변화를 줄 수 있습니다:

+makeExample('structural-directives/ts/app/structural-directives.component.html', 'ngSwitch')(format=".")
:marked
  그들 중 `ngSwitch`의 조건이 참인 경우, Angular는 DOM 내로 템플릿의 내용을 삽입하게 됩니다.

  무엇이 `ngIf`와 `ngFor`와 함께 이런 일을 가능하게 하는 걸까요?
  우린 이런 디렉티브들을 사용할 때 `<template>` 태그를 사용하지 않습니다.

<a id="asterisk"></a>
.l-main-section
:marked
  ## 아스테리스크(\*) 효과
  여기서 다시 그 디렉티브들을 보겠습니다. 차이점이 보이나요.

+makeExample('structural-directives/ts/app/structural-directives.component.html', 'asterisk')(format=".")
:marked
  이 디렉티브들의 이름에 아스테리스크(\*)를 접두사로 두고 있습니다.

  아스테리스크는 "문법적 마약"입니다. 그것은 writer와 reader 모두에 대해 `ngIf`와 `ngFor`를 간소화시켜줍니다.
  내부 깊숙한 곳에서 Angular는 아스테리스크 버전을 좀 더 장황한 `<template>` 형태로 대체합니다.

  다음 두 개의 `ngIf`에 대한 예제는 효과적으로는 동일하면서 다르게 쓸 수 있는 스타일을 보여줍니다:

+makeExample('structural-directives/ts/app/structural-directives.component.html', 'ngIf-template')(format=".")

:marked
  우리 중 대부분은 (A) 스타일을 더 선호할 겁니다.

  Angular가 (A) 스타일을 (B) 스타일로 확장한다는 것은 알만한 가치가 있습니다.
  Angular는 단락과 그것의 내용을 `<template>` 태그 내로 이동시킵니다.
  또, 해당 디렉티브를 프로퍼티 바인딩이 이루어지는 `<template>` 태그 상으로 대괄호로 감싸 옮깁니다.
  호스트 컴포넌트의 `condition` 프로퍼티의 boolean 값은 템플릿화된 컨텐츠를 디스플레이할지 말지를 결정합니다.

  Angular는 `*ngFor`를 유사한 방식으로 변형합니다:

+makeExample('structural-directives/ts/app/structural-directives.component.html', 'ngFor-template')(format=".")
:marked
  기본 패턴은 동일합니다: `<template>`을 생성하고, 컨텐츠의 위치를 옮긴 뒤에, 디렉티브를 `<template>`으로 옮기는 것 말이죠.

  여기에는 부가적인 `ngForOf` 프로퍼티 바인딩(iterable) 그리고 `hero`라는 템플릿 입력 변수(각 반복 내의 현재 아이템) 내로 확장되는
  Angular의 [ngFor 마이크로문법](template-syntax.html#ngForMicrosyntax)에 따른 특별하고 미묘한 차이가 있습니다.

<a id="unless"></a>
.l-main-section
:marked
  ## 구조적 디렉티브를 만들어보세요
  `ngIf`의 악의없는 쌍둥이인 `Unless`라고 하는 구조적 디렉티브를 직접 만들어 보죠.

  `true`일 때 템플릿 컨텐츠를 디스플레이하는 `ngIf`와는 다르게,
  우리의 디렉티브는 조건이 ***거짓***인 경우 컨텐츠를 디스플레이하게 만들겁니다.

block unless-intro
  :marked
    디렉티브를 만드는 것은 컴포넌트를 만드는 것과 유사합니다.
    * `Directive` 데코레이터를 임포트하세요.

    * 우리의 디렉티브를 인식할 CSS **어트리뷰트 셀렉터**(대괄호 안에 넣게 될)를 추가하세요.

    * 바인딩을 위해 public `input` 프로퍼티의 이름을 지정합니다
    (일반적으로는 디렉티브 자신의 이름이 됩니다).

    * 구현 클래스에 데코레이터를 적용합니다.

    다음은 우리가 만들고자 하는 디렉티브의 겉모습입니다:

+makeExample('structural-directives/ts/app/unless.directive.ts', 'unless-declaration', 'unless.directive.ts (excerpt)')(format=".")
.l-sub-section
  :marked
    ### 셀렉터 브래킷 [&nbsp;]
    어트리뷰트를 선택하기 위한 CSS 문법은 대괄호 안에 이름을 넣는 것입니다. 
    우리는 우리가 만드는 디렉티브의 이름을 대괄호 안에 넣을 겁니다. [치트 시트](cheatsheet.html)에서 *디렉티브 설정*을 참고하시기 바랍니다.  

    ### 셀렉터 이름의 접두사
    우리는 셀렉터 이름이 현재가 됐든 미래의 언제가 됐든, 표준 HTML 어트리뷰트와 충돌하는 것을 방지하도록 접두사를 붙이는 것을 권고하고 있습니다.

    우리는 `unless` 디렉티브 이름을 **`ng`**으로 접두사화하지 **않았는데**,
    그 접두사가 Angular에 속한 것이고 우리의 디렉티브가 Angular의 디렉티브와 혼동되는 걸 원치 않았기 때문입니다.

    그래서 우리의 접두사는 `my`입니다.
:marked
  우리는 템플릿에 대한 접근*과* 그것의 내용을 렌더링할 수 있는 무언가가 필요할 겁니다.
  우리는 템플릿에 `TemplateRef`로 접근합니다. 렌더러는 `ViewContainerRef`가 담당합니다.
  그 두 개를 private 변수로 생성자에 주입시키도록 합니다.

+makeExample('structural-directives/ts/app/unless.directive.ts', 'unless-constructor')(format=".")

:marked
  이 디렉티브의 사용처에서 디렉티브의 `myUnless` 입력 프로퍼티에 boolean 값을 바인딩할 겁니다.  
  디렉티브는 그 값에 근거해 템플릿을 추가하거나 제거합니다.

  `myUnless` 프로퍼티를 이제 setter만 있는 프로퍼티로 추가해보죠.

+makeExample('structural-directives/ts/app/unless.directive.ts', 'unless-set')(format=".")
.l-sub-section
  :marked
    `@Input()` 애노테이션은 이 프로퍼티를 디렉티브의 입력으로 표시합니다.
:marked
  특별할 건 없습니다: 조건이 거짓이면 템플릿을 렌더링하고 그게 아니면 요소 내용을 깨끗이 제거할 겁니다.

  최종 결과물은 다음과 같습니다:

+makeExample('structural-directives/ts/app/unless.directive.ts', null, 'unless.directive.ts')

:marked
  이제 우리는 그것을 호스트 컴폰넌트의 `directives` 배열에 넣고 실행해보면 됩니다.
  먼저 테스트할 HTML을 템플릿에 추가해보겠습니다:

+makeExample('structural-directives/ts/app/structural-directives.component.html', 'myUnless')(format=".")
:marked
  그것을 실행시키면 예상한데로 동작할겁니다. `ngIf`와 반대로 말이죠.
  `condition`이 `true`면, 상위 단락은 제거되고(`<script>` 태그로 대체되고) 하위 단락이 나타날 겁니다.
figure.image-display
  img(src='/resources/images/devguide/structural-directives/myUnless-is-true.png' alt="myUnless is true" )

:marked
  우리의 `myUnless` 디렉티브는 극도로 간단합니다. 분명히 우리는 무언가 했습니다.
  확실히 `ngIf`가 좀 더 복잡할까요?

  [소스 코드를 보세요](https://github.com/angular/angular/blob/master/modules/%40angular/common/src/directives/ng_if.ts).
  문서화가 잘 되어 있으며 무엇이 어떻게 돌아가는 건지 알고 싶을 경우 소스를 참고해도 괜찮습니다.

  `ngIf`도 그리 다르지 않습니다!
  몇 가지 성능 향상을 위한(필요하지 않은 경우에 뷰를 제거하지 않거나 다시 만들지 않기 위한) 추가적인 점검들이 있긴 하지만 그들은 꽤나 비슷합니다.

.l-main-section
:marked
  ## 다시 돌아보기
  다음은 이 챕터와 관련된 소스 코드들입니다.

+makeTabs(`
  structural-directives/ts/app/unless.directive.ts,
  structural-directives/ts/app/heavy-loader.component.ts,
  structural-directives/ts/app/structural-directives.component.ts,
  structural-directives/ts/app/structural-directives.component.html
  `,
  null,
  `unless.directive.ts,
   heavy-loader.component.ts,
   structural-directives.component.ts,
   structural-directives.component.html
   `)
:marked
  `ngFor`와 `ngIf`와 같은 구조적 디렉티브로 HTML 레이아웃을 다르는 법을 배웠고 그와 비슷한 `myUnless`라고 하는 구조적 디렉티브를 직접 작성해보았습니다.

  Angular는 외부의 컨텐츠를 받아 그 컨텐츠를 템플릿 내에 만들어내는 *구조적 컴포넌트*와 같은 레이아웃을 관리하기 위한 좀 더 세련된 기술들을 제공합니다. 
  Tab과 tab pane 컨트롤은 좋은 예제입니다.

  이후 챕터에서 구조적 컴포넌트에 관해 배워보도록 하겠습니다.
